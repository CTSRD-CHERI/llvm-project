// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %cheri_purecap_cc1 %s -std=c++14 -emit-llvm -o - -verify
// RUN: %cheri_purecap_cc1 %s -std=c++14 -DCODEGEN -emit-llvm -o - | FileCheck %s
/// Bitfields with underlying type __uintcap_t used to cause assertions. Found while compiling qdatetime.cpp for purecap ABI
/// TODO: we should be able to generate code for this (truncating to 64 bits), but for
/// now emitting an error is better than crashing since this is a rather niche use case.

typedef __intcap_t qintptr;
typedef __uintcap_t quintptr;

#ifndef CODEGEN
struct AnonBitfield {
  quintptr : 8; // expected-error{{anonymous bit-field has capability type 'quintptr' (aka 'unsigned __intcap'); this is not supported yet}}
};

struct ShortDataIntptr {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  quintptr status : 8;
#endif
  qintptr msecs : sizeof(void *) * 8L - 8;
  // expected-error@-1{{bit-field 'msecs' has capability type 'qintptr' (aka '__intcap'); this is not supported yet}}
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
  quintptr status : 8; // expected-error{{bit-field 'status' has capability type 'quintptr' (aka 'unsigned __intcap'); this is not supported yet}}
#endif
};

void setMsecsIntptr(ShortDataIntptr *data, long f) {
  data->msecs = f;
  data->msecs = qintptr(f);
  data->status = 24;
}
#endif

struct ShortDataLong {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  unsigned long status : 8;
#endif
  unsigned long msecs : sizeof(void *) * 8L - 8;
  // expected-warning@-1{{width of bit-field 'msecs' (120 bits) exceeds the width of its type; value will be truncated to 64 bits}}
#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
  unsigned long status : 8;
#endif
};

// CHECK-LABEL: define {{[^@]+}}@setMsecsLong
// CHECK-SAME: ([[STRUCT_SHORTDATALONG:%.*]] addrspace(200)* [[DATA:%.*]], i64 signext [[F:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA_ADDR:%.*]] = alloca [[STRUCT_SHORTDATALONG]] addrspace(200)*, align 16, addrspace(200)
// CHECK-NEXT:    [[F_ADDR:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    store [[STRUCT_SHORTDATALONG]] addrspace(200)* [[DATA]], [[STRUCT_SHORTDATALONG]] addrspace(200)* addrspace(200)* [[DATA_ADDR]], align 16
// CHECK-NEXT:    store i64 [[F]], i64 addrspace(200)* [[F_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, i64 addrspace(200)* [[F_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load [[STRUCT_SHORTDATALONG]] addrspace(200)*, [[STRUCT_SHORTDATALONG]] addrspace(200)* addrspace(200)* [[DATA_ADDR]], align 16
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast [[STRUCT_SHORTDATALONG]] addrspace(200)* [[TMP1]] to i128 addrspace(200)*
// CHECK-NEXT:    [[TMP3:%.*]] = zext i64 [[TMP0]] to i128
// CHECK-NEXT:    [[BF_LOAD:%.*]] = load i128, i128 addrspace(200)* [[TMP2]], align 8
// CHECK-NEXT:    [[BF_VALUE:%.*]] = and i128 [[TMP3]], 1329227995784915872903807060280344575
// CHECK-NEXT:    [[BF_SHL:%.*]] = shl i128 [[BF_VALUE]], 8
// CHECK-NEXT:    [[BF_CLEAR:%.*]] = and i128 [[BF_LOAD]], 255
// CHECK-NEXT:    [[BF_SET:%.*]] = or i128 [[BF_CLEAR]], [[BF_SHL]]
// CHECK-NEXT:    store i128 [[BF_SET]], i128 addrspace(200)* [[TMP2]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[F_ADDR]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP4]]
// CHECK-NEXT:    [[TMP6:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP5]])
// CHECK-NEXT:    [[TMP7:%.*]] = load [[STRUCT_SHORTDATALONG]] addrspace(200)*, [[STRUCT_SHORTDATALONG]] addrspace(200)* addrspace(200)* [[DATA_ADDR]], align 16
// CHECK-NEXT:    [[TMP8:%.*]] = bitcast [[STRUCT_SHORTDATALONG]] addrspace(200)* [[TMP7]] to i128 addrspace(200)*
// CHECK-NEXT:    [[TMP9:%.*]] = zext i64 [[TMP6]] to i128
// CHECK-NEXT:    [[BF_LOAD1:%.*]] = load i128, i128 addrspace(200)* [[TMP8]], align 8
// CHECK-NEXT:    [[BF_VALUE2:%.*]] = and i128 [[TMP9]], 1329227995784915872903807060280344575
// CHECK-NEXT:    [[BF_SHL3:%.*]] = shl i128 [[BF_VALUE2]], 8
// CHECK-NEXT:    [[BF_CLEAR4:%.*]] = and i128 [[BF_LOAD1]], 255
// CHECK-NEXT:    [[BF_SET5:%.*]] = or i128 [[BF_CLEAR4]], [[BF_SHL3]]
// CHECK-NEXT:    store i128 [[BF_SET5]], i128 addrspace(200)* [[TMP8]], align 8
// CHECK-NEXT:    [[TMP10:%.*]] = load [[STRUCT_SHORTDATALONG]] addrspace(200)*, [[STRUCT_SHORTDATALONG]] addrspace(200)* addrspace(200)* [[DATA_ADDR]], align 16
// CHECK-NEXT:    [[TMP11:%.*]] = bitcast [[STRUCT_SHORTDATALONG]] addrspace(200)* [[TMP10]] to i128 addrspace(200)*
// CHECK-NEXT:    [[BF_LOAD6:%.*]] = load i128, i128 addrspace(200)* [[TMP11]], align 8
// CHECK-NEXT:    [[BF_CLEAR7:%.*]] = and i128 [[BF_LOAD6]], -256
// CHECK-NEXT:    [[BF_SET8:%.*]] = or i128 [[BF_CLEAR7]], 24
// CHECK-NEXT:    store i128 [[BF_SET8]], i128 addrspace(200)* [[TMP11]], align 8
// CHECK-NEXT:    ret void
//
extern "C" void setMsecsLong(ShortDataLong *data, long f) {
  data->msecs = f;
  data->msecs = qintptr(f);
  data->status = 24;
}
