// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 -Wno-cheri -disable-O0-optnone -emit-llvm %s -o - \
// RUN:   | opt -S -mem2reg | FileCheck %s

// This would previously crash Clang, as it would erroneously continue walking
// up past the implicitly-dereferencing (the reference) MemberExpr, incorrectly
// seeing 's' as the base, of type 'struct S', rather than the correct 's.p' of
// type 'char & __capability'. Sema would therefore think this was valid code,
// giving a 'char *', but during CodeGen it would get a 'char * __capability'
// instead and crash.
// See: https://github.com/CTSRD-CHERI/llvm-project/issues/363 for a related
// issue that inspired this test.
//
// The fix for this then erroneously looked at arrows before reference members,
// causing the second test to crash in the same way. The third test using a
// reference to the struct is added for completeness.

extern "C" {

struct S {
  char & __capability p;
};

// CHECK-LABEL: @dot(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 16
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[S]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* [[S_COERCE:%.*]], i8 addrspace(200)** [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[S]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)** [[P]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast i8 addrspace(200)* [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
char *dot(struct S s) {
  return (char *)&s.p;
}

// CHECK-LABEL: @arrow(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], %struct.S* [[S:%.*]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)** [[P]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast i8 addrspace(200)* [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
char *arrow(struct S *s) {
  return (char *)&s->p;
}

// CHECK-LABEL: @ref_dot(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], %struct.S* [[S:%.*]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)** [[P]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast i8 addrspace(200)* [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
char *ref_dot(struct S &s) {
  return (char *)&s.p;
}

}; // extern "C"
