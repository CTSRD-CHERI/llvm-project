// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 -std=c++11 -x c++ -emit-llvm -o - %s | %cheri_FileCheck %s

// Check that constant initialization works even for binary operations
class A {
  public:
    static const __uintcap_t thinFlag = 1;
    static const __uintcap_t reservedFlag = 2;
    static const __uintcap_t flags = thinFlag | reservedFlag;
};

// CHECK-LABEL: @_Z1fv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = alloca [[CLASS_A:%.*]], align 1
// CHECK-NEXT:    [[X:%.*]] = alloca i8 addrspace(200)*, align 16
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1), i8 addrspace(200)** [[X]], align 16
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 2), i8 addrspace(200)** [[X]], align 16
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 3), i8 addrspace(200)** [[X]], align 16
// CHECK-NEXT:    ret void
//
void f() {
  A a;
  __uintcap_t x;
  x = a.thinFlag;
  x = a.reservedFlag;
  x = a.flags;
}

