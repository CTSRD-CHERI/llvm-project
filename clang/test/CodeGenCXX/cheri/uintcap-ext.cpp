// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 %s -emit-llvm -o - | FileCheck %s
// RUNs: %cheri_purecap_cc1 %s -emit-llvm -o - -O2

extern unsigned u32;
extern int s32;

// Previously Clang would generate a sext instruction for the conversion from
// u32 -> __uintcap_t. Check that we correctly generate a zext.

// These should both zero-extend

// CHECK-LABEL: @_Z8zext_capv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* @u32, align 4
// CHECK-NEXT:    [[CONV:%.*]] = zext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[CONV]]
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
__uintcap_t zext_cap() {
  return static_cast<__uintcap_t>(u32);
}
// CHECK-LABEL: @_Z7zext_64v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* @u32, align 4
// CHECK-NEXT:    [[CONV:%.*]] = zext i32 [[TMP0]] to i64
// CHECK-NEXT:    ret i64 [[CONV]]
//
unsigned long long zext_64() {
  return static_cast<unsigned long long>(u32);
}

// And these should sign-extend

// CHECK-LABEL: @_Z8sext_capv(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* @s32, align 4
// CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[CONV]]
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
__intcap_t sext_cap() {
  return static_cast<__intcap_t>(s32);
}
// CHECK-LABEL: @_Z7sext_64v(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* @s32, align 4
// CHECK-NEXT:    [[CONV:%.*]] = sext i32 [[TMP0]] to i64
// CHECK-NEXT:    ret i64 [[CONV]]
//
long long sext_64() {
  return static_cast<long long>(s32);
}
