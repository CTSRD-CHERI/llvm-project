// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// REQUIRES: mips-registered-target
// RUN: %cheri_purecap_cc1 -DERROR_CHECK  -emit-llvm -o - %s -O2 | %cheri_FileCheck %s -check-prefix PURECAP_IR
// RUN: %cheri_cc1 -emit-llvm -o - %s -O2 | %cheri_FileCheck %s -check-prefix N64_IR

// RUN: %cheri_cc1 -S -o - %s  -O2 | %cheri_FileCheck %s -check-prefixes ASM,N64_ASM
// RUN: %cheri_purecap_cc1 -S -o - %s -O2 | %cheri_FileCheck %s -check-prefixes ASM,PURECAP_ASM

// This previously crashed:
// RUN: %cheri_purecap_cc1 -DERROR_CHECK -S -o - %s -O2 -verify | %cheri_FileCheck %s -check-prefixes ASM,PURECAP_ASM,WITH_ERROR_ASM

template <class Tp>
inline
void DoNotOptimize(Tp const& value) {
  asm volatile("" : : "r,m"(value) : "memory");
}

template <class Tp>
inline void DoNotOptimize(Tp& value) {
#if defined(__clang__)
  asm volatile("" : "+r,m"(value) : : "memory");
#else
  asm volatile("" : "+m,r"(value) : : "memory");
#endif
}

extern bool cancel;
extern void* foo;

// PURECAP_IR-LABEL: @test(
// PURECAP_IR-NEXT:  entry:
// PURECAP_IR-NEXT:    [[TMP0:%.*]] = load i8, i8 addrspace(200)* @cancel, align 1, !tbaa !2, !range !6
// PURECAP_IR-NEXT:    [[TOBOOL_I:%.*]] = icmp ne i8 [[TMP0]], 0
// PURECAP_IR-NEXT:    tail call void asm sideeffect "", "=*r|m,0,~{memory},~{$1}"(i8 addrspace(200)* nonnull @cancel, i1 [[TOBOOL_I]]) #1, !srcloc !7
// PURECAP_IR-NEXT:    [[TMP1:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* @foo, align [[#CAP_SIZE]], !tbaa !8
// PURECAP_IR-NEXT:    tail call void asm sideeffect "", "=*r|m,0,~{memory},~{$1}"(i8 addrspace(200)* addrspace(200)* nonnull @foo, i8 addrspace(200)* [[TMP1]]) #1, !srcloc !7
// PURECAP_IR-NEXT:    ret void
//
// N64_IR-LABEL: @test(
// N64_IR-NEXT:  entry:
// N64_IR-NEXT:    [[TMP0:%.*]] = load i8, i8* @cancel, align 1, !tbaa !2, !range !6
// N64_IR-NEXT:    [[TOBOOL_I:%.*]] = icmp ne i8 [[TMP0]], 0
// N64_IR-NEXT:    tail call void asm sideeffect "", "=*r|m,0,~{memory},~{$1}"(i8* nonnull @cancel, i1 [[TOBOOL_I]]) #1, !srcloc !7
// N64_IR-NEXT:    [[TMP1:%.*]] = load i8*, i8** @foo, align 8, !tbaa !8
// N64_IR-NEXT:    tail call void asm sideeffect "", "=*r|m,0,~{memory},~{$1}"(i8** nonnull @foo, i8* [[TMP1]]) #1, !srcloc !7
// N64_IR-NEXT:    ret void
//
extern "C" void test() {
  // ASM-LABEL: test:
  DoNotOptimize(cancel);
  // N64_ASM: ld $3, %got_disp(cancel)($2)
  // PURECAP_ASM: clcbi	$c{{.+}}, %captab20(cancel)($c{{.+}})
  DoNotOptimize(foo);
  // N64_ASM: ld $2, %got_disp(foo)($2)
  // PURECAP_ASM: clcbi	$c{{.+}}, %captab20(foo)($c{{.+}})
  // ASM: .end test
}


#ifdef ERROR_CHECK
template <class Tp>
inline
void DoNotOptimize2(Tp const& value) {
  asm volatile("" : : "C,m"(value) : "memory");
}

template <class Tp>
inline void DoNotOptimize2(Tp& value) {
  asm volatile("" : "+C,m"(value) : : "memory");  // expected-error{{couldn't allocate output register for constraint 'C'}}
}
// PURECAP_IR-LABEL: @test2(
// PURECAP_IR-NEXT:  entry:
// PURECAP_IR-NEXT:    [[TMP0:%.*]] = load i8, i8 addrspace(200)* @cancel, align 1, !tbaa !2, !range !6
// PURECAP_IR-NEXT:    [[TOBOOL_I:%.*]] = icmp ne i8 [[TMP0]], 0
// PURECAP_IR-NEXT:    tail call void asm sideeffect "", "=*C|m,0,~{memory},~{$1}"(i8 addrspace(200)* nonnull @cancel, i1 [[TOBOOL_I]]) #1, !srcloc !10
// PURECAP_IR-NEXT:    [[TMP1:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* @foo, align [[#CAP_SIZE]], !tbaa !8
// PURECAP_IR-NEXT:    tail call void asm sideeffect "", "=*C|m,0,~{memory},~{$1}"(i8 addrspace(200)* addrspace(200)* nonnull @foo, i8 addrspace(200)* [[TMP1]]) #1, !srcloc !10
// PURECAP_IR-NEXT:    ret void
//
extern "C" void test2() {
  // The load of cancel is not emitted as ASM since it caused an error:
  // WITH_ERROR_ASM-LABEL: test2:
  // WITH_ERROR_ASM-NOT:   %captab20(cancel)
  // WITH_ERROR_ASM:       clcbi $c{{.+}}, %captab20(foo)($c{{.+}})
  // WITH_ERROR_ASM-NOT:   %captab20(cancel)
  // WITH_ERROR_ASM:       .end test2
  DoNotOptimize2(cancel);
  DoNotOptimize2(foo);
}
#endif
