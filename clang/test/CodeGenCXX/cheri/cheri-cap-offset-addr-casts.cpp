// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// Test IR generation for __cheri_{offset, addr} when used with C++ features
// RUN: %cheri_cc1 -std=c++11 -fsyntax-only %s -verify=expected,hybrid
// RUN: %cheri_purecap_cc1 -std=c++11 -fsyntax-only %s -verify
// RUN: %cheri_purecap_cc1 -std=c++11 -x c++ -DCODEGEN -O1 -emit-llvm -o - %s | FileCheck %s

class A {};
// CHECK-LABEL: define {{[^@]+}}@_Z1fv
// CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void f() { };

#ifndef CODEGEN
// Test object references
void objrefs_bad(A& a) {
  long x1 = (__cheri_offset long)a; // expected-error-re{{invalid source type 'A &{{( __capability)?}}' for __cheri_offset: source must be a capability}}
  long x2 = (__cheri_addr long)a;   // expected-error-re{{invalid source type 'A &{{( __capability)?}}' for __cheri_addr: source must be a capability}}
}

// Test function references
void funcref_bad(void (&f)(void)) {
  long x1 = (__cheri_offset long)f; // hybrid-error{{invalid source type 'void (*)()' for __cheri_offset: source must be a capability}}
  long x2 = (__cheri_addr long)f;
}
#endif

// Test object references
// CHECK-LABEL: define {{[^@]+}}@_Z14objrefs_addrofR1A
// CHECK-SAME: ([[CLASS_A:%.*]] addrspace(200)* noundef nonnull align 1 dereferenceable(1) [[A:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR1:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds [[CLASS_A]], [[CLASS_A]] addrspace(200)* [[A]], i64 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP2]], [[TMP1]]
// CHECK-NEXT:    ret i64 [[ADD]]
//
long objrefs_addrof(A& a) {
  long x1 = (__cheri_offset long)&a; // hybrid-error{{invalid source type 'A *' for __cheri_offset: source must be a capability}}
  long x2 = (__cheri_addr long)&a;
  return x1 + x2;
}

// Test function references
// CHECK-LABEL: define {{[^@]+}}@_Z14funcref_addrofRFvvE
// CHECK-SAME: (void () addrspace(200)* noundef nonnull [[F:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR1]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast void () addrspace(200)* [[F]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP2]], [[TMP1]]
// CHECK-NEXT:    ret i64 [[ADD]]
//
long funcref_addrof(void (&f)(void)) {
  long x1 = (__cheri_offset long)&f; // hybrid-error{{invalid source type 'void (*)()' for __cheri_offset: source must be a capability}}
  long x2 = (__cheri_addr long)&f;
  return x1 + x2;
}
