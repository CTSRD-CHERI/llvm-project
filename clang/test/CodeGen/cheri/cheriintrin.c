// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 %s -o - -emit-llvm -O1 -Weverything -Werror -verify -Wno-declaration-after-statement | FileCheck %s
// RUN: %cheri_purecap_cc1 %s -o - -emit-llvm -O1 -Weverything -Werror -Wno-declaration-after-statement -verify | FileCheck %s
// RUN: %riscv64y_hybrid_cc1 %s -o - -emit-llvm -O1 -Weverything -Werror -Wno-declaration-after-statement -verify | FileCheck %s --check-prefix=RVY
// RUN: %riscv64y_purecap_cc1 %s -o - -emit-llvm -O1 -Weverything -Werror -Wno-declaration-after-statement -verify | FileCheck %s --check-prefix=RVY
// expected-no-diagnostics

#include <cheriintrin.h>
// Check that all macros defined in cheriintrin.h work as expected

void use_size_t(__SIZE_TYPE__ s);
void use_bool(_Bool b);
void use_cap(void *__capability p);

void test(void *__capability cap, char *__capability cap2, __SIZE_TYPE__ i);

// CHECK-LABEL: @test(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[CAP:%.*]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP0]]) #[[ATTR5:[0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[CAP]], i64 [[I:%.*]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP1]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call i64 @llvm.cheri.cap.base.get.i64(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP2]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP3:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP3]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP4:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP4]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP5:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP5]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP6:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.tag.clear(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP6]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP7:%.*]] = tail call i1 @llvm.cheri.cap.tag.get(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP7]]) #[[ATTR5]]
// CHECK-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP7]]) #[[ATTR5]]
// CHECK-NEXT:    [[LNOT:%.*]] = xor i1 [[TMP7]], true
// CHECK-NEXT:    tail call void @use_bool(i1 noundef zeroext [[LNOT]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP8:%.*]] = tail call i1 @llvm.cheri.cap.equal.exact(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2:%.*]])
// CHECK-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP8]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP9:%.*]] = tail call i1 @llvm.cheri.cap.subset.test(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// CHECK-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP9]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP10:%.*]] = tail call i64 @llvm.cheri.round.representable.length.i64(i64 [[I]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP10]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP11:%.*]] = tail call i64 @llvm.cheri.representable.alignment.mask.i64(i64 [[I]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP11]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP12:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP12]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP13:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP13]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP14:%.*]] = tail call i64 @llvm.cheri.cap.type.get.i64(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP14]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP15:%.*]] = tail call i1 @llvm.cheri.cap.sealed.get(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP15]]) #[[ATTR5]]
// CHECK-NEXT:    [[LNOT1:%.*]] = xor i1 [[TMP15]], true
// CHECK-NEXT:    tail call void @use_bool(i1 noundef zeroext [[LNOT1]]) #[[ATTR5]]
// CHECK-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TMP14]], -2
// CHECK-NEXT:    tail call void @use_bool(i1 noundef zeroext [[CMP]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP16:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.seal.entry(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP16]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP17:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.seal(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP17]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP18:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.unseal(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP18]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP19:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.build(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP19]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP20:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.conditional.seal(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP20]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP21:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.type.copy(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP21]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP22:%.*]] = tail call i64 @llvm.cheri.cap.perms.get.i64(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    [[CONV2:%.*]] = and i64 [[TMP22]], 4294967295
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[CONV2]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP23:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) [[CAP]], i64 4)
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP23]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP24:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) [[CAP]], i64 -3)
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP24]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP25:%.*]] = tail call ptr addrspace(200) @llvm.cheri.ddc.get()
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP25]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP26:%.*]] = tail call ptr addrspace(200) @llvm.cheri.pcc.get()
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP26]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP27:%.*]] = tail call i64 @llvm.cheri.cap.flags.get.i64(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP27]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP28:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.flags.set.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP28]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP29:%.*]] = tail call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP29]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP30:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP30]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP31:%.*]] = tail call i64 @llvm.cheri.cap.load.tags.i64(ptr addrspace(200) [[CAP]])
// CHECK-NEXT:    tail call void @use_size_t(i64 noundef zeroext [[TMP31]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
// RVY-LABEL: @test(
// RVY-NEXT:  entry:
// RVY-NEXT:    [[TMP0:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[CAP:%.*]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP0]]) #[[ATTR5:[0-9]+]]
// RVY-NEXT:    [[TMP1:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[CAP]], i64 [[I:%.*]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP1]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP2:%.*]] = tail call i64 @llvm.cheri.cap.base.get.i64(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP2]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP3:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP3]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP4:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP4]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP5:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP5]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP6:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.tag.clear(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP6]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP7:%.*]] = tail call i1 @llvm.cheri.cap.tag.get(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP7]]) #[[ATTR5]]
// RVY-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP7]]) #[[ATTR5]]
// RVY-NEXT:    [[LNOT:%.*]] = xor i1 [[TMP7]], true
// RVY-NEXT:    tail call void @use_bool(i1 noundef zeroext [[LNOT]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP8:%.*]] = tail call i1 @llvm.cheri.cap.equal.exact(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2:%.*]])
// RVY-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP8]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP9:%.*]] = tail call i1 @llvm.cheri.cap.subset.test(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// RVY-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP9]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP10:%.*]] = tail call i64 @llvm.cheri.round.representable.length.i64(i64 [[I]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP10]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP11:%.*]] = tail call i64 @llvm.cheri.representable.alignment.mask.i64(i64 [[I]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP11]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP12:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP12]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP13:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.exact.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP13]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP14:%.*]] = tail call i64 @llvm.cheri.cap.type.get.i64(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP14]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP15:%.*]] = tail call i1 @llvm.cheri.cap.sealed.get(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_bool(i1 noundef zeroext [[TMP15]]) #[[ATTR5]]
// RVY-NEXT:    [[LNOT1:%.*]] = xor i1 [[TMP15]], true
// RVY-NEXT:    tail call void @use_bool(i1 noundef zeroext [[LNOT1]]) #[[ATTR5]]
// RVY-NEXT:    [[CMP:%.*]] = icmp eq i64 [[TMP14]], -2
// RVY-NEXT:    tail call void @use_bool(i1 noundef zeroext [[CMP]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP16:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.seal.entry(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP16]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP17:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.seal(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP17]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP18:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.unseal(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP18]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP19:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.build(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP19]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP20:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.conditional.seal(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP20]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP21:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.type.copy(ptr addrspace(200) [[CAP]], ptr addrspace(200) [[CAP2]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP21]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP22:%.*]] = tail call i64 @llvm.cheri.cap.perms.get.i64(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    [[CONV2:%.*]] = and i64 [[TMP22]], 4294967295
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[CONV2]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP23:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) [[CAP]], i64 262144)
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP23]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP24:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200) [[CAP]], i64 -131073)
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP24]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP25:%.*]] = tail call ptr addrspace(200) @llvm.cheri.ddc.get()
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP25]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP26:%.*]] = tail call ptr addrspace(200) @llvm.cheri.pcc.get()
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP26]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP27:%.*]] = tail call i64 @llvm.cheri.cap.flags.get.i64(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP27]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP28:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.flags.set.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP28]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP29:%.*]] = tail call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP29]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP30:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[CAP]], i64 [[I]])
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[TMP30]]) #[[ATTR5]]
// RVY-NEXT:    [[TMP31:%.*]] = tail call i64 @llvm.cheri.cap.load.tags.i64(ptr addrspace(200) [[CAP]])
// RVY-NEXT:    tail call void @use_size_t(i64 noundef [[TMP31]]) #[[ATTR5]]
// RVY-NEXT:    ret void
//
void test(void *__capability cap, char *__capability cap2, __SIZE_TYPE__ i) {
  use_size_t(cheri_address_get(cap));
  use_cap(cheri_address_set(cap, i));

  use_size_t(cheri_base_get(cap));

  use_size_t(cheri_length_get(cap));

  use_size_t(cheri_offset_get(cap));
  use_cap(cheri_offset_set(cap, i));

  use_cap(cheri_tag_clear(cap));
  use_bool(cheri_tag_get(cap));
  use_bool(cheri_is_valid(cap));
  use_bool(cheri_is_invalid(cap));

  use_bool(cheri_is_equal_exact(cap, cap2));
  use_bool(cheri_is_subset(cap, cap2));

  use_size_t(cheri_representable_length(i));
  use_size_t(cheri_representable_alignment_mask(i));

  use_cap(cheri_bounds_set(cap, i));
  use_cap(cheri_bounds_set_exact(cap, i));

  /* Check that the cheri_otype_t type is defined */
  _Static_assert(__builtin_types_compatible_p(cheri_otype_t *, __typeof__(cheri_type_get(cap)) *), "");
  _Static_assert(__builtin_types_compatible_p(cheri_otype_t *, long *), "");
  _Static_assert(CHERI_OTYPE_UNSEALED == -1, "RISCV and MIPS expect -2");
  _Static_assert(CHERI_OTYPE_SENTRY == -2, "RISCV and MIPS expect -2");
  use_size_t((unsigned long)cheri_type_get(cap));
  use_bool(cheri_is_sealed(cap));
  use_bool(cheri_is_unsealed(cap));
  use_bool(cheri_is_sentry(cap));
  use_cap(cheri_sentry_create(cap));
  use_cap(cheri_seal(cap, cap2));
  use_cap(cheri_unseal(cap, cap2));

  use_cap(cheri_cap_build(cap, (__intcap_t)cap2));
  use_cap(cheri_seal_conditionally(cap, cap2));
  use_cap(cheri_type_copy(cap, cap2));

#if !defined(__riscv_y)
  _Static_assert(CHERI_PERM_GLOBAL != 0, "must be defined");
  _Static_assert(CHERI_PERM_EXECUTE != 0, "must be defined");
  _Static_assert(CHERI_PERM_LOAD != 0, "must be defined");
  _Static_assert(CHERI_PERM_STORE != 0, "must be defined");
  _Static_assert(CHERI_PERM_LOAD_CAP != 0, "must be defined");
  _Static_assert(CHERI_PERM_STORE_CAP != 0, "must be defined");
  _Static_assert(CHERI_PERM_STORE_LOCAL_CAP != 0, "must be defined");
  _Static_assert(CHERI_PERM_SEAL != 0, "must be defined");
  _Static_assert(CHERI_PERM_INVOKE != 0, "must be defined");
  _Static_assert(CHERI_PERM_UNSEAL != 0, "must be defined");
  _Static_assert(CHERI_PERM_SYSTEM_REGS != 0, "must be defined");
#else
  _Static_assert(CHERI_PERM_CAP != 0, "must be defined");
  _Static_assert(CHERI_PERM_WRITE != 0, "must be defined");
  _Static_assert(CHERI_PERM_READ != 0, "must be defined");
  _Static_assert(CHERI_PERM_EXECUTE != 0, "must be defined");
  _Static_assert(CHERI_PERM_SYSTEM_REGS != 0, "must be defined");
  _Static_assert(CHERI_PERM_LOAD_MUTABLE != 0, "must be defined");
  _Static_assert(CHERI_PERM_LOAD_GLOBAL != 0, "must be defined");
  _Static_assert(CHERI_PERM_STORE_LOCAL != 0, "must be defined");
  _Static_assert(CHERI_PERM_CAPABILITY_GLOBAL != 0, "must be defined");
#endif
  /* Check that CHERI_PERMS_T is defined */
  cheri_perms_t cap_perms = cheri_perms_get(cap);
  use_size_t(cap_perms);
#if !defined(__riscv_y)
  use_cap(cheri_perms_and(cap, CHERI_PERM_LOAD));
#else
  use_cap(cheri_perms_and(cap, CHERI_PERM_READ));
#endif
  use_cap(cheri_perms_clear(cap, CHERI_PERM_EXECUTE));

  use_cap(cheri_ddc_get());
  use_cap(cheri_pcc_get());

  use_size_t(cheri_flags_get(cap));
  use_cap(cheri_flags_set(cap, i));

  use_size_t(cheri_high_get(cap));
  use_cap(cheri_high_set(cap, i));

  use_size_t(cheri_tags_load(cap));
}

/* We also define macros for __builtin_is_aligned/__builtin_align_{up,down}().
 * They are not CHERI specific, but using __builtin_* is ugly.
 *
 * TOOD: we may want to provide nicer names in stdalign.h.
 */
void test_alignment_builtins(void *__capability cap, __SIZE_TYPE__ align);

// CHECK-LABEL: @test_alignment_builtins(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[MASK:%.*]] = add i64 [[ALIGN:%.*]], -1
// CHECK-NEXT:    [[PTRADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[CAP:%.*]])
// CHECK-NEXT:    [[OVER_BOUNDARY:%.*]] = add i64 [[PTRADDR]], [[MASK]]
// CHECK-NEXT:    [[INVERTED_MASK:%.*]] = sub i64 0, [[ALIGN]]
// CHECK-NEXT:    [[ALIGNED_INTPTR:%.*]] = and i64 [[OVER_BOUNDARY]], [[INVERTED_MASK]]
// CHECK-NEXT:    [[DIFF:%.*]] = sub i64 [[ALIGNED_INTPTR]], [[PTRADDR]]
// CHECK-NEXT:    [[ALIGNED_RESULT:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[CAP]], i64 [[DIFF]]
// CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr addrspace(200) [[ALIGNED_RESULT]], i64 [[ALIGN]]) ]
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[ALIGNED_RESULT]]) #[[ATTR5]]
// CHECK-NEXT:    [[ALIGNED_INTPTR5:%.*]] = and i64 [[PTRADDR]], [[INVERTED_MASK]]
// CHECK-NEXT:    [[DIFF6:%.*]] = sub i64 [[ALIGNED_INTPTR5]], [[PTRADDR]]
// CHECK-NEXT:    [[ALIGNED_RESULT7:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[CAP]], i64 [[DIFF6]]
// CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr addrspace(200) [[ALIGNED_RESULT7]], i64 [[ALIGN]]) ]
// CHECK-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[ALIGNED_RESULT7]]) #[[ATTR5]]
// CHECK-NEXT:    [[SET_BITS:%.*]] = and i64 [[PTRADDR]], [[MASK]]
// CHECK-NEXT:    [[IS_ALIGNED:%.*]] = icmp eq i64 [[SET_BITS]], 0
// CHECK-NEXT:    tail call void @use_bool(i1 noundef zeroext [[IS_ALIGNED]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
// RVY-LABEL: @test_alignment_builtins(
// RVY-NEXT:  entry:
// RVY-NEXT:    [[MASK:%.*]] = add i64 [[ALIGN:%.*]], -1
// RVY-NEXT:    [[PTRADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[CAP:%.*]])
// RVY-NEXT:    [[OVER_BOUNDARY:%.*]] = add i64 [[PTRADDR]], [[MASK]]
// RVY-NEXT:    [[INVERTED_MASK:%.*]] = sub i64 0, [[ALIGN]]
// RVY-NEXT:    [[ALIGNED_INTPTR:%.*]] = and i64 [[OVER_BOUNDARY]], [[INVERTED_MASK]]
// RVY-NEXT:    [[DIFF:%.*]] = sub i64 [[ALIGNED_INTPTR]], [[PTRADDR]]
// RVY-NEXT:    [[ALIGNED_RESULT:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[CAP]], i64 [[DIFF]]
// RVY-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr addrspace(200) [[ALIGNED_RESULT]], i64 [[ALIGN]]) ]
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[ALIGNED_RESULT]]) #[[ATTR5]]
// RVY-NEXT:    [[ALIGNED_INTPTR5:%.*]] = and i64 [[PTRADDR]], [[INVERTED_MASK]]
// RVY-NEXT:    [[DIFF6:%.*]] = sub i64 [[ALIGNED_INTPTR5]], [[PTRADDR]]
// RVY-NEXT:    [[ALIGNED_RESULT7:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[CAP]], i64 [[DIFF6]]
// RVY-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr addrspace(200) [[ALIGNED_RESULT7]], i64 [[ALIGN]]) ]
// RVY-NEXT:    tail call void @use_cap(ptr addrspace(200) noundef [[ALIGNED_RESULT7]]) #[[ATTR5]]
// RVY-NEXT:    [[SET_BITS:%.*]] = and i64 [[PTRADDR]], [[MASK]]
// RVY-NEXT:    [[IS_ALIGNED:%.*]] = icmp eq i64 [[SET_BITS]], 0
// RVY-NEXT:    tail call void @use_bool(i1 noundef zeroext [[IS_ALIGNED]]) #[[ATTR5]]
// RVY-NEXT:    ret void
//
void test_alignment_builtins(void *__capability cap, __SIZE_TYPE__ align) {
  use_cap(cheri_align_up(cap, align));
  use_cap(cheri_align_down(cap, align));
  use_bool(cheri_is_aligned(cap, align));
}
