// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// REQUIRES: mips-registered-target
/// Check calling conventions for passing unions
// RUN: %cheri_purecap_cc1 %s -no-opaque-pointers -O0 -emit-llvm -o - | %cheri_FileCheck %s
// RUN: %cheri_purecap_cc1 %s -O2 -S -o - | %cheri_FileCheck %s -check-prefixes ASM

// example union from WebKit
union CallData {
  struct {
    char* c;
    int i;
  } Bar;
};

// example union that is passed into semctl()
union semun {
  int val;
  char *buf1;
  char *buf2;
  char *buf3;
};


// example of nested structs
union DeepDive {
  struct {
    struct {
      char* str;
    } B;
  } A;
};

union DeepNoDive {
  struct {
    struct {
      char* str;
      int d;
    } B;
  } A;
};

// CHECK-LABEL: @test_onelevel_helper(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FOO:%.*]] = alloca [[UNION_CALLDATA:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i8 addrspace(200)* [[FOO_COERCE:%.*]] to [[UNION_CALLDATA]] addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = load [[UNION_CALLDATA]], [[UNION_CALLDATA]] addrspace(200)* [[TMP0]], align 16
// CHECK-NEXT:    store [[UNION_CALLDATA]] [[TMP1]], [[UNION_CALLDATA]] addrspace(200)* [[FOO]], align 16
// CHECK-NEXT:    ret void
//
void test_onelevel_helper(union CallData foo) {
}

// CHECK-LABEL: @test_onelevel(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FOO:%.*]] = alloca [[UNION_CALLDATA:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[BAR:%.*]] = bitcast [[UNION_CALLDATA]] addrspace(200)* [[FOO]] to [[STRUCT_ANON:%.*]] addrspace(200)*
// CHECK-NEXT:    [[C:%.*]] = getelementptr inbounds [[STRUCT_ANON]], [[STRUCT_ANON]] addrspace(200)* [[BAR]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr inbounds ([6 x i8], [6 x i8] addrspace(200)* @.str, i64 0, i64 0), i8 addrspace(200)* addrspace(200)* [[C]], align 16
// CHECK-NEXT:    [[BAR1:%.*]] = bitcast [[UNION_CALLDATA]] addrspace(200)* [[FOO]] to [[STRUCT_ANON]] addrspace(200)*
// CHECK-NEXT:    [[I:%.*]] = getelementptr inbounds [[STRUCT_ANON]], [[STRUCT_ANON]] addrspace(200)* [[BAR1]], i32 0, i32 1
// CHECK-NEXT:    store i32 9, i32 addrspace(200)* [[I]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[UNION_CALLDATA]] addrspace(200)* [[FOO]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @test_onelevel_helper(i8 addrspace(200)* inreg [[TMP0]])
// CHECK-NEXT:    ret void
//
void test_onelevel() {
  union CallData foo;
  foo.Bar.c = "hello";
  foo.Bar.i = 9;
  test_onelevel_helper(foo);
}

// CHECK-LABEL: @test_zerolevels_helper(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], [[UNION_SEMUN]] addrspace(200)* [[S]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* [[S_COERCE:%.*]], i8 addrspace(200)* addrspace(200)* [[COERCE_DIVE]], align 16
// CHECK-NEXT:    ret void
//
void test_zerolevels_helper(union semun s) {
}

// CHECK-LABEL: @test_zerolevels(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[BUF1:%.*]] = bitcast [[UNION_SEMUN]] addrspace(200)* [[S]] to i8 addrspace(200)* addrspace(200)*
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr inbounds ([6 x i8], [6 x i8] addrspace(200)* @.str, i64 0, i64 0), i8 addrspace(200)* addrspace(200)* [[BUF1]], align 16
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], [[UNION_SEMUN]] addrspace(200)* [[S]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[COERCE_DIVE]], align 16
// CHECK-NEXT:    call void @test_zerolevels_helper(i8 addrspace(200)* inreg [[TMP0]])
// CHECK-NEXT:    ret void
//
void test_zerolevels() {
  union semun s;
  s.buf1 = "hello";
  test_zerolevels_helper(s);
}

// CHECK-LABEL: @test_twolevels_dive_helper(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca [[UNION_DEEPDIVE:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_DEEPDIVE]], [[UNION_DEEPDIVE]] addrspace(200)* [[D]], i32 0, i32 0
// CHECK-NEXT:    [[COERCE_DIVE1:%.*]] = getelementptr inbounds [[STRUCT_ANON_0:%.*]], [[STRUCT_ANON_0]] addrspace(200)* [[COERCE_DIVE]], i32 0, i32 0
// CHECK-NEXT:    [[COERCE_DIVE2:%.*]] = getelementptr inbounds [[STRUCT_ANON_1:%.*]], [[STRUCT_ANON_1]] addrspace(200)* [[COERCE_DIVE1]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* [[D_COERCE:%.*]], i8 addrspace(200)* addrspace(200)* [[COERCE_DIVE2]], align 16
// CHECK-NEXT:    ret void
//
void test_twolevels_dive_helper(union DeepDive d) {

}

// CHECK-LABEL: @test_twolevels_dive(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca [[UNION_DEEPDIVE:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[A:%.*]] = bitcast [[UNION_DEEPDIVE]] addrspace(200)* [[D]] to [[STRUCT_ANON_0:%.*]] addrspace(200)*
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_ANON_0]], [[STRUCT_ANON_0]] addrspace(200)* [[A]], i32 0, i32 0
// CHECK-NEXT:    [[STR:%.*]] = getelementptr inbounds [[STRUCT_ANON_1:%.*]], [[STRUCT_ANON_1]] addrspace(200)* [[B]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr inbounds ([6 x i8], [6 x i8] addrspace(200)* @.str, i64 0, i64 0), i8 addrspace(200)* addrspace(200)* [[STR]], align 16
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_DEEPDIVE]], [[UNION_DEEPDIVE]] addrspace(200)* [[D]], i32 0, i32 0
// CHECK-NEXT:    [[COERCE_DIVE1:%.*]] = getelementptr inbounds [[STRUCT_ANON_0]], [[STRUCT_ANON_0]] addrspace(200)* [[COERCE_DIVE]], i32 0, i32 0
// CHECK-NEXT:    [[COERCE_DIVE2:%.*]] = getelementptr inbounds [[STRUCT_ANON_1]], [[STRUCT_ANON_1]] addrspace(200)* [[COERCE_DIVE1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[COERCE_DIVE2]], align 16
// CHECK-NEXT:    call void @test_twolevels_dive_helper(i8 addrspace(200)* inreg [[TMP0]])
// CHECK-NEXT:    ret void
//
void test_twolevels_dive() {
  union DeepDive d;
  d.A.B.str = "hello";
  test_twolevels_dive_helper(d);
}

// CHECK-LABEL: @test_twolevels_nodive_helper(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca [[UNION_DEEPNODIVE:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i8 addrspace(200)* [[D_COERCE:%.*]] to [[UNION_DEEPNODIVE]] addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = load [[UNION_DEEPNODIVE]], [[UNION_DEEPNODIVE]] addrspace(200)* [[TMP0]], align 16
// CHECK-NEXT:    store [[UNION_DEEPNODIVE]] [[TMP1]], [[UNION_DEEPNODIVE]] addrspace(200)* [[D]], align 16
// CHECK-NEXT:    ret void
//
void test_twolevels_nodive_helper(union DeepNoDive d) {
}

// CHECK-LABEL: @test_twolevels_nodive(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca [[UNION_DEEPNODIVE:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[A:%.*]] = bitcast [[UNION_DEEPNODIVE]] addrspace(200)* [[D]] to [[STRUCT_ANON_2:%.*]] addrspace(200)*
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_ANON_2]], [[STRUCT_ANON_2]] addrspace(200)* [[A]], i32 0, i32 0
// CHECK-NEXT:    [[STR:%.*]] = getelementptr inbounds [[STRUCT_ANON_3:%.*]], [[STRUCT_ANON_3]] addrspace(200)* [[B]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr inbounds ([6 x i8], [6 x i8] addrspace(200)* @.str, i64 0, i64 0), i8 addrspace(200)* addrspace(200)* [[STR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[UNION_DEEPNODIVE]] addrspace(200)* [[D]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @test_twolevels_nodive_helper(i8 addrspace(200)* inreg [[TMP0]])
// CHECK-NEXT:    ret void
//
void test_twolevels_nodive() {
  union DeepNoDive d;
  d.A.B.str = "hello";
  test_twolevels_nodive_helper(d);
}

// Test that reading the values from semun works as expected
// Assembly tests shouldn't really be in clang but in this case we really want to verify that the calling convention matches

// For reading/writing the integer value we store the int and read back as capability/ write the cap and read back as an int
// TODO: could just use CIncOffset/CGetAddr here?

// CHECK-LABEL: @test_semun_read_int(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], [[UNION_SEMUN]] addrspace(200)* [[S]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* [[S_COERCE:%.*]], i8 addrspace(200)* addrspace(200)* [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[VAL:%.*]] = bitcast [[UNION_SEMUN]] addrspace(200)* [[S]] to i32 addrspace(200)*
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32 addrspace(200)* [[VAL]], align 16
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 1
// CHECK-NEXT:    ret i32 [[ADD]]
//
int test_semun_read_int(union semun s) {
  return s.val + 1;
  // ASM-LABEL: test_semun_read_int:
  // ASM:      cincoffset	$c11, $c11, -[[#CAP_SIZE]]
  // ASM-NEXT: csc	$c3, $zero, 0($c11)
  // ASM-NEXT: clw	$1, $zero, 0($c11)
  // ASM-NEXT: addiu	$2, $1, 1
  // ASM-NEXT: cjr	$c17
  // ASM: .end test_semun_read_int
}

extern int semun_pass_int_helper(union semun s);
// CHECK-LABEL: @test_semun_pass_int(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], [[UNION_SEMUN]] addrspace(200)* [[S]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* [[S_COERCE:%.*]], i8 addrspace(200)* addrspace(200)* [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[VAL:%.*]] = bitcast [[UNION_SEMUN]] addrspace(200)* [[S]] to i32 addrspace(200)*
// CHECK-NEXT:    store i32 1234, i32 addrspace(200)* [[VAL]], align 16
// CHECK-NEXT:    [[COERCE_DIVE1:%.*]] = getelementptr inbounds [[UNION_SEMUN]], [[UNION_SEMUN]] addrspace(200)* [[S]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[COERCE_DIVE1]], align 16
// CHECK-NEXT:    [[CALL:%.*]] = call signext i32 @semun_pass_int_helper(i8 addrspace(200)* inreg [[TMP0]])
// CHECK-NEXT:    ret i32 [[CALL]]
//
int test_semun_pass_int(union semun s) {
  s.val = 1234;
  // ASM-LABEL: test_semun_pass_int:
  // ASM:      csc	$c3, $zero, 0($c11)
  // ASM-NEXT: addiu	$1, $zero, 1234
  // ASM-NEXT: csw	$1, $zero, 0($c11)
  // ASM:      clc	$c3, $zero, 0($c11)
  // ASM-LABEL: .end test_semun_pass_int
  return semun_pass_int_helper(s);
}

// CHECK-LABEL: @test_semun_pass_int_2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTCOMPOUNDLITERAL:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[VAL:%.*]] = bitcast [[UNION_SEMUN]] addrspace(200)* [[DOTCOMPOUNDLITERAL]] to i32 addrspace(200)*
// CHECK-NEXT:    store i32 1234, i32 addrspace(200)* [[VAL]], align 16
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], [[UNION_SEMUN]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[CALL:%.*]] = call signext i32 @semun_pass_int_helper(i8 addrspace(200)* inreg [[TMP0]])
// CHECK-NEXT:    ret i32 [[CALL]]
//
int test_semun_pass_int_2() {
  // ASM-LABEL: test_semun_pass_int_2:
  // CHERI256 did a memset to zero before (this happens because clang thinks it
  // should do it for aggregates > 16)
  // TODO: do it for (> 16 || containsCaps)?
  // CHERI256:        csetbounds $c1, $c11, 32
  // CHERI256:        csc $cnull, $zero, 0($c1)
  // ASM:             addiu	$1, $zero, 1234
  // ASM-NEXT:        csw	$1, $zero, 0($c11)
  // ASM:             cjalr $c12, $c17
  // ASM-NEXT:        clc	$c3, $zero, 0($c11)
  // ASM-LABEL: .end test_semun_pass_int_2
  return semun_pass_int_helper((union semun){.val = 1234});
}

// CHECK-LABEL: @test_semun_read_cap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], [[UNION_SEMUN]] addrspace(200)* [[S]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* [[S_COERCE:%.*]], i8 addrspace(200)* addrspace(200)* [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[BUF1:%.*]] = bitcast [[UNION_SEMUN]] addrspace(200)* [[S]] to i8 addrspace(200)* addrspace(200)*
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[BUF1]], align 16
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[TMP0]], i64 1
// CHECK-NEXT:    ret i8 addrspace(200)* [[ADD_PTR]]
//
void* test_semun_read_cap(union semun s) {
  // ASM-LABEL: test_semun_read_cap:
  // ASM:      cjr $c17
  // ASM-NEXT: cincoffset	$c3, $c3, 1
  // ASM: .end test_semun_read_cap
  return s.buf1 + 1;
}
