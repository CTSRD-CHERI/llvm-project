// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -O2 -emit-llvm %s -o - -Rcheri-subobject-bounds -mllvm -debug-only="cheri-bounds" -verify | %cheri_FileCheck %s
// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -O0 -emit-llvm %s -o /dev/null -w -mllvm -stats 2>&1 | FileCheck %s -check-prefix DBG -implicit-check-not cheri-bounds
// DBG: ... Statistics Collected ...
// DBG:  9 cheri-bounds - Number of array-to-pointer-decays checked for tightening bounds
// DBG:  4 cheri-bounds - Number of array-to-pointer-decays where remaining allocation size was used
// DBG:  5 cheri-bounds - Number of array-to-pointer-decays where bounds were tightened
// REQUIRES: asserts

void overflow_buffer(void *);

typedef struct {
  long x;
  int buf[10];
  char c;
} struct_with_array;

// NOTE: bounds must be set before the GEP:
// CHECK-LABEL: define {{[^@]+}}@test_struct_member_decay
// CHECK-SAME: ([[STRUCT_STRUCT_WITH_ARRAY:%.*]] addrspace(200)* noundef [[S:%.*]], i64 noundef signext [[INDEX:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_WITH_ARRAY]], [[STRUCT_STRUCT_WITH_ARRAY]] addrspace(200)* [[S]], i64 0, i32 1, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[ARRAYDECAY]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 40)
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* noundef [[TMP1]]) #[[ATTR5:[0-9]+]]
// CHECK-NEXT:    ret void
//
void test_struct_member_decay(struct_with_array *s, long index) {
  // should set bounds to 10
  overflow_buffer(s->buf); // expected-remark{{setting sub-object bounds for field 'buf' (array decay on 'int [10]') to 40 bytes}}
}

// CHECK-LABEL: define {{[^@]+}}@test_local_array_decay
// CHECK-SAME: ([[STRUCT_STRUCT_WITH_ARRAY:%.*]] addrspace(200)* nocapture noundef readnone [[S:%.*]], i64 noundef signext [[INDEX:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUFFER:%.*]] = alloca [12 x i32], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [12 x i32] addrspace(200)* [[BUFFER]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.lifetime.start.p200i8(i64 48, i8 addrspace(200)* nonnull [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 48)
// CHECK-NEXT:    call void @overflow_buffer(i8 addrspace(200)* noundef [[TMP1]]) #[[ATTR5]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p200i8(i64 48, i8 addrspace(200)* nonnull [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_local_array_decay(struct_with_array *s, long index) {
  int buffer[12];
  // should set bounds to 10
  overflow_buffer(buffer); // expected-remark{{setting bounds for array decay on 'int [12]' to 48 bytes}}
}

// CHECK-LABEL: define {{[^@]+}}@return_stack_decay
// CHECK-SAME: ([[STRUCT_STRUCT_WITH_ARRAY:%.*]] addrspace(200)* nocapture noundef readnone [[S:%.*]], i64 noundef signext [[INDEX:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR4:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUFFER:%.*]] = alloca [21 x i32], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [21 x i32] addrspace(200)* [[BUFFER]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.lifetime.start.p200i8(i64 84, i8 addrspace(200)* nonnull [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 84)
// CHECK-NEXT:    call void @llvm.lifetime.end.p200i8(i64 84, i8 addrspace(200)* nonnull [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
void* return_stack_decay(struct_with_array *s, long index) {
  int buffer[21];
  return buffer; // expected-remark{{setting bounds for array decay on 'int [21]' to 84 bytes}}
  // expected-warning@-1{{address of stack memory associated with local variable 'buffer' returned}}
}

float global_buffer[100];
// CHECK-LABEL: define {{[^@]+}}@test_global_array_decay
// CHECK-SAME: (i64 noundef signext [[INDEX:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* bitcast ([100 x float] addrspace(200)* @global_buffer to i8 addrspace(200)*), i64 400)
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* noundef [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_global_array_decay(long index) {
  // should set bounds to 100 * 4
  overflow_buffer(global_buffer); // expected-remark{{setting bounds for array decay on 'float [100]' to 400 bytes}}
}

struct foo {
  int buffer[1];
  char buffer2;
} global_foo;

// CHECK-LABEL: define {{[^@]+}}@test_global_struct_array_decay
// CHECK-SAME: ([[STRUCT_STRUCT_WITH_ARRAY:%.*]] addrspace(200)* nocapture noundef readnone [[S:%.*]], i64 noundef signext [[INDEX:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* bitcast ([[STRUCT_FOO:%.*]] addrspace(200)* @global_foo to i8 addrspace(200)*), i64 4)
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* noundef [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_global_struct_array_decay(struct_with_array *s, long index) {
  overflow_buffer(global_foo.buffer); // expected-remark{{setting sub-object bounds for field 'buffer' (array decay on 'int [1]') to 4 bytes}}
}

// CHECK-LABEL: define {{[^@]+}}@test_local_vla_decay
// CHECK-SAME: ([[STRUCT_STRUCT_WITH_ARRAY:%.*]] addrspace(200)* nocapture noundef readnone [[S:%.*]], i64 noundef signext [[SIZE:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VLA:%.*]] = alloca i32, i64 [[SIZE]], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[VLA]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    call void @overflow_buffer(i8 addrspace(200)* noundef [[TMP1]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_local_vla_decay(struct_with_array *s, long size) {
  // TODO: should not set bounds here since the backend will bound the VLA
  int vla[size];
  overflow_buffer(vla); // expected-remark{{setting bounds for array decay on 'int [size]' to remaining bytes (array decay on variable size type)}}
}

struct vla_struct {
  char len;
  int vla[];
};

// CHECK-LABEL: define {{[^@]+}}@test_vla_struct_member_decay
// CHECK-SAME: ([[STRUCT_VLA_STRUCT:%.*]] addrspace(200)* noundef [[S:%.*]], i64 noundef signext [[INDEX:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_VLA_STRUCT]], [[STRUCT_VLA_STRUCT]] addrspace(200)* [[S]], i64 0, i32 1, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[ARRAYDECAY]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* noundef [[TMP1]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_vla_struct_member_decay(struct vla_struct *s, long index) {
  overflow_buffer(s->vla); // expected-remark{{setting sub-object bounds for field 'vla' (array decay on 'int []') to remaining bytes (member is potential variable length array)}}
}

struct fake_vla_struct {
  char len;
  int fake_vla[0];
};

// CHECK-LABEL: define {{[^@]+}}@test_fake_vla_struct_member_decay
// CHECK-SAME: ([[STRUCT_FAKE_VLA_STRUCT:%.*]] addrspace(200)* noundef [[S:%.*]], i64 noundef signext [[INDEX:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_FAKE_VLA_STRUCT]], [[STRUCT_FAKE_VLA_STRUCT]] addrspace(200)* [[S]], i64 0, i32 1, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[ARRAYDECAY]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* noundef [[TMP1]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_fake_vla_struct_member_decay(struct fake_vla_struct *s, long index) {
  overflow_buffer(s->fake_vla); // expected-remark{{setting sub-object bounds for field 'fake_vla' (array decay on 'int [0]') to remaining bytes (member is potential variable length array)}}
}

struct fake_vla_struct2 {
  char len;
  int fake_vla2[1]; // last member, size==1 -> possible fake VLA
};

// CHECK-LABEL: define {{[^@]+}}@test_fake_vla_struct2_member_decay
// CHECK-SAME: ([[STRUCT_FAKE_VLA_STRUCT2:%.*]] addrspace(200)* noundef [[S:%.*]], i64 noundef signext [[INDEX:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [[STRUCT_FAKE_VLA_STRUCT2]], [[STRUCT_FAKE_VLA_STRUCT2]] addrspace(200)* [[S]], i64 0, i32 1, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[ARRAYDECAY]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @overflow_buffer(i8 addrspace(200)* noundef [[TMP1]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_fake_vla_struct2_member_decay(struct fake_vla_struct2 *s, long index) {
  // TODO: should set reverse bounds here: raise bottom to current offset
  overflow_buffer(s->fake_vla2); // expected-remark{{setting sub-object bounds for field 'fake_vla2' (array decay on 'int [1]') to remaining bytes (member is potential variable length array)}}
}
