// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// REQUIRES: riscv-registered-target
// REQUIRES: mips-registered-target
// Check that we convert function pointers to PCC-relative capabilities and
// data pointers to ddc relative ones: (at least for globals)
// RUN: %cheri_cc1 -o - -emit-llvm %s | FileCheck %s
// RUN: %riscv64_cheri_cc1 -o - -emit-llvm %s | FileCheck %s

// Check the assembly output to see if we used PCC or DDC
// RUN: %cheri_cc1 -o - -S %s | FileCheck %s --check-prefixes=ASM,ASM-MIPS
// RUN: %riscv64_cheri_cc1 -o - -S %s | FileCheck %s --check-prefixes=ASM,ASM-RISCV

void external_fn(void);
int external_global;

// CHECK-LABEL: define {{[^@]+}}@global_fn_to_cap
// CHECK-SAME: () #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.pcc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) [[TMP0]], i64 ptrtoint (ptr @external_fn to i64))
// CHECK-NEXT:    ret ptr addrspace(200) [[TMP1]]
//
void *__capability global_fn_to_cap(void) {
  // ASM-LABEL: global_fn_to_cap:
  // ASM-MIPS:      cgetpcc $c1
  // ASM-MIPS-NEXT: ld $1, %got_disp(external_fn)($1)
  // ASM-MIPS-NEXT: cfromptr $c3, $c1, $1
  // ASM-RISCV: cspecialr ca0, pcc
  // ASM-RISCV: la a1, external_fn
  // ASM-RISCV-NEXT:  cfromptr ca0, ca0, a1
  return (__cheri_tocap void *__capability) & external_fn;
}

// CHECK-LABEL: define {{[^@]+}}@global_data_to_cap
// CHECK-SAME: () #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr addrspace(200) addrspacecast (ptr @external_global to ptr addrspace(200))
//
void *__capability global_data_to_cap(void) {
  // ASM-LABEL: global_data_to_cap:
  // ASM-MIPS: ld $1, %got_disp(external_global)($1)
  // ASM-MIPS-NEXT: cfromddc $c1, $1
  // MIPS automatically sets bounds in hybrid mode for global variables
  // ASM-MIPS-NEXT: csetbounds $c3, $c1, 4
  // ASM-RISCV: la a0, external_global
  // ASM-RISCV-NEXT:  cfromptr ca0, ddc, a0
  // We do not set bounds on RISCV
  // ASM-RISCV-NOT: csetbounds
  return (__cheri_tocap void *__capability) & external_global;
}

// CHECK-LABEL: define {{[^@]+}}@fn_ptr_to_cap
// CHECK-SAME: (ptr noundef [[FN_PTR:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FN_PTR_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[FN_PTR]], ptr [[FN_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[FN_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.pcc.get()
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[TMP0]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) [[TMP1]], i64 [[TMP2]])
// CHECK-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
void *__capability fn_ptr_to_cap(void (*fn_ptr)(void)) {
  // ASM-LABEL: fn_ptr_to_cap:
  // ASM-MIPS:      cgetpcc $c1
  // ASM-MIPS-NEXT: cfromptr $c3, $c1, $1
  // ASM-RISCV:      cspecialr ca0, pcc
  // ASM-RISCV-NEXT: cfromptr ca0, ca0, a1
  return (__cheri_tocap void *__capability)fn_ptr;
}

// CHECK-LABEL: define {{[^@]+}}@fn_ptr_to_cap_not_smart_enough
// CHECK-SAME: (ptr noundef [[FN_PTR:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FN_PTR_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[TMP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[FN_PTR]], ptr [[FN_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[FN_PTR_ADDR]], align 8
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[TMP]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = addrspacecast ptr [[TMP1]] to ptr addrspace(200)
// CHECK-NEXT:    ret ptr addrspace(200) [[TMP2]]
//
void *__capability fn_ptr_to_cap_not_smart_enough(void (*fn_ptr)(void)) {
  // ASM-LABEL: fn_ptr_to_cap_not_smart_enough:
  // ASM-MIPS:  cfromddc $c3, $1
  // ASM-RISCV: cfromptr ca0, ddc, a0
  // Note: In this case clang doesn't see that the result is actual a function
  // so it uses DDC:
  void *tmp = (void *)fn_ptr;
  return (__cheri_tocap void *__capability)tmp;
}

// CHECK-LABEL: define {{[^@]+}}@data_ptr_to_cap
// CHECK-SAME: (ptr noundef [[DATA_PTR:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA_PTR_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[DATA_PTR]], ptr [[DATA_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[DATA_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast ptr [[TMP0]] to ptr addrspace(200)
// CHECK-NEXT:    ret ptr addrspace(200) [[TMP1]]
//
void *__capability data_ptr_to_cap(int *data_ptr) {
  // Note: For data pointers we derive from DDC:
  // ASM-LABEL: data_ptr_to_cap:
  // ASM-MIPS:  cfromddc $c3, $1
  // ASM-RISCV: cfromptr ca0, ddc, a0
  return (__cheri_tocap void *__capability)data_ptr;
}
