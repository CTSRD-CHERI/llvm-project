// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// REQUIRES: riscv-registered-target
// REQUIRES: mips-registered-target
// Check that we convert function pointers to PCC-relative capabilities and
// data pointers to ddc relative ones: (at least for globals)
// RUN: %cheri_cc1 -o - -emit-llvm %s | FileCheck %s
// RUN: %riscv64_cheri_cc1 -o - -emit-llvm %s | FileCheck %s

// Check the assembly output to see if we used PCC or DDC
// RUN: %cheri_cc1 -o - -S %s | FileCheck %s --check-prefixes=ASM,ASM-MIPS
// RUN: %riscv64_cheri_cc1 -o - -S %s | FileCheck %s --check-prefixes=ASM,ASM-RISCV


void external_fn(void);
int external_global;

// CHECK-LABEL: define {{[^@]+}}@global_fn_to_cap() #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8 addrspace(200)* addrspacecast (i8* bitcast (void ()* @external_fn to i8*) to i8 addrspace(200)*)
//
void* __capability global_fn_to_cap(void) {
  // ASM-LABEL: global_fn_to_cap:
  // ASM-MIPS: ld $1, %got_disp(external_fn)($1)
  // ASM-MIPS-NEXT: cgetpccsetoffset	$c3, $1
  // ASM-RISCV: auipc a0, %got_pcrel_hi(external_fn)
  // ASM-RISCV-NEXT:  ld a0, %pcrel_lo(
  // FIXME-CHERI-RISCV: This is wrong:
  // ASM-RISCV-NEXT:  cfromptr ca0, ddc, a0
  return (__cheri_tocap void* __capability)&external_fn;
}

// CHECK-LABEL: define {{[^@]+}}@global_data_to_cap() #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8 addrspace(200)* addrspacecast (i8* bitcast (i32* @external_global to i8*) to i8 addrspace(200)*)
//
void* __capability global_data_to_cap(void) {
  // ASM-LABEL: global_data_to_cap:
  // ASM-MIPS: ld $1, %got_disp(external_global)($1)
  // ASM-MIPS-NEXT: cfromddc $c3, $1
  // ASM-RISCV: auipc a0, %got_pcrel_hi(external_global)
  // ASM-RISCV-NEXT:  ld a0, %pcrel_lo(
  // ASM-RISCV-NEXT:  cfromptr ca0, ddc, a0
  return (__cheri_tocap void* __capability)&external_global;
}

// CHECK-LABEL: define {{[^@]+}}@fn_ptr_to_cap
// CHECK-SAME: (void ()* [[FN_PTR:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FN_PTR_ADDR:%.*]] = alloca void ()*, align 8
// CHECK-NEXT:    store void ()* [[FN_PTR]], void ()** [[FN_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load void ()*, void ()** [[FN_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast void ()* [[TMP0]] to i8*
// CHECK-NEXT:    [[TMP2:%.*]] = addrspacecast i8* [[TMP1]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP2]]
//
void* __capability fn_ptr_to_cap(void (*fn_ptr)(void)) {
  // Note: for function pointers we don't currently infer that we have to derive from PCC:
  // ASM-LABEL: fn_ptr_to_cap:
  // ASM-MIPS:  cfromddc $c3, $1
  // ASM-RISCV: cfromptr ca0, ddc, a0
  return (__cheri_tocap void* __capability)fn_ptr;
}

// CHECK-LABEL: define {{[^@]+}}@data_ptr_to_cap
// CHECK-SAME: (i32* [[DATA_PTR:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA_PTR_ADDR:%.*]] = alloca i32*, align 8
// CHECK-NEXT:    store i32* [[DATA_PTR]], i32** [[DATA_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i32*, i32** [[DATA_PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32* [[TMP0]] to i8*
// CHECK-NEXT:    [[TMP2:%.*]] = addrspacecast i8* [[TMP1]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP2]]
//
void* __capability data_ptr_to_cap(int* data_ptr) {
  // Note: For data pointers we derive from DDC:
  // ASM-LABEL: data_ptr_to_cap:
  // ASM-MIPS:  cfromddc $c3, $1
  // ASM-RISCV: cfromptr ca0, ddc, a0
  return (__cheri_tocap void* __capability)data_ptr;
}
