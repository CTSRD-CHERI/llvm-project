// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -disable-O0-optnone \
// RUN:   -emit-llvm %s -o - -Rcheri-subobject-bounds -verify \
// RUN:   | opt -S -mem2reg | FileCheck %s

union UA {
  char a[2];
};

struct SA {
  char a[2];
};

struct TA {
  char a[2] __attribute__((cheri_subobject_bounds_use_remaining_size));
};

union UP {
  char *p;
};

struct SP {
  char *p;
};

struct TP {
  char *p __attribute__((cheri_subobject_bounds_use_remaining_size));
};

// TODO: Currently the UP and TP tests incorrectly use the bounds of the
// pointer's container, treating it as if it were an array instead. TP
// additionally gets its first use-remaining-size bounds setting wrong,
// applying it to the pointer as well.

// CHECK-LABEL: @test_UA(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = bitcast [[UNION_UA:%.*]] addrspace(200)* [[UA:%.*]] to [2 x i8] addrspace(200)*
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [2 x i8] addrspace(200)* [[A]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* [[TMP0]], i64 2)
// CHECK-NEXT:    [[SUBSCRIPT_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP1]] to [2 x i8] addrspace(200)*
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast [2 x i8] addrspace(200)* [[SUBSCRIPT_WITH_BOUNDS]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP3:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* [[TMP2]], i64 2)
// CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP3]] to [2 x i8] addrspace(200)*
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x i8], [2 x i8] addrspace(200)* [[ADDRESS_WITH_BOUNDS]], i64 0, i64 1
// CHECK-NEXT:    ret i8 addrspace(200)* [[ARRAYIDX]]
//
char *test_UA(union UA *ua) {
  return &ua->a[1];
  // expected-remark@-1 {{setting sub-object bounds for field 'a' (array subscript on 'char [2]') to 2 bytes}}
  // expected-remark@-2 {{using size of containing type 'union UA' instead of object type 'char' for subobject bounds on union member}}
  // expected-remark@-3 {{setting sub-object bounds for pointer to 'char' to 2 bytes}}
}

// CHECK-LABEL: @test_SA(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_SA:%.*]], [[STRUCT_SA]] addrspace(200)* [[SA:%.*]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [2 x i8] addrspace(200)* [[A]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* [[TMP0]], i64 2)
// CHECK-NEXT:    [[SUBSCRIPT_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP1]] to [2 x i8] addrspace(200)*
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast [2 x i8] addrspace(200)* [[SUBSCRIPT_WITH_BOUNDS]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP3:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* [[TMP2]], i64 2)
// CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP3]] to [2 x i8] addrspace(200)*
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x i8], [2 x i8] addrspace(200)* [[ADDRESS_WITH_BOUNDS]], i64 0, i64 1
// CHECK-NEXT:    ret i8 addrspace(200)* [[ARRAYIDX]]
//
char *test_SA(struct SA *sa) {
  return &sa->a[1];
  // expected-remark@-1 {{setting sub-object bounds for field 'a' (array subscript on 'char [2]') to 2 bytes}}
  // expected-remark@-2 {{using size of containing type 'char [2]' instead of object type 'char' for subobject bounds on &array[<CONSTANT>]}}
  // expected-remark@-3 {{setting sub-object bounds for pointer to 'char' to 2 bytes}}
}

// CHECK-LABEL: @test_TA(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_TA:%.*]], [[STRUCT_TA]] addrspace(200)* [[TA:%.*]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [2 x i8] addrspace(200)* [[A]] to i8 addrspace(200)*
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [2 x i8] addrspace(200)* [[A]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP2:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* [[TMP1]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    [[SUBSCRIPT_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP2]] to [2 x i8] addrspace(200)*
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [2 x i8], [2 x i8] addrspace(200)* [[SUBSCRIPT_WITH_BOUNDS]], i64 0, i64 1
// CHECK-NEXT:    [[CUR_OFFSET1:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[ARRAYIDX]])
// CHECK-NEXT:    [[CUR_LEN2:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* [[ARRAYIDX]])
// CHECK-NEXT:    [[REMAINING_BYTES3:%.*]] = sub i64 [[CUR_LEN2]], [[CUR_OFFSET1]]
// CHECK-NEXT:    [[TMP3:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* [[ARRAYIDX]], i64 [[REMAINING_BYTES3]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP3]]
//
char *test_TA(struct TA *ta) {
  return &ta->a[1];
  // expected-remark@-1 {{setting sub-object bounds for field 'a' (array subscript on 'char [2]') to remaining bytes (member has use-remaining-size attribute)}}
  // expected-remark@-2 {{setting sub-object bounds for field 'a' (pointer to 'char') to remaining bytes (member has use-remaining-size attribute)}}
}

// CHECK-LABEL: @test_UP(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P:%.*]] = bitcast [[UNION_UP:%.*]] addrspace(200)* [[UP:%.*]] to i8 addrspace(200)* addrspace(200)*
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[P]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* [[TMP0]], i64 16)
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[TMP1]], i64 1
// CHECK-NEXT:    ret i8 addrspace(200)* [[ARRAYIDX]]
//
char *test_UP(union UP *up) {
  return &up->p[1];
  // expected-remark@-1 {{not setting bounds for array subscript on 'char *' (array subscript on non-array type)}}
  // expected-remark@-2 {{using size of containing type 'union UP' instead of object type 'char' for subobject bounds on union member}}
  // expected-remark@-3 {{setting sub-object bounds for pointer to 'char' to 16 bytes}}
}

// CHECK-LABEL: @test_SP(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds [[STRUCT_SP:%.*]], [[STRUCT_SP]] addrspace(200)* [[SP:%.*]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[P]], align 16
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[TMP0]], i64 1
// CHECK-NEXT:    ret i8 addrspace(200)* [[ARRAYIDX]]
//
char *test_SP(struct SP *sp) {
  return &sp->p[1];
  // expected-remark@-1 {{not setting bounds for array subscript on 'char *' (array subscript on non-array type)}}
  // expected-remark@-2 {{not setting bounds for pointer to 'char' (should set bounds on full array but size is not known)}}
}

// CHECK-LABEL: @test_TP(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds [[STRUCT_TP:%.*]], [[STRUCT_TP]] addrspace(200)* [[TP:%.*]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[P]], align 16
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* [[TMP0]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[TMP1]], i64 1
// CHECK-NEXT:    [[CUR_OFFSET1:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[ARRAYIDX]])
// CHECK-NEXT:    [[CUR_LEN2:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* [[ARRAYIDX]])
// CHECK-NEXT:    [[REMAINING_BYTES3:%.*]] = sub i64 [[CUR_LEN2]], [[CUR_OFFSET1]]
// CHECK-NEXT:    [[TMP2:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* [[ARRAYIDX]], i64 [[REMAINING_BYTES3]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP2]]
//
char *test_TP(struct TP *tp) {
  return &tp->p[1];
  // expected-remark@-1 {{setting sub-object bounds for field 'p' (array subscript on 'char *') to remaining bytes (member has use-remaining-size attribute)}}
  // expected-remark@-2 {{setting sub-object bounds for field 'p' (pointer to 'char') to remaining bytes (member has use-remaining-size attribute)}}
}
