// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %cheri_purecap_cc1 -emit-llvm -O2 %s -o - | FileCheck %s
// RUN: %cheri_purecap_cc1 -S -O2 %s -o - | FileCheck %s --check-prefix ASM
// This used to crash with an assertion:
// void llvm::CCState::getInRegsParamInfo(unsigned int, unsigned int &, unsigned int &) const: Assertion `InRegsParamRecordIndex < ByValRegs.size() && "Wrong ByVal parameter index"' failed.

// It should be calling memcpy instead of attempting to pass the huge struct inreg:
// ASM: clcbi	$c12, %capcall20(memcpy)(
typedef struct { int err_msg[1024]; } Dwarf_Error;
extern Dwarf_Error a;
void fn2();
// CHECK-LABEL: define {{[^@]+}}@fn1
// CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_DWARF_ERROR:%.*]], align 8, addrspace(200)
// CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 4096, ptr addrspace(200) nonnull [[BYVAL_TEMP]]) #[[ATTR4:[0-9]+]]
// CHECK-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) noundef nonnull align 8 dereferenceable(4096) [[BYVAL_TEMP]], ptr addrspace(200) noundef nonnull align 4 dereferenceable(4096) @a, i64 4096, i1 false), !tbaa.struct !2
// CHECK-NEXT:    tail call void @fn2(ptr addrspace(200) noundef nonnull byval([[STRUCT_DWARF_ERROR]]) align 8 [[BYVAL_TEMP]]) #[[ATTR4]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p200(i64 4096, ptr addrspace(200) nonnull [[BYVAL_TEMP]]) #[[ATTR4]]
// CHECK-NEXT:    ret void
//
void fn1() {
  fn2(a);
}
