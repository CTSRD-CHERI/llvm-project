// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -emit-llvm -O2 %s -o - | FileCheck %s
// RUN: %cheri_purecap_cc1 -S -O2 %s -o - | FileCheck %s --check-prefix ASM
// This used to crash with an assertion:
// void llvm::CCState::getInRegsParamInfo(unsigned int, unsigned int &, unsigned int &) const: Assertion `InRegsParamRecordIndex < ByValRegs.size() && "Wrong ByVal parameter index"' failed.

// It should be calling memcpy instead of attempting to pass the huge struct inreg:
// ASM: clcbi	$c12, %capcall20(memcpy)(
typedef struct { int err_msg[1024]; } Dwarf_Error;
Dwarf_Error a;
void fn2();
// CHECK-LABEL: define {{[^@]+}}@fn1() local_unnamed_addr addrspace(200) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_DWARF_ERROR:%.*]], align 8, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_DWARF_ERROR]] addrspace(200)* [[BYVAL_TEMP]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.lifetime.start.p200i8(i64 4096, i8 addrspace(200)* nonnull [[TMP0]]) #3
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* nonnull align 8 dereferenceable(4096) [[TMP0]], i8 addrspace(200)* nonnull align 4 dereferenceable(4096) bitcast (%struct.Dwarf_Error addrspace(200)* @a to i8 addrspace(200)*), i64 4096, i1 false), !tbaa.struct !2
// CHECK-NEXT:    tail call void bitcast (void (...) addrspace(200)* @fn2 to void (%struct.Dwarf_Error addrspace(200)*) addrspace(200)*)(%struct.Dwarf_Error addrspace(200)* nonnull byval(%struct.Dwarf_Error) align 8 [[BYVAL_TEMP]]) #3
// CHECK-NEXT:    call void @llvm.lifetime.end.p200i8(i64 4096, i8 addrspace(200)* nonnull [[TMP0]]) #3
// CHECK-NEXT:    ret void
//
void fn1() {
  fn2(a);
}
