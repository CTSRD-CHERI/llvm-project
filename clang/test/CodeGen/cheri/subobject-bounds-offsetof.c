// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -disable-O0-optnone -emit-llvm %s -o - -cheri-bounds=subobject-safe \
// RUN:   | opt -S -mem2reg | FileCheck %s
// RUN: %cheri_purecap_cc1 -disable-O0-optnone -emit-llvm %s -o - -cheri-bounds=aggressive \
// RUN:   | opt -S -mem2reg | FileCheck %s
// RUN: %cheri_purecap_cc1 -disable-O0-optnone -emit-llvm %s -o - -cheri-bounds=very-aggressive \
// RUN:   | opt -S -mem2reg | FileCheck %s
// RUN: %cheri_purecap_cc1 -disable-O0-optnone -emit-llvm %s -o - -cheri-bounds=everywhere-unsafe \
// RUN:   | opt -S -mem2reg | FileCheck %s

// Check that we don't set bounds on hand-rolled offsetof idioms using NULL.
// This is technically UB but we need to make it work in practice.

struct S {
  int x;
  struct {
    int z;
  } y;
};

// CHECK-LABEL: @offsetof_x(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* null, i64 4)
// CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP0]] to i32 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 addrspace(200)* [[ADDRESS_WITH_BOUNDS]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP1]])
// CHECK-NEXT:    ret i64 [[TMP2]]
//
long offsetof_x(void) {
  return (long)&((struct S *)0)->x;
}

// CHECK-LABEL: @offsetof_z(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* bitcast (i32 addrspace(200)* getelementptr inbounds ([[STRUCT_S:%.*]], [[STRUCT_S]] addrspace(200)* null, i32 0, i32 1, i32 0) to i8 addrspace(200)*), i64 4)
// CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP0]] to i32 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast i32 addrspace(200)* [[ADDRESS_WITH_BOUNDS]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP1]])
// CHECK-NEXT:    ret i64 [[TMP2]]
//
long offsetof_z(void) {
  return (long)&((struct S *)0)->y.z;
}
