// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// REQUIRES: mips-registered-target

// RUN: %cheri_purecap_cc1 -std=c11 %s -emit-llvm -o - -O0 | %cheri_FileCheck %s
// RUN: %cheri_purecap_cc1 -std=c11 %s -emit-llvm -o - -O2 | %cheri_FileCheck %s -check-prefixes OPT,NULL_INVALID-OPT
// RUN: %cheri_purecap_cc1 -std=c11 %s -emit-llvm -o - -O2 -fno-delete-null-pointer-checks | %cheri_FileCheck %s -check-prefixes OPT,NO_DELETE_NULL-OPT
// Check that we can generate assembly without crashing
// RUN: %cheri_purecap_cc1 -mllvm -cheri-cap-table-abi=plt -std=c11 %s -S -o - -O2 -fno-delete-null-pointer-checks | FileCheck %s -check-prefix ASM

// This previously crashed in codegen when generating the *p
// CHECK-LABEL: @main(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[P:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    store i32 0, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    store ptr addrspace(200) null, ptr addrspace(200) [[P]], align 16
// CHECK-NEXT:    [[ATOMIC_LOAD:%.*]] = load atomic ptr addrspace(200), ptr addrspace(200) [[P]] seq_cst, align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[ATOMIC_LOAD]], align 4
// CHECK-NEXT:    ret i32 [[TMP0]]
//
// NULL_INVALID-OPT-LABEL: @main(
// NULL_INVALID-OPT-NEXT:  entry:
// Now clang can tell that it is dereferencing a null pointer and returns undef
// NULL_INVALID-OPT-NEXT:    ret i32 undef
//
// NO_DELETE_NULL-OPT-LABEL: @main(
// NO_DELETE_NULL-OPT-NEXT:  entry:
// This uses a crazy alignment value (the maximum) because it is loading a null pointer, not a bug!
// NO_DELETE_NULL-OPT-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) null, align 4294967296, !tbaa [[TBAA2:![0-9]+]]
// NO_DELETE_NULL-OPT-NEXT:    ret i32 [[TMP0]]
int main(void) {
  _Atomic(int*) p = (int*)0;
  return *p;

  // TODO: why is this not going in the delay slot?
  // ASM-LABEL: main:
  // ASM:      cgetnull	$c1
  // ASM-NEXT: clw	$2, $zero, 0($c1)
  // ASM-NEXT: cjr	$c17
  // ASM-NEXT: nop
}

// This previously crashed in codegen when generating the *p
// CHECK-LABEL: @main2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) [[P:%.*]], ptr addrspace(200) [[P_ADDR]], align 16
// CHECK-NEXT:    [[ATOMIC_LOAD:%.*]] = load atomic ptr addrspace(200), ptr addrspace(200) [[P_ADDR]] seq_cst, align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[ATOMIC_LOAD]], align 4
// CHECK-NEXT:    ret i32 [[TMP0]]
//
// OPT-LABEL: @main2(
// OPT-NEXT:  entry:
// OPT-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[P:%.*]], align 4, !tbaa [[TBAA2:![0-9]+]]
// OPT-NEXT:    ret i32 [[TMP0]]
//
int main2(_Atomic(int*) p) {
  return *p;
  // ASM-LABEL: main2:
  // TODO: why is this not going in the delay slot?
  // ASM:      clw	$2, $zero, 0($c3)
  // ASM-NEXT: cjr	$c17
  // ASM-NEXT: nop
}


// This was also crashing:
_Atomic(int *) a;
// CHECK-LABEL: @test_store(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    store atomic ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i64 1), ptr addrspace(200) @a seq_cst, align 16
// CHECK-NEXT:    ret void
//
// OPT-LABEL: @test_store(
// OPT-NEXT:  entry:
// OPT-NEXT:    store atomic ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i64 1), ptr addrspace(200) @a seq_cst, align 16, !tbaa [[TBAA6:![0-9]+]]
// OPT-NEXT:    ret void
//
void test_store() {
  a = (void *)1;
  // ASM-LABEL: test_store:
  // TODO: why is this not going in the delay slot?
  // ASM: clcbi	$c1, %captab20(a)($c26)
  // ASM-NEXT: sync
  // ASM-NEXT: cincoffset	$c2, $cnull, 1
  // ASM-NEXT: csc	$c2, $zero, 0($c1)
  // ASM-NEXT: sync
  // ASM-NEXT: cjr	$c17
  // ASM-NEXT: nop
}
