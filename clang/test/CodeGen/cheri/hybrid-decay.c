// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 -disable-O0-optnone -emit-llvm %s -o - \
// RUN:   | opt -S -mem2reg | FileCheck %s

struct S {
  char buf[1];
};

// TODO: None of these should involve addrspacecast

// These tests may look redundant, as one would expect that if the decay-only
// tests all work (which test various different expressions the frontend needs
// to look at in order to find the __capability) then the binary expression
// ones should too. However, arrow_plus_1 (and curiously only it) is stubborn
// and, if it generates erroneous addrspacecast's, those somehow persist,
// whereas the other two variants, and all the decay-only tests, all have their
// addrspacecast's folded if optimisations are enabled, masking the bug.

// CHECK-LABEL: @arrow(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUF:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], [[STRUCT_S]] addrspace(200)* [[P:%.*]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [1 x i8], [1 x i8] addrspace(200)* [[BUF]], i64 0, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[ARRAYDECAY]] to i8*
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast i8* [[TMP0]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char * __capability arrow(struct S * __capability p) {
  return p->buf;
}

// CHECK-LABEL: @deref(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [1 x i8], [1 x i8] addrspace(200)* [[P:%.*]], i64 0, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[ARRAYDECAY]] to i8*
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast i8* [[TMP0]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char * __capability deref(char (* __capability p)[1]) {
  return *p;
}

// CHECK-LABEL: @sub(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [1 x i8], [1 x i8] addrspace(200)* [[P:%.*]], i64 0
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [1 x i8], [1 x i8] addrspace(200)* [[ARRAYIDX]], i64 0, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[ARRAYDECAY]] to i8*
// CHECK-NEXT:    [[TMP1:%.*]] = addrspacecast i8* [[TMP0]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char * __capability sub(char (* __capability p)[1]) {
  return p[0];
}

// CHECK-LABEL: @arrow_plus_1(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUF:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], [[STRUCT_S]] addrspace(200)* [[P:%.*]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [1 x i8], [1 x i8] addrspace(200)* [[BUF]], i64 0, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[ARRAYDECAY]] to i8*
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, i8* [[TMP0]], i64 1
// CHECK-NEXT:    [[ADD_PTR_ASCAST:%.*]] = addrspacecast i8* [[ADD_PTR]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[ADD_PTR_ASCAST]]
//
char * __capability arrow_plus_1(struct S * __capability p) {
  return p->buf + 1;
}

// CHECK-LABEL: @deref_plus_1(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [1 x i8], [1 x i8] addrspace(200)* [[P:%.*]], i64 0, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[ARRAYDECAY]] to i8*
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, i8* [[TMP0]], i64 1
// CHECK-NEXT:    [[ADD_PTR_ASCAST:%.*]] = addrspacecast i8* [[ADD_PTR]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[ADD_PTR_ASCAST]]
//
char * __capability deref_plus_1(char (* __capability p)[1]) {
  return *p + 1;
}

// CHECK-LABEL: @sub_plus_1(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [1 x i8], [1 x i8] addrspace(200)* [[P:%.*]], i64 0
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [1 x i8], [1 x i8] addrspace(200)* [[ARRAYIDX]], i64 0, i64 0
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[ARRAYDECAY]] to i8*
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, i8* [[TMP0]], i64 1
// CHECK-NEXT:    [[ADD_PTR_ASCAST:%.*]] = addrspacecast i8* [[ADD_PTR]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[ADD_PTR_ASCAST]]
//
char * __capability sub_plus_1(char (* __capability p)[1]) {
  return p[0] + 1;
}
