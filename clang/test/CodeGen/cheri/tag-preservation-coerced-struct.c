// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %riscv64_cheri_purecap_cc1 %s -emit-llvm -o - -O0 | FileCheck %s
/// Test that we set the no_preserve_tags flag for coerced struct return values.
/// Original test case found building XML_ExpatVersionInfo.

typedef struct {
  int major;
  int minor;
  int micro;
} XML_Expat_Version;
// CHECK-LABEL: define {{[^@]+}}@XML_ExpatVersionInfo
// CHECK-SAME: () addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_XML_EXPAT_VERSION:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[RETVAL_COERCE:%.*]] = alloca [2 x i64], align 8, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_XML_EXPAT_VERSION]] addrspace(200)* [[RETVAL]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 4 [[TMP0]], i8 addrspace(200)* align 4 bitcast ([[STRUCT_XML_EXPAT_VERSION]] addrspace(200)* @__const.XML_ExpatVersionInfo.ret to i8 addrspace(200)*), i64 12, i1 false) #[[ATTR2:[0-9]+]]
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [2 x i64] addrspace(200)* [[RETVAL_COERCE]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP2:%.*]] = bitcast [[STRUCT_XML_EXPAT_VERSION]] addrspace(200)* [[RETVAL]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 8 [[TMP1]], i8 addrspace(200)* align 4 [[TMP2]], i64 12, i1 false)
// CHECK-NEXT:    [[TMP3:%.*]] = load [2 x i64], [2 x i64] addrspace(200)* [[RETVAL_COERCE]], align 8
// CHECK-NEXT:    ret [2 x i64] [[TMP3]]
//
XML_Expat_Version XML_ExpatVersionInfo(void) {
  XML_Expat_Version ret = {1, 2, 3};
  return ret;
}
// CHECK-LABEL: define {{[^@]+}}@take_XML_ExpatVersionInfo
// CHECK-SAME: ([2 x i64] [[V_COERCE:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[V:%.*]] = alloca [[STRUCT_XML_EXPAT_VERSION:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP_COERCE:%.*]] = alloca [2 x i64], align 8, addrspace(200)
// CHECK-NEXT:    store [2 x i64] [[V_COERCE]], [2 x i64] addrspace(200)* [[TMP_COERCE]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_XML_EXPAT_VERSION]] addrspace(200)* [[V]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [2 x i64] addrspace(200)* [[TMP_COERCE]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 4 [[TMP0]], i8 addrspace(200)* align 8 [[TMP1]], i64 12, i1 false)
// CHECK-NEXT:    [[MAJOR:%.*]] = getelementptr inbounds [[STRUCT_XML_EXPAT_VERSION]], [[STRUCT_XML_EXPAT_VERSION]] addrspace(200)* [[V]], i32 0, i32 0
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32 addrspace(200)* [[MAJOR]], align 4
// CHECK-NEXT:    ret i32 [[TMP2]]
//
int take_XML_ExpatVersionInfo(XML_Expat_Version v) {
  return v.major;
}
// CHECK-LABEL: define {{[^@]+}}@pass_XML_ExpatVersionInfo
// CHECK-SAME: () addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTCOMPOUNDLITERAL:%.*]] = alloca [[STRUCT_XML_EXPAT_VERSION:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[DOTCOMPOUNDLITERAL_COERCE:%.*]] = alloca [2 x i64], align 8, addrspace(200)
// CHECK-NEXT:    [[MAJOR:%.*]] = getelementptr inbounds [[STRUCT_XML_EXPAT_VERSION]], [[STRUCT_XML_EXPAT_VERSION]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// CHECK-NEXT:    store i32 1, i32 addrspace(200)* [[MAJOR]], align 4
// CHECK-NEXT:    [[MINOR:%.*]] = getelementptr inbounds [[STRUCT_XML_EXPAT_VERSION]], [[STRUCT_XML_EXPAT_VERSION]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 1
// CHECK-NEXT:    store i32 2, i32 addrspace(200)* [[MINOR]], align 4
// CHECK-NEXT:    [[MICRO:%.*]] = getelementptr inbounds [[STRUCT_XML_EXPAT_VERSION]], [[STRUCT_XML_EXPAT_VERSION]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 2
// CHECK-NEXT:    store i32 3, i32 addrspace(200)* [[MICRO]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [2 x i64] addrspace(200)* [[DOTCOMPOUNDLITERAL_COERCE]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_XML_EXPAT_VERSION]] addrspace(200)* [[DOTCOMPOUNDLITERAL]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 8 [[TMP0]], i8 addrspace(200)* align 4 [[TMP1]], i64 12, i1 false)
// CHECK-NEXT:    [[TMP2:%.*]] = load [2 x i64], [2 x i64] addrspace(200)* [[DOTCOMPOUNDLITERAL_COERCE]], align 8
// CHECK-NEXT:    [[CALL:%.*]] = call signext i32 @take_XML_ExpatVersionInfo([2 x i64] [[TMP2]])
// CHECK-NEXT:    ret i32 [[CALL]]
//
int pass_XML_ExpatVersionInfo(void) {
  return take_XML_ExpatVersionInfo((XML_Expat_Version){1, 2, 3});
}

typedef struct {
  int a;
  int b;
} int_pair;
// CHECK-LABEL: define {{[^@]+}}@ret_int_pair
// CHECK-SAME: () addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca [[STRUCT_INT_PAIR:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_INT_PAIR]] addrspace(200)* [[RETVAL]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 4 [[TMP0]], i8 addrspace(200)* align 4 bitcast ([[STRUCT_INT_PAIR]] addrspace(200)* @__const.ret_int_pair.ret to i8 addrspace(200)*), i64 8, i1 false) #[[ATTR2]]
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_INT_PAIR]] addrspace(200)* [[RETVAL]] to i64 addrspace(200)*
// CHECK-NEXT:    [[TMP2:%.*]] = load i64, i64 addrspace(200)* [[TMP1]], align 4
// CHECK-NEXT:    ret i64 [[TMP2]]
//
int_pair ret_int_pair(void) {
  int_pair ret = {1, 2};
  return ret;
}
// CHECK-LABEL: define {{[^@]+}}@take_int_pair
// CHECK-SAME: (i64 [[P_COERCE:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P:%.*]] = alloca [[STRUCT_INT_PAIR:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_INT_PAIR]] addrspace(200)* [[P]] to i64 addrspace(200)*
// CHECK-NEXT:    store i64 [[P_COERCE]], i64 addrspace(200)* [[TMP0]], align 4
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_INT_PAIR]], [[STRUCT_INT_PAIR]] addrspace(200)* [[P]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, i32 addrspace(200)* [[A]], align 4
// CHECK-NEXT:    ret i32 [[TMP1]]
//
int take_int_pair(int_pair p) {
  return p.a;
}
// CHECK-LABEL: define {{[^@]+}}@pass_int_pair
// CHECK-SAME: () addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTCOMPOUNDLITERAL:%.*]] = alloca [[STRUCT_INT_PAIR:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_INT_PAIR]], [[STRUCT_INT_PAIR]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// CHECK-NEXT:    store i32 1, i32 addrspace(200)* [[A]], align 4
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_INT_PAIR]], [[STRUCT_INT_PAIR]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 1
// CHECK-NEXT:    store i32 2, i32 addrspace(200)* [[B]], align 4
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_INT_PAIR]] addrspace(200)* [[DOTCOMPOUNDLITERAL]] to i64 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = load i64, i64 addrspace(200)* [[TMP0]], align 4
// CHECK-NEXT:    [[CALL:%.*]] = call signext i32 @take_int_pair(i64 [[TMP1]])
// CHECK-NEXT:    ret i32 [[CALL]]
//
int pass_int_pair(void) {
  return take_int_pair((int_pair){1, 2});
}

typedef struct {
  __intcap a;
  int b;
} cap_int_pair;
// CHECK-LABEL: define {{[^@]+}}@ret_cap_int_pair
// CHECK-SAME: ([[STRUCT_CAP_INT_PAIR:%.*]] addrspace(200)* noalias sret([[STRUCT_CAP_INT_PAIR]]) align 16 [[AGG_RESULT:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RESULT_PTR:%.*]] = alloca i8 addrspace(200)*, align 16, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_CAP_INT_PAIR]] addrspace(200)* [[AGG_RESULT]] to i8 addrspace(200)*
// CHECK-NEXT:    store i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* addrspace(200)* [[RESULT_PTR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_CAP_INT_PAIR]] addrspace(200)* [[AGG_RESULT]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 [[TMP1]], i8 addrspace(200)* align 16 bitcast ([[STRUCT_CAP_INT_PAIR]] addrspace(200)* @__const.ret_cap_int_pair.ret to i8 addrspace(200)*), i64 32, i1 false) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    ret void
//
cap_int_pair ret_cap_int_pair(void) {
  cap_int_pair ret = {1, 2};
  return ret;
}
// CHECK-LABEL: define {{[^@]+}}@take_cap_int_pair
// CHECK-SAME: ([[STRUCT_CAP_INT_PAIR:%.*]] addrspace(200)* [[P:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_CAP_INT_PAIR]], [[STRUCT_CAP_INT_PAIR]] addrspace(200)* [[P]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[A]], align 16
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
__intcap take_cap_int_pair(cap_int_pair p) {
  return p.a;
}
// CHECK-LABEL: define {{[^@]+}}@pass_cap_int_pair
// CHECK-SAME: () addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTCOMPOUNDLITERAL:%.*]] = alloca [[STRUCT_CAP_INT_PAIR:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_CAP_INT_PAIR]], align 16, addrspace(200)
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_CAP_INT_PAIR]], [[STRUCT_CAP_INT_PAIR]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1), i8 addrspace(200)* addrspace(200)* [[A]], align 16
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_CAP_INT_PAIR]], [[STRUCT_CAP_INT_PAIR]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 1
// CHECK-NEXT:    store i32 2, i32 addrspace(200)* [[B]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_CAP_INT_PAIR]] addrspace(200)* [[BYVAL_TEMP]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_CAP_INT_PAIR]] addrspace(200)* [[DOTCOMPOUNDLITERAL]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 [[TMP0]], i8 addrspace(200)* align 16 [[TMP1]], i64 32, i1 false) #[[ATTR3]]
// CHECK-NEXT:    [[CALL:%.*]] = call i8 addrspace(200)* @take_cap_int_pair([[STRUCT_CAP_INT_PAIR]] addrspace(200)* [[BYVAL_TEMP]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[CALL]]
//
__intcap pass_cap_int_pair(void) {
  return take_cap_int_pair((cap_int_pair){1, 2});
}

typedef struct {
  __intcap a;
  __intcap b;
} cap_pair;
// CHECK-LABEL: define {{[^@]+}}@ret_cap_pair
// CHECK-SAME: ([[STRUCT_CAP_PAIR:%.*]] addrspace(200)* noalias sret([[STRUCT_CAP_PAIR]]) align 16 [[AGG_RESULT:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RESULT_PTR:%.*]] = alloca i8 addrspace(200)*, align 16, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_CAP_PAIR]] addrspace(200)* [[AGG_RESULT]] to i8 addrspace(200)*
// CHECK-NEXT:    store i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* addrspace(200)* [[RESULT_PTR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_CAP_PAIR]] addrspace(200)* [[AGG_RESULT]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 [[TMP1]], i8 addrspace(200)* align 16 bitcast ([[STRUCT_CAP_PAIR]] addrspace(200)* @__const.ret_cap_pair.ret to i8 addrspace(200)*), i64 32, i1 false) #[[ATTR3]]
// CHECK-NEXT:    ret void
//
cap_pair ret_cap_pair(void) {
  cap_pair ret = {1, 2};
  return ret;
}
// CHECK-LABEL: define {{[^@]+}}@take_cap_pair
// CHECK-SAME: ([[STRUCT_CAP_PAIR:%.*]] addrspace(200)* [[P:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_CAP_PAIR]], [[STRUCT_CAP_PAIR]] addrspace(200)* [[P]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[A]], align 16
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
__intcap take_cap_pair(cap_pair p) {
  return p.a;
}
// CHECK-LABEL: define {{[^@]+}}@pass_cap_pair
// CHECK-SAME: () addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTCOMPOUNDLITERAL:%.*]] = alloca [[STRUCT_CAP_PAIR:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_CAP_PAIR]], align 16, addrspace(200)
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_CAP_PAIR]], [[STRUCT_CAP_PAIR]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1), i8 addrspace(200)* addrspace(200)* [[A]], align 16
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_CAP_PAIR]], [[STRUCT_CAP_PAIR]] addrspace(200)* [[DOTCOMPOUNDLITERAL]], i32 0, i32 1
// CHECK-NEXT:    store i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 2), i8 addrspace(200)* addrspace(200)* [[B]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_CAP_PAIR]] addrspace(200)* [[BYVAL_TEMP]] to i8 addrspace(200)*
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_CAP_PAIR]] addrspace(200)* [[DOTCOMPOUNDLITERAL]] to i8 addrspace(200)*
// CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 [[TMP0]], i8 addrspace(200)* align 16 [[TMP1]], i64 32, i1 false) #[[ATTR3]]
// CHECK-NEXT:    [[CALL:%.*]] = call i8 addrspace(200)* @take_cap_pair([[STRUCT_CAP_PAIR]] addrspace(200)* [[BYVAL_TEMP]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[CALL]]
//
__intcap pass_cap_pair(void) {
  return take_cap_pair((cap_pair){1, 2});
}

// UTC_ARGS: --disable
// CHECK: attributes #[[ATTR2]] = { no_preserve_cheri_tags }
// CHECK: attributes #[[ATTR3]] = { must_preserve_cheri_tags }
