// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 -o - -O2 -emit-llvm %s | FileCheck %s

// CHECK-LABEL: define {{[^@]+}}@add_invalid_ptr() local_unnamed_addr #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* inttoptr (i64 100 to i8 addrspace(200)*), i64 924)
//
void *__capability add_invalid_ptr(void) {
  // This cannot return a valid tagged capability:
  char* __capability cap = (char* __capability)100;
  cap += 10;
  return cap + 914;
}

// CHECK-LABEL: define {{[^@]+}}@add_valid_ptr() local_unnamed_addr #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* addrspacecast (i8* inttoptr (i64 100 to i8*) to i8 addrspace(200)*), i64 924)
//
void *__capability add_valid_ptr(void) {
  // This can return a valid tagged capability:
  char *__capability cap = (__cheri_tocap char *__capability)(char *)100;
  cap += 10;
  return cap + 914;
}

// CHECK-LABEL: define {{[^@]+}}@add_uintcap_t() local_unnamed_addr #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1024)
//
__uintcap_t add_uintcap_t(void) {
  // This always returns a untagged capability with offset 1024
  __uintcap_t cap = (__uintcap_t)100;
  cap += 10;
  return cap + 914;
}
