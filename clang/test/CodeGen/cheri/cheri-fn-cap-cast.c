// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %cheri_cc1 %s -emit-llvm  -o - | FileCheck %s
void (*__capability c)(void);
typedef void (*fnptr)(void);
// CHECK-LABEL: define {{[^@]+}}@cheri_codeptr
// CHECK-SAME: (ptr noundef [[PTR:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PTR_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[PTR]], ptr [[PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[PTR_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.pcc.get()
// CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[TMP0]] to i64
// CHECK-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) [[TMP1]], i64 [[TMP2]])
// CHECK-NEXT:    store ptr addrspace(200) [[TMP3]], ptr @c, align 16
// CHECK-NEXT:    ret void
//
void cheri_codeptr(const fnptr ptr) {
  // Check that this cast is PCC-relative and not DDC-relative
  c = (__cheri_tocap void (*__capability)(void))ptr;
}
