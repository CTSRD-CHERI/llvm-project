// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// We pipe through opt -mem2reg to make the test checks shorter (but keep -O0 to avoid seeing any instcombine folds)
// RUN: %cheri_cc1 -Wno-cheri-capability-misuse -ast-dump %s | FileCheck %s --check-prefix=AST
// RUN: %cheri_cc1 -Wno-error=cheri-capability-misuse -verify -emit-llvm -o - -disable-O0-optnone %s | opt -S -mem2reg -o - | FileCheck %s
// TODO: could split this into a Sema+CodeGen test, but having both here is easier

// CHECK-LABEL: define {{[^@]+}}@test_long_to_capptr
// CHECK-SAME: (i64 signext [[L:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = inttoptr i64 [[L]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
char *__capability test_long_to_capptr(long l) {
  // FIXME: this warning is wrong since it will use cfromddc!!
  return (char *__capability)l;
  // FIXME: wrong: expected-warning@-1{{cast from provenance-free integer type to pointer type will give pointer that can not be dereferenced}}
  // FIXME: wrong: expected-note@-2{{insert cast to intptr_t to silence this warning}}
  // AST-LABEL: FunctionDecl {{.+}} test_long_to_capptr
  // AST:       CStyleCastExpr {{.+}} 'char * __capability __attribute__((cheri_no_provenance))':'char * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'long' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_capptr
// CHECK-SAME: (i8 addrspace(200)* [[L:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8 addrspace(200)* [[L]]
//
char *__capability test_intcap_to_capptr(__intcap_t l) {
  return (char *__capability)l;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_capptr
  // AST:       CStyleCastExpr {{.+}} 'char * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap_t':'__intcap_t' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_ptr_to_capptr_default
// CHECK-SAME: (i8* [[P:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8* [[P]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
char *__capability test_ptr_to_capptr_default(char *p) {
  // FIXME: this warning is wrong since it will use cfromddc!!
  return (char *__capability)p;
  // FIXME: wrong: expected-warning@-1{{cast from provenance-free integer type to pointer type will give pointer that can not be dereferenced}}
  // FIXME: wrong: expected-note@-2{{insert cast to intptr_t to silence this warning}}
  // AST-LABEL: FunctionDecl {{.+}} test_ptr_to_capptr_default
  // AST:       CStyleCastExpr {{.+}} 'char * __capability' <PointerToCHERICapability>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char *' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_ptr_to_capptr_tocap
// CHECK-SAME: (i8* [[P:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8* [[P]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
char *__capability test_ptr_to_capptr_tocap(char *p) {
  return (__cheri_tocap char *__capability)p;
  // AST-LABEL: FunctionDecl {{.+}} test_ptr_to_capptr_tocap
  // AST:       CStyleCastExpr {{.+}} 'char * __capability' <PointerToCHERICapability>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char *' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_ptr_to_capptr_via_addr_intcap
// CHECK-SAME: (i8* [[P:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint i8* [[P]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP0]]
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char *__capability test_ptr_to_capptr_via_addr_intcap(char *p) {
  return (char *__capability)(__cheri_addr __intcap_t)p;
  // AST-LABEL: FunctionDecl {{.+}} test_ptr_to_capptr_via_addr_intcap
  // AST:       CStyleCastExpr {{.+}} 'char * __capability' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap_t':'__intcap_t' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char *' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_ptr_to_intcap_default
// CHECK-SAME: (i8* [[P:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint i8* [[P]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP0]]
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
__intcap_t test_ptr_to_intcap_default(char *p) {
  return (__intcap_t)p;
  // AST-LABEL: FunctionDecl {{.+}} test_ptr_to_intcap_default
  // AST:       CStyleCastExpr {{.+}} '__intcap_t':'__intcap_t' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char *' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_ptr_to_intcap_tocap
// CHECK-SAME: (i8* [[P:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8* [[P]] to i8 addrspace(200)*
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
__intcap_t test_ptr_to_intcap_tocap(char *p) {
  return (__cheri_tocap __intcap_t)p;
  // AST-LABEL: FunctionDecl {{.+}} test_ptr_to_intcap_tocap
  // AST:       CStyleCastExpr {{.+}} '__intcap_t':'__intcap_t' <PointerToCHERICapability>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char *' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_ptr_to_intcap_addr
// CHECK-SAME: (i8* [[P:%.*]]) #0
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = ptrtoint i8* [[P]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP0]]
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
__intcap_t test_ptr_to_intcap_addr(char *p) {
  return (__cheri_addr __intcap_t)p;
  // AST-LABEL: FunctionDecl {{.+}} test_ptr_to_intcap_addr
  // AST:       CStyleCastExpr {{.+}} '__intcap_t':'__intcap_t' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char *' <LValueToRValue> part_of_explicit_cast
}
