// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py

// Check that we can use the cheri_subobject_bounds_use_remaining_size annotation to set bounds on VLAs and vla-like constructs

// RUNNOT: %cheri_purecap_cc1 -cheri-bounds=aggressive -O2 -std=c11 -emit-llvm %s -o /dev/null -Rcheri-subobject-bounds -ast-dump -fcolor-diagnostics
// RUNNOT: %cheri_purecap_cc1 -cheri-bounds=aggressive -O2 -std=c11 -emit-llvm %s -o - -Rcheri-subobject-bounds -mllvm -debug-only=cheri-bounds
// RUN: %cheri_purecap_cc1 -cheri-bounds=aggressive -O2 -std=c11 -emit-llvm %s -o - -Rcheri-subobject-bounds -verify | FileCheck %s

// CHECK-LABEL: @test_basic(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA1:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DATA:%.*]], i64 4
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[DATA1]], i64 255)
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
void *test_basic(void *data, long index) {
  struct LikeStructDirent {
    int size;
    char data[255];
  } *l = data;
  int x = l->data[index]; // expected-remark{{setting sub-object bounds for field 'data' (array subscript on 'char[255]') to 255 bytes}}
  return &l->data;        // expected-remark{{setting sub-object bounds for field 'data' (pointer to 'char[255]') to 255 bytes}}
}

// CHECK-LABEL: @test_opt_out(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA1:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DATA:%.*]], i64 4
// CHECK-NEXT:    ret i8 addrspace(200)* [[DATA1]]
//
void *test_opt_out(void *data, long index) {
  struct LikeStructDirentOptOut {
    int size;
    char data[255] __attribute__((cheri_no_subobject_bounds));
  } *l = data;
  int x = l->data[index]; // expected-remark{{not setting bounds for array subscript on field 'data' (field has opt-out attribute)}}
  return &l->data;        // expected-remark{{not setting bounds for pointer to field 'data' (field has opt-out attribute)}}
}

// CHECK-LABEL: @test_remaining_size(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA1:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DATA:%.*]], i64 4
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[DATA1]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[DATA1]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[DATA1]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
void *test_remaining_size(void *data, long index) {
  struct LikeStructDirentRemainingSize {
    int size;
    char data[255] __attribute__((cheri_subobject_bounds_use_remaining_size));
  } *l = data;
  int x = l->data[index]; // expected-remark{{setting sub-object bounds for field 'data' (array subscript on 'char[255]') to remaining bytes (member has use-remaining-size attribute)}}
  return &l->data;        // expected-remark{{setting sub-object bounds for field 'data' (pointer to 'char[255]') to remaining bytes (member has use-remaining-size attribute)}}
}

// CHECK-LABEL: @test_remaining_size_not_array(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[F:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DATA:%.*]], i64 4
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[F]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[F]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[F]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
void *test_remaining_size_not_array(void *data, long index) {
  struct Foo {
    int x;
    int y;
  };
  struct RemainingSizeNotArray {
    int size;
    struct Foo f __attribute__((cheri_subobject_bounds_use_remaining_size));
    int pad;
  } *l = data;
  // This should just remove the first member from the data pointer
  return &l->f; // expected-remark{{setting sub-object bounds for field 'f' (pointer to 'struct Foo') to remaining bytes (member has use-remaining-size attribute)}}
}

// CHECK-LABEL: @test_remaining_size_on_type(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA1:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DATA:%.*]], i64 4
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[DATA1]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[DATA1]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[LESS_THAN_MAX_SIZE:%.*]] = icmp ult i64 [[REMAINING_BYTES]], 16
// CHECK-NEXT:    [[BOUNDED_REMAINING_SIZE:%.*]] = select i1 [[LESS_THAN_MAX_SIZE]], i64 [[REMAINING_BYTES]], i64 16
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[DATA1]], i64 [[BOUNDED_REMAINING_SIZE]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
void *test_remaining_size_on_type(void *data, long index) {
  struct UseRemaining {
    int x;
  } __attribute__((cheri_subobject_bounds_use_remaining_size(16)));
  struct WithRemainingSize {
    int size;
    struct UseRemaining data;
    int pad;
  } *l = data;
  return &l->data; // expected-remark{{setting sub-object bounds for field 'data' (pointer to 'struct UseRemaining') to min(16, remaining) bytes (member type has use-remaining-size attribute)}}
}

// TODO: would be nice to support it on typedefs too, but attributes with arguments don't seem to work very well.
// CHECK-LABEL: @test_remaining_size_ignored_on_typedef(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA1:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DATA:%.*]], i64 8
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[DATA1]], i64 4)
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
void *test_remaining_size_ignored_on_typedef(void *data, long index) {
  struct DontUseRemaining {
    int x;
  };
  typedef struct DontUseRemaining UseRemainingTypedef __attribute__((cheri_subobject_bounds_use_remaining_size(18)));
  // expected-warning@-1{{'cheri_subobject_bounds_use_remaining_size' attribute only applies to non-static data members, structs, unions, and classes}}
  struct WithRemainingSize {
    int size;
    struct DontUseRemaining bounded_data;
    UseRemainingTypedef data;
    int pad;
  } *l = data;
  (void)&l->bounded_data; // expected-remark{{setting sub-object bounds for field 'bounded_data' (pointer to 'struct DontUseRemaining') to 4 bytes}}
  return &l->data;        // expected-remark{{setting sub-object bounds for field 'data' (pointer to 'UseRemainingTypedef' (aka 'struct DontUseRemaining')) to 4 bytes}}
}

// CHECK-LABEL: @test_remaining_size_maximum(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DATA1:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DATA:%.*]], i64 4
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[DATA1]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[DATA1]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[LESS_THAN_MAX_SIZE:%.*]] = icmp ult i64 [[REMAINING_BYTES]], 127
// CHECK-NEXT:    [[BOUNDED_REMAINING_SIZE:%.*]] = select i1 [[LESS_THAN_MAX_SIZE]], i64 [[REMAINING_BYTES]], i64 127
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[DATA1]], i64 [[BOUNDED_REMAINING_SIZE]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
void *test_remaining_size_maximum(void *data, long index) {
  struct LikeStructDirentRemainingSizeWithMax {
    int size;
    char data[255] __attribute__((cheri_subobject_bounds_use_remaining_size(127)));
  } *l = data;
  int x = l->data[index]; // expected-remark{{setting sub-object bounds for field 'data' (array subscript on 'char[255]') to min(127, remaining) bytes (member has use-remaining-size attribute)}}
  return &l->data;        // expected-remark{{setting sub-object bounds for field 'data' (pointer to 'char[255]') to min(127, remaining) bytes (member has use-remaining-size attribute)}}
}

// CHECK-LABEL: @test_vla(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VLA:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DATA:%.*]], i64 4
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull [[VLA]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)* nonnull [[VLA]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[VLA]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP0]]
//
void *test_vla(void *data, long index) {
  struct VLA {
    int size;
    char vla[]; // should use the remaining size:
  } *l = data;
  int x = l->vla[index]; // expected-remark{{setting sub-object bounds for field 'vla' (array subscript on 'char[]') to remaining bytes (member is potential variable length array)}}
  return &l->vla;        // expected-remark{{setting sub-object bounds for field 'vla' (pointer to 'char[]') to remaining bytes (member is potential variable length array)}}
}

#ifdef NOTYET
void *test_remaining_size_other_member(void *data, long index) {
  // Would be nice to just load the size member and use that for the bounds
  struct LikeStructDirentRemainingSizeWithMax {
    int size;
    char data[255] __attribute__((cheri_subobject_bounds_use_remaining_size(size)));
  } *l = data;
  int x = l->data[index]; // expected-remark{{sadasfasf}}
  return &l->data;        // expected-remark{{sadasfasf}}
}
#endif
