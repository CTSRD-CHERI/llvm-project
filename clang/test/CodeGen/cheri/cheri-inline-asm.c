// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// REQUIRES: mips-registered-target

// RUN: %cheri_purecap_cc1 -emit-llvm -o - %s | %cheri_FileCheck %s
// RUN: %cheri_purecap_cc1 -S -o - %s -verify | FileCheck %s -check-prefix ASM
// CHECK-LABEL: @f(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) [[P:%.*]], ptr addrspace(200) [[P_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[P_ADDR]], align 16
// CHECK-NEXT:    call void asm sideeffect "# ASM EXPR: $0", "rm,~{memory},~{$1}"(ptr addrspace(200) [[TMP0]]) #[[ATTR1:[0-9]+]], !srcloc !2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[P_ADDR]], align 16
// CHECK-NEXT:    call void asm sideeffect "# ASM EXPR: $0", "r,~{memory},~{$1}"(ptr addrspace(200) [[TMP1]]) #[[ATTR1]], !srcloc !3
// CHECK-NEXT:    call void asm sideeffect "# ASM EXPR: $0", "*m,~{memory},~{$1}"(ptr addrspace(200) elementtype(ptr addrspace(200)) [[P_ADDR]]) #[[ATTR1]], !srcloc !4
// CHECK-NEXT:    ret void
//
void f(char *p) {
  asm volatile("# ASM EXPR: %0" : : "rm"(p) : "memory");
  // mem-expr:
  // ASM: # ASM EXPR: {{[0-9]+}}($c{{[0-9]+}})
  asm volatile("# ASM EXPR: %0" : : "r"(p) : "memory");
  // capabitliy register:
  // ASM: # ASM EXPR: $c{{[0-9]+}}
  asm volatile("# ASM EXPR: %0" : : "m"(p) : "memory");
  // mem-expr:
  // ASM: # ASM EXPR: {{[0-9]+}}($c{{[0-9]+}})
}


// CHECK-LABEL: @f2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = alloca i8, align 1, addrspace(200)
// CHECK-NEXT:    store i8 0, ptr addrspace(200) [[B]], align 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr addrspace(200) [[B]], align 1
// CHECK-NEXT:    [[TOBOOL:%.*]] = trunc i8 [[TMP0]] to i1
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 asm sideeffect "", "=C,0,~{$1}"(i1 [[TOBOOL]]) #[[ATTR1]], !srcloc !5
// CHECK-NEXT:    store i8 [[TMP1]], ptr addrspace(200) [[B]], align 1
// CHECK-NEXT:    [[TMP2:%.*]] = load i8, ptr addrspace(200) [[B]], align 1
// CHECK-NEXT:    [[TOBOOL1:%.*]] = trunc i8 [[TMP2]] to i1
// CHECK-NEXT:    ret i1 [[TOBOOL1]]
//
_Bool f2(void) {
  _Bool b = 0;
  asm volatile("" : "+C"(b)); // NOTE: this is invalid but is only detected when emitting asm:
  // expected-error@-1{{couldn't allocate output register for constraint 'C'}}
  return b;
}
