// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 -Wno-cheri -disable-O0-optnone -emit-llvm %s -o - \
// RUN:   | opt -S -mem2reg | FileCheck %s

// This would previously crash Clang, as it would erroneously continue walking
// up past the ArraySubscriptExpr and through the MemberExpr, incorrectly
// seeing 's' as the base, of type 'struct S', rather than the correct 's.p' of
// type 'void * __capability'. Sema would therefore think this was valid code,
// giving a 'void *', but during CodeGen it would get a 'void * __capability'
// instead and crash.
// See: https://github.com/CTSRD-CHERI/llvm-project/issues/363

struct S {
  void * __capability p;
};

// CHECK-LABEL: @foo(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 16
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[S]], i32 0, i32 0
// CHECK-NEXT:    store i8 addrspace(200)* [[S_COERCE:%.*]], i8 addrspace(200)** [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds [[STRUCT_S]], %struct.S* [[S]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)** [[P]], align 16
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[TMP0]], i64 0
// CHECK-NEXT:    [[ARRAYIDX_ASCAST:%.*]] = addrspacecast i8 addrspace(200)* [[ARRAYIDX]] to i8*
// CHECK-NEXT:    ret i8* [[ARRAYIDX_ASCAST]]
//
void *foo(struct S s) {
  return (void *)&s.p[0];
}
