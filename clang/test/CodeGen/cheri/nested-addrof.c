// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 -Wno-cheri -disable-O0-optnone -emit-llvm %s -o - \
// RUN:   | opt -S -passes=mem2reg | FileCheck %s
// RUN: %cheri_cc1 -Wno-cheri -disable-O0-optnone -emit-llvm -x c++ %s -o - \
// RUN:   | opt -S -passes=mem2reg | FileCheck %s

// This would previously crash Clang, as it would erroneously continue walking
// up past the ArraySubscriptExpr and through the MemberExpr, incorrectly
// seeing 's' as the base, of type 'struct S', rather than the correct 's.p' of
// type 'char * __capability'. Sema would therefore think this was valid code,
// giving a 'char *', but during CodeGen it would get a 'char * __capability'
// instead and crash.
// See: https://github.com/CTSRD-CHERI/llvm-project/issues/363

#ifdef __cplusplus
extern "C" {
#endif

struct S {
  char * __capability p;
};

// CHECK-LABEL: @sub(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[STRUCT_S:%.*]], align 16
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S]], i32 0, i32 0
// CHECK-NEXT:    store ptr addrspace(200) [[S_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[P:%.*]] = getelementptr inbounds [[STRUCT_S]], ptr [[S]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr [[P]], align 16
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[TMP0]], i64 0
// CHECK-NEXT:    [[ARRAYIDX_ASCAST:%.*]] = addrspacecast ptr addrspace(200) [[ARRAYIDX]] to ptr
// CHECK-NEXT:    ret ptr [[ARRAYIDX_ASCAST]]
//
char *sub(struct S s) {
  return (char *)&s.p[0];
}

#ifdef __cplusplus
}; // extern "C"
#endif
