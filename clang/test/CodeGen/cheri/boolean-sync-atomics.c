// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 -emit-llvm -o - -O0 %s | FileCheck %s -check-prefix N64
// RUN: %cheri_purecap_cc1 -emit-llvm -o - -O0 %s | FileCheck %s -check-prefix PURECAP
typedef struct {
  _Bool volatile repr;
} atomic_b_t;

atomic_b_t value;
// N64-LABEL: @atomic_compare_exchange_weak_b(
// N64-NEXT:  entry:
// N64-NEXT:    [[EXPECTED_ADDR:%.*]] = alloca i8, align 1
// N64-NEXT:    [[DESIRED_ADDR:%.*]] = alloca i8, align 1
// N64-NEXT:    [[FROMBOOL:%.*]] = zext i1 [[EXPECTED:%.*]] to i8
// N64-NEXT:    store i8 [[FROMBOOL]], i8* [[EXPECTED_ADDR]], align 1
// N64-NEXT:    [[FROMBOOL1:%.*]] = zext i1 [[DESIRED:%.*]] to i8
// N64-NEXT:    store i8 [[FROMBOOL1]], i8* [[DESIRED_ADDR]], align 1
// N64-NEXT:    [[TMP0:%.*]] = load i8, i8* [[EXPECTED_ADDR]], align 1
// N64-NEXT:    [[TOBOOL:%.*]] = trunc i8 [[TMP0]] to i1
// N64-NEXT:    [[TMP1:%.*]] = load i8, i8* [[DESIRED_ADDR]], align 1
// N64-NEXT:    [[TOBOOL2:%.*]] = trunc i8 [[TMP1]] to i1
// N64-NEXT:    [[FROMBOOL3:%.*]] = zext i1 [[TOBOOL]] to i8
// N64-NEXT:    [[FROMBOOL4:%.*]] = zext i1 [[TOBOOL2]] to i8
// N64-NEXT:    [[TMP2:%.*]] = cmpxchg i8* getelementptr inbounds ([[STRUCT_ATOMIC_B_T:%.*]], %struct.atomic_b_t* @value, i32 0, i32 0), i8 [[FROMBOOL3]], i8 [[FROMBOOL4]] seq_cst seq_cst, align 1
// N64-NEXT:    [[TMP3:%.*]] = extractvalue { i8, i1 } [[TMP2]], 0
// N64-NEXT:    [[TOBOOL5:%.*]] = trunc i8 [[TMP3]] to i1
// N64-NEXT:    ret i1 [[TOBOOL5]]
//
// PURECAP-LABEL: @atomic_compare_exchange_weak_b(
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[EXPECTED_ADDR:%.*]] = alloca i8, align 1, addrspace(200)
// PURECAP-NEXT:    [[DESIRED_ADDR:%.*]] = alloca i8, align 1, addrspace(200)
// PURECAP-NEXT:    [[FROMBOOL:%.*]] = zext i1 [[EXPECTED:%.*]] to i8
// PURECAP-NEXT:    store i8 [[FROMBOOL]], i8 addrspace(200)* [[EXPECTED_ADDR]], align 1
// PURECAP-NEXT:    [[FROMBOOL1:%.*]] = zext i1 [[DESIRED:%.*]] to i8
// PURECAP-NEXT:    store i8 [[FROMBOOL1]], i8 addrspace(200)* [[DESIRED_ADDR]], align 1
// PURECAP-NEXT:    [[TMP0:%.*]] = load i8, i8 addrspace(200)* [[EXPECTED_ADDR]], align 1
// PURECAP-NEXT:    [[TOBOOL:%.*]] = trunc i8 [[TMP0]] to i1
// PURECAP-NEXT:    [[TMP1:%.*]] = load i8, i8 addrspace(200)* [[DESIRED_ADDR]], align 1
// PURECAP-NEXT:    [[TOBOOL2:%.*]] = trunc i8 [[TMP1]] to i1
// PURECAP-NEXT:    [[FROMBOOL3:%.*]] = zext i1 [[TOBOOL]] to i8
// PURECAP-NEXT:    [[FROMBOOL4:%.*]] = zext i1 [[TOBOOL2]] to i8
// PURECAP-NEXT:    [[TMP2:%.*]] = cmpxchg i8 addrspace(200)* getelementptr inbounds ([[STRUCT_ATOMIC_B_T:%.*]], [[STRUCT_ATOMIC_B_T]] addrspace(200)* @value, i32 0, i32 0), i8 [[FROMBOOL3]], i8 [[FROMBOOL4]] seq_cst seq_cst, align 1
// PURECAP-NEXT:    [[TMP3:%.*]] = extractvalue { i8, i1 } [[TMP2]], 0
// PURECAP-NEXT:    [[TOBOOL5:%.*]] = trunc i8 [[TMP3]] to i1
// PURECAP-NEXT:    ret i1 [[TOBOOL5]]
//
_Bool atomic_compare_exchange_weak_b(_Bool expected, _Bool desired) {
  return __sync_val_compare_and_swap(&value.repr, expected, desired);
}

// N64-LABEL: @atomic_swap_b(
// N64-NEXT:  entry:
// N64-NEXT:    [[DESIRED_ADDR:%.*]] = alloca i8, align 1
// N64-NEXT:    [[FROMBOOL:%.*]] = zext i1 [[DESIRED:%.*]] to i8
// N64-NEXT:    store i8 [[FROMBOOL]], i8* [[DESIRED_ADDR]], align 1
// N64-NEXT:    [[TMP0:%.*]] = load i8, i8* [[DESIRED_ADDR]], align 1
// N64-NEXT:    [[TOBOOL:%.*]] = trunc i8 [[TMP0]] to i1
// N64-NEXT:    [[FROMBOOL1:%.*]] = zext i1 [[TOBOOL]] to i8
// N64-NEXT:    [[TMP1:%.*]] = atomicrmw xchg i8* getelementptr inbounds ([[STRUCT_ATOMIC_B_T:%.*]], %struct.atomic_b_t* @value, i32 0, i32 0), i8 [[FROMBOOL1]] seq_cst, align 1
// N64-NEXT:    [[TOBOOL2:%.*]] = trunc i8 [[TMP1]] to i1
// N64-NEXT:    ret i1 [[TOBOOL2]]
//
// PURECAP-LABEL: @atomic_swap_b(
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[DESIRED_ADDR:%.*]] = alloca i8, align 1, addrspace(200)
// PURECAP-NEXT:    [[FROMBOOL:%.*]] = zext i1 [[DESIRED:%.*]] to i8
// PURECAP-NEXT:    store i8 [[FROMBOOL]], i8 addrspace(200)* [[DESIRED_ADDR]], align 1
// PURECAP-NEXT:    [[TMP0:%.*]] = load i8, i8 addrspace(200)* [[DESIRED_ADDR]], align 1
// PURECAP-NEXT:    [[TOBOOL:%.*]] = trunc i8 [[TMP0]] to i1
// PURECAP-NEXT:    [[FROMBOOL1:%.*]] = zext i1 [[TOBOOL]] to i8
// PURECAP-NEXT:    [[TMP1:%.*]] = atomicrmw xchg i8 addrspace(200)* getelementptr inbounds ([[STRUCT_ATOMIC_B_T:%.*]], [[STRUCT_ATOMIC_B_T]] addrspace(200)* @value, i32 0, i32 0), i8 [[FROMBOOL1]] seq_cst, align 1
// PURECAP-NEXT:    [[TOBOOL2:%.*]] = trunc i8 [[TMP1]] to i1
// PURECAP-NEXT:    ret i1 [[TOBOOL2]]
//
_Bool atomic_swap_b(_Bool desired) {
  return __sync_swap(&value.repr, desired);
}
