// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -emit-llvm -o - -verify %s | %cheri_FileCheck %s
// Test that IR generation is correct for __cheri_offset and __cheri_addr

// CHECK-LABEL: @check_offset(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[C_ADDR:%.*]] = alloca i8 addrspace(200)*, align [[#CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[X1:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    [[X2:%.*]] = alloca i16, align 2, addrspace(200)
// CHECK-NEXT:    [[X3:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    store i8 addrspace(200)* [[C:%.*]], i8 addrspace(200)* addrspace(200)* [[C_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[C_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    store i64 [[TMP1]], i64 addrspace(200)* [[X1]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[C_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP3:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[TMP2]])
// CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[TMP3]] to i16
// CHECK-NEXT:    store i16 [[CONV]], i16 addrspace(200)* [[X2]], align 2
// CHECK-NEXT:    [[TMP4:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[C_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP5:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[TMP4]])
// CHECK-NEXT:    [[CONV1:%.*]] = trunc i64 [[TMP5]] to i16
// CHECK-NEXT:    [[CONV2:%.*]] = sext i16 [[CONV1]] to i64
// CHECK-NEXT:    store i64 [[CONV2]], i64 addrspace(200)* [[X3]], align 8
// CHECK-NEXT:    ret void
//
void check_offset(char *c) {
  long x1 = (__cheri_offset long)c;
  short x2 = (__cheri_offset short)c; // expected-warning {{target type 'short' is smaller than the type 'long int' of the capability offset field; truncation may occur}}
  long x3 = (__cheri_offset short)c; // expected-warning {{target type 'short' is smaller than the type 'long int' of the capability offset field; truncation may occur}}
}

// CHECK-LABEL: @check_addr(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[C_ADDR:%.*]] = alloca i8 addrspace(200)*, align [[#CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    [[X1:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    [[X2:%.*]] = alloca i16, align 2, addrspace(200)
// CHECK-NEXT:    [[X3:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    store i8 addrspace(200)* [[C:%.*]], i8 addrspace(200)* addrspace(200)* [[C_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[C_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    store i64 [[TMP1]], i64 addrspace(200)* [[X1]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[C_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP3:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP2]])
// CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[TMP3]] to i16
// CHECK-NEXT:    store i16 [[CONV]], i16 addrspace(200)* [[X2]], align 2
// CHECK-NEXT:    [[TMP4:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[C_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP5:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP4]])
// CHECK-NEXT:    [[CONV1:%.*]] = trunc i64 [[TMP5]] to i16
// CHECK-NEXT:    [[CONV2:%.*]] = sext i16 [[CONV1]] to i64
// CHECK-NEXT:    store i64 [[CONV2]], i64 addrspace(200)* [[X3]], align 8
// CHECK-NEXT:    ret void
//
void check_addr(char *c) {
  long x1 = (__cheri_addr long)c;
  short x2 = (__cheri_addr short)c; // expected-warning {{target type 'short' is smaller than the type 'long int' of the address; truncation may occur}}
  long x3 = (__cheri_addr short)c; // expected-warning {{target type 'short' is smaller than the type 'long int' of the address; truncation may occur}}
}

// Using (u)intcap_t as the source previously crashed
typedef int b;
// CHECK-LABEL: @libunwind_crash(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CAP_ADDR:%.*]] = alloca i8 addrspace(200)*, align [[#CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    store i8 addrspace(200)* [[CAP:%.*]], i8 addrspace(200)* addrspace(200)* [[CAP_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[CAP_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[TMP1]] to i32
// CHECK-NEXT:    ret i32 [[CONV]]
//
b libunwind_crash(__uintcap_t cap) {
  return (__cheri_addr b)cap; // expected-warning {{target type 'b' (aka 'int') is smaller than the type 'long int' of the address; truncation may occur}}
}

// CHECK-LABEL: @libunwind_crash2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CAP_ADDR:%.*]] = alloca i8 addrspace(200)*, align [[#CAP_SIZE]], addrspace(200)
// CHECK-NEXT:    store i8 addrspace(200)* [[CAP:%.*]], i8 addrspace(200)* addrspace(200)* [[CAP_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP0:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[CAP_ADDR]], align [[#CAP_SIZE]]
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[TMP1]] to i32
// CHECK-NEXT:    ret i32 [[CONV]]
//
b libunwind_crash2(__intcap_t cap) {
  return (__cheri_offset b)cap; // expected-warning {{target type 'b' (aka 'int') is smaller than the type 'long int' of the capability offset field; truncation may occur}}
}
