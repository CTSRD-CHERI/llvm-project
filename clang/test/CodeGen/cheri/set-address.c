// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// REQUIRES: mips-registered-target

// RUN: %cheri_cc1 %s -o - -emit-llvm | %cheri_FileCheck %s -check-prefix=HYBRID
// RUN: %cheri_purecap_cc1 %s -o - -emit-llvm | %cheri_FileCheck %s -check-prefix=PURECAP

typedef __SIZE_TYPE__ ptraddr_t;
// The existing inline function macro from cheric.h
static __attribute__((always_inline)) inline void *__capability
cheri_setaddress(const void *__capability dst, ptraddr_t addr) {
  return (__builtin_cheri_offset_increment(dst, addr - __builtin_cheri_address_get(dst)));
}

// HYBRID-LABEL: define {{[^@]+}}@use_sys_cheric_function
// HYBRID-SAME: (ptr addrspace(200) noundef [[IN:%.*]], i64 noundef zeroext [[NEW_ADDR:%.*]]) #[[ATTR0:[0-9]+]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[DST_ADDR_I:%.*]] = alloca ptr addrspace(200), align 16
// HYBRID-NEXT:    [[ADDR_ADDR_I:%.*]] = alloca i64, align 8
// HYBRID-NEXT:    [[IN_ADDR:%.*]] = alloca ptr addrspace(200), align 16
// HYBRID-NEXT:    [[NEW_ADDR_ADDR:%.*]] = alloca i64, align 8
// HYBRID-NEXT:    store ptr addrspace(200) [[IN]], ptr [[IN_ADDR]], align 16
// HYBRID-NEXT:    store i64 [[NEW_ADDR]], ptr [[NEW_ADDR_ADDR]], align 8
// HYBRID-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr [[IN_ADDR]], align 16
// HYBRID-NEXT:    [[TMP1:%.*]] = load i64, ptr [[NEW_ADDR_ADDR]], align 8
// HYBRID-NEXT:    store ptr addrspace(200) [[TMP0]], ptr [[DST_ADDR_I]], align 16
// HYBRID-NEXT:    store i64 [[TMP1]], ptr [[ADDR_ADDR_I]], align 8
// HYBRID-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr [[DST_ADDR_I]], align 16
// HYBRID-NEXT:    [[TMP3:%.*]] = load i64, ptr [[ADDR_ADDR_I]], align 8
// HYBRID-NEXT:    [[TMP4:%.*]] = load ptr addrspace(200), ptr [[DST_ADDR_I]], align 16
// HYBRID-NEXT:    [[TMP5:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP4]])
// HYBRID-NEXT:    [[SUB_I:%.*]] = sub i64 [[TMP3]], [[TMP5]]
// HYBRID-NEXT:    [[__BUILTIN_CHERI_OFFSET_INCREMENT_I:%.*]] = getelementptr i8, ptr addrspace(200) [[TMP2]], i64 [[SUB_I]]
// HYBRID-NEXT:    ret ptr addrspace(200) [[__BUILTIN_CHERI_OFFSET_INCREMENT_I]]
//
// PURECAP-LABEL: define {{[^@]+}}@use_sys_cheric_function
// PURECAP-SAME: (ptr addrspace(200) noundef [[IN:%.*]], i64 noundef zeroext [[NEW_ADDR:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[DST_ADDR_I:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// PURECAP-NEXT:    [[ADDR_ADDR_I:%.*]] = alloca i64, align 8, addrspace(200)
// PURECAP-NEXT:    [[IN_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// PURECAP-NEXT:    [[NEW_ADDR_ADDR:%.*]] = alloca i64, align 8, addrspace(200)
// PURECAP-NEXT:    store ptr addrspace(200) [[IN]], ptr addrspace(200) [[IN_ADDR]], align 16
// PURECAP-NEXT:    store i64 [[NEW_ADDR]], ptr addrspace(200) [[NEW_ADDR_ADDR]], align 8
// PURECAP-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[IN_ADDR]], align 16
// PURECAP-NEXT:    [[TMP1:%.*]] = load i64, ptr addrspace(200) [[NEW_ADDR_ADDR]], align 8
// PURECAP-NEXT:    store ptr addrspace(200) [[TMP0]], ptr addrspace(200) [[DST_ADDR_I]], align 16
// PURECAP-NEXT:    store i64 [[TMP1]], ptr addrspace(200) [[ADDR_ADDR_I]], align 8
// PURECAP-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[DST_ADDR_I]], align 16
// PURECAP-NEXT:    [[TMP3:%.*]] = load i64, ptr addrspace(200) [[ADDR_ADDR_I]], align 8
// PURECAP-NEXT:    [[TMP4:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[DST_ADDR_I]], align 16
// PURECAP-NEXT:    [[TMP5:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP4]])
// PURECAP-NEXT:    [[SUB_I:%.*]] = sub i64 [[TMP3]], [[TMP5]]
// PURECAP-NEXT:    [[__BUILTIN_CHERI_OFFSET_INCREMENT_I:%.*]] = getelementptr i8, ptr addrspace(200) [[TMP2]], i64 [[SUB_I]]
// PURECAP-NEXT:    ret ptr addrspace(200) [[__BUILTIN_CHERI_OFFSET_INCREMENT_I]]
//
void *__capability use_sys_cheric_function(void *__capability in, ptraddr_t new_addr) {
  return cheri_setaddress(in, new_addr);
  // ASM-LABEL: .ent use_sys_cheric_function
  // ASM: csetaddr $c3, $c3, $4
  // ASM: .end use_sys_cheric_function
}

// HYBRID-LABEL: define {{[^@]+}}@use_builtin_function
// HYBRID-SAME: (ptr addrspace(200) noundef [[IN:%.*]], i64 noundef zeroext [[NEW_ADDR:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[IN_ADDR:%.*]] = alloca ptr addrspace(200), align 16
// HYBRID-NEXT:    [[NEW_ADDR_ADDR:%.*]] = alloca i64, align 8
// HYBRID-NEXT:    store ptr addrspace(200) [[IN]], ptr [[IN_ADDR]], align 16
// HYBRID-NEXT:    store i64 [[NEW_ADDR]], ptr [[NEW_ADDR_ADDR]], align 8
// HYBRID-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr [[IN_ADDR]], align 16
// HYBRID-NEXT:    [[TMP1:%.*]] = load i64, ptr [[NEW_ADDR_ADDR]], align 8
// HYBRID-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[TMP0]], i64 [[TMP1]])
// HYBRID-NEXT:    ret ptr addrspace(200) [[TMP2]]
//
// PURECAP-LABEL: define {{[^@]+}}@use_builtin_function
// PURECAP-SAME: (ptr addrspace(200) noundef [[IN:%.*]], i64 noundef zeroext [[NEW_ADDR:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[IN_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// PURECAP-NEXT:    [[NEW_ADDR_ADDR:%.*]] = alloca i64, align 8, addrspace(200)
// PURECAP-NEXT:    store ptr addrspace(200) [[IN]], ptr addrspace(200) [[IN_ADDR]], align 16
// PURECAP-NEXT:    store i64 [[NEW_ADDR]], ptr addrspace(200) [[NEW_ADDR_ADDR]], align 8
// PURECAP-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[IN_ADDR]], align 16
// PURECAP-NEXT:    [[TMP1:%.*]] = load i64, ptr addrspace(200) [[NEW_ADDR_ADDR]], align 8
// PURECAP-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[TMP0]], i64 [[TMP1]])
// PURECAP-NEXT:    ret ptr addrspace(200) [[TMP2]]
//
void *__capability use_builtin_function(void *__capability in, ptraddr_t new_addr) {
  return __builtin_cheri_address_set(in, new_addr);
  // ASM-LABEL: .ent use_builtin_function
  // ASM: csetaddr $c3, $c3, $4
  // ASM: .end use_builtin_function
}

// HYBRID-LABEL: define {{[^@]+}}@use_asm
// HYBRID-SAME: (ptr addrspace(200) noundef [[IN:%.*]], i64 noundef zeroext [[NEW_ADDR:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[IN_ADDR:%.*]] = alloca ptr addrspace(200), align 16
// HYBRID-NEXT:    [[NEW_ADDR_ADDR:%.*]] = alloca i64, align 8
// HYBRID-NEXT:    [[RESULT:%.*]] = alloca ptr addrspace(200), align 16
// HYBRID-NEXT:    store ptr addrspace(200) [[IN]], ptr [[IN_ADDR]], align 16
// HYBRID-NEXT:    store i64 [[NEW_ADDR]], ptr [[NEW_ADDR_ADDR]], align 8
// HYBRID-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr [[IN_ADDR]], align 16
// HYBRID-NEXT:    [[TMP1:%.*]] = load i64, ptr [[NEW_ADDR_ADDR]], align 8
// HYBRID-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) asm "csetaddr $0, $1, $2\0A\09", "=C,C,r,~{$1}"(ptr addrspace(200) [[TMP0]], i64 [[TMP1]]) #[[ATTR2:[0-9]+]], !srcloc !2
// HYBRID-NEXT:    store ptr addrspace(200) [[TMP2]], ptr [[RESULT]], align 16
// HYBRID-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr [[RESULT]], align 16
// HYBRID-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
// PURECAP-LABEL: define {{[^@]+}}@use_asm
// PURECAP-SAME: (ptr addrspace(200) noundef [[IN:%.*]], i64 noundef zeroext [[NEW_ADDR:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[IN_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// PURECAP-NEXT:    [[NEW_ADDR_ADDR:%.*]] = alloca i64, align 8, addrspace(200)
// PURECAP-NEXT:    [[RESULT:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// PURECAP-NEXT:    store ptr addrspace(200) [[IN]], ptr addrspace(200) [[IN_ADDR]], align 16
// PURECAP-NEXT:    store i64 [[NEW_ADDR]], ptr addrspace(200) [[NEW_ADDR_ADDR]], align 8
// PURECAP-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[IN_ADDR]], align 16
// PURECAP-NEXT:    [[TMP1:%.*]] = load i64, ptr addrspace(200) [[NEW_ADDR_ADDR]], align 8
// PURECAP-NEXT:    [[TMP2:%.*]] = call ptr addrspace(200) asm "csetaddr $0, $1, $2\0A\09", "=C,C,r,~{$1}"(ptr addrspace(200) [[TMP0]], i64 [[TMP1]]) #[[ATTR2:[0-9]+]], !srcloc !2
// PURECAP-NEXT:    store ptr addrspace(200) [[TMP2]], ptr addrspace(200) [[RESULT]], align 16
// PURECAP-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[RESULT]], align 16
// PURECAP-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
void *__capability use_asm(void *__capability in, ptraddr_t new_addr) {
  void *__capability result;
  __asm__ ("csetaddr %0, %1, %2\n\t" :"=C"(result) : "C"(in), "r"(new_addr));
  return result;
  // ASM-LABEL: .ent use_asm
  // ASM: csetaddr $c3, $c3, $4
  // ASM: .end use_asm
}
