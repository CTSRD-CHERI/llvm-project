// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
/// Check that we can inline memcpy() calls for small structures that are known
/// not to contain capabilities. Previously we assumed that all copies >= sizeof(capability)
/// can contain capabilities and we therefore fell back to calling memcpy if the
/// alignment was less than >= alignof(capability).
/// TODO: include some end-to-end testing to ensure that the frontend and backend changes allow
///  eliding the memcpy() call that we were previously force to make?
// RUN: %riscv64_cheri_purecap_cc1 %s -emit-llvm -o - -O0 | FileCheck %s

#if __has_feature(capabilities)
#define CAP_SIZE sizeof(void *__capability)
#else
#define CAP_SIZE (2 * sizeof(long))
#endif

void *memcpy(void *, const void *, unsigned long);

// Test case from lib/libc/sys/__vdso_gettimeofday.c binuptime
struct bintime {
  long sec;
  long frac;
};
struct vdso_timehands {
  /* some more fields */
  struct bintime th_offset;
  struct bintime th_boottime;
};

void test_binuptime_assign(struct bintime *bt, struct vdso_timehands *th) {
  *bt = th->th_offset;
  // CHECK-LABEL: void @test_binuptime_assign(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 8 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 8 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 16, i1 false){{$}}
  // FIXME-SAME: i64 16, i1 false) [[NO_PRESERVE_TAGS_ATTR:#[0-9]+]]{{$}}
}

struct cap_size_buffer {
  int data[CAP_SIZE / sizeof(int)];
};

void test_cap_size_buffer_copy(struct cap_size_buffer *a, struct cap_size_buffer *b) {
  *a = *b;
  // CHECK-LABEL: void @test_cap_size_buffer_copy(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 4 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 4 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 16, i1 false){{$}}
  // FIXME-SAME: i64 16, i1 false) [[NO_PRESERVE_TAGS_ATTR]]{{$}}
}

union large_union_align_half_cap_size {
  struct cap_size_buffer data;
  int i;
  float f;
  long l;
  char bigdata[4 * CAP_SIZE];
};

void test_bigger_union_copy(union large_union_align_half_cap_size *a, union large_union_align_half_cap_size *b) {
  // No tags in this union -> can inline the memcpy()
  *a = *b;
  // CHECK-LABEL: void @test_bigger_union_copy(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 8 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 8 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 64, i1 false){{$}}
  // FIXME-SAME: i64 64, i1 false) [[NO_PRESERVE_TAGS_ATTR]]{{$}}
}

void test_align_copy_voidptr(void *a, void *b) {
  // void* could contain caps but we don't add the attribute and rely on the backend to decide
  memcpy(a, b, CAP_SIZE);
  // CHECK-LABEL: void @test_align_copy_voidptr(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 1 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 1 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 16, i1 false){{$}}
}

void test_align_copy_charptr(char *a, char *b) {
  // char* could contain caps since it's (unfortunately) basically the same as void*,
  // but again we don't add the attribute and rely on the backend to decide
  memcpy(a, b, CAP_SIZE);
  // CHECK-LABEL: void @test_align_copy_charptr(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 1 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 1 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 16, i1 false){{$}}
}

void test_align_copy_longptr(long *a, long *b) {
  // Note: here we don't infer the no-preserve tags (yet)
  memcpy(a, b, CAP_SIZE);
  // CHECK-LABEL: void @test_align_copy_longptr(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 8 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 8 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 16, i1 false){{$}}
  // FIXME-SAME: [[NO_PRESERVE_TAGS_ATTR]]{{$}}
}

#if __has_feature(capabilities)
void test_align_copy_capptr(unsigned __intcap *a, unsigned __intcap *b) {
  memcpy(a, b, CAP_SIZE);
  // CHECK-LABEL: void @test_align_copy_capptr(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 16 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 16, i1 false) [[MUST_PRESERVE_TAGS_ATTR:#[0-9]+]]{{$}}
}
#endif

struct fwddecl;

void test_align_copy_fwd_declared(struct fwddecl *a, struct fwddecl *b) {
  // We don't know if src contains capabilities -> don't add the attribute no-preserve
  // attribute but also don't add the must-preserve attribute and let the backend decide
  memcpy(a, b, CAP_SIZE);
  // CHECK-LABEL: void @test_align_copy_fwd_declared(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 1 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 1 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 16, i1 false){{$}}
}

void test_align_copy_fwd_declared_2(void *a, struct fwddecl *b) {
  // We don't know if src contains capabilities -> don't add the attribute no-preserve
  // attribute but also don't add the must-preserve attribute and let the backend decide
  memcpy(a, b, CAP_SIZE);
  // CHECK-LABEL: void @test_align_copy_fwd_declared_2(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 1 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 1 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 16, i1 false){{$}}
}

void test_align_copy_fwd_declared_dst_notag(long *a, struct fwddecl *b) {
  // We don't know if src contains capabilities, but the destination can't contain tags
  // CHECK-LABEL: void @test_align_copy_fwd_declared_dst_notag(
  // CHECK: call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 8 {{%[0-9a-zA-Z.]+}}, i8 addrspace(200)* align 1 {{%[0-9a-zA-Z.]+}},
  // CHECK-SAME: i64 16, i1 false){{$}}
  memcpy(a, b, CAP_SIZE);
}

// CHECK: attributes #0 = {
// FIXME-DAG: attributes [[NO_PRESERVE_TAGS_ATTR]] = { no_preserve_cheri_tags }
// CHECK-DAG: attributes [[MUST_PRESERVE_TAGS_ATTR]] = { must_preserve_cheri_tags "frontend-memtransfer-type"="'unsigned __intcap'" }
