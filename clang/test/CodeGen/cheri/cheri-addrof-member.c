// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %cheri_cc1 -disable-O0-optnone -emit-llvm %s -o - \
// RUN:   | opt -S -mem2reg | FileCheck %s

struct S {
  char buf[1];
  char c;
};

// CHECK-LABEL: define {{[^@]+}}@struct_member
// CHECK-SAME: ([[STRUCT_S:%.*]] addrspace(200)* noundef [[S:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[C:%.*]] = getelementptr inbounds [[STRUCT_S]], [[STRUCT_S]] addrspace(200)* [[S]], i32 0, i32 1
// CHECK-NEXT:    ret i8 addrspace(200)* [[C]]
//
char * __capability struct_member(struct S * __capability s) {
  return &s->c;
}

// CHECK-LABEL: define {{[^@]+}}@array_member
// CHECK-SAME: (i8 addrspace(200)* noundef [[P:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[P]], i64 42
// CHECK-NEXT:    ret i8 addrspace(200)* [[ARRAYIDX]]
//
char * __capability array_member(char * __capability p) {
  return &p[42];
}

// This started crashing in CodeGen after recursively resolving memberexprs.
// Check that we don't create a capability.
// CHECK-LABEL: define {{[^@]+}}@typeof_arg
// CHECK-SAME: (i8 addrspace(200)* noundef [[P:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[P_ADDR:%.*]] = alloca i8 addrspace(200)*, align 16
// CHECK-NEXT:    store i8 addrspace(200)* [[P]], i8 addrspace(200)** [[P_ADDR]], align 16
// CHECK-NEXT:    call void @foo(i8 addrspace(200)** noundef [[P_ADDR]])
// CHECK-NEXT:    ret void
//
void typeof_arg(void * __capability p) {
  extern void foo(void * __capability *);
  typeof(&p) q = &p;
  foo(q);
}

// Previously this would crash without the __cheri_fromcap and give an error
// with it since Sema incorrectly determined the address to be a pointer not a
// capability, as it peeked through the ArrayToPointerDecay and saw the type as
// `char [1]`, which is not a capability.
// CHECK-LABEL: define {{[^@]+}}@fromcap_member
// CHECK-SAME: ([[STRUCT_S:%.*]] addrspace(200)* noundef [[S:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUF:%.*]] = getelementptr inbounds [[STRUCT_S]], [[STRUCT_S]] addrspace(200)* [[S]], i32 0, i32 0
// CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [1 x i8], [1 x i8] addrspace(200)* [[BUF]], i64 0, i64 0
// CHECK-NEXT:    [[ARRAYIDX_ASCAST:%.*]] = addrspacecast i8 addrspace(200)* [[ARRAYIDX]] to i8*
// CHECK-NEXT:    ret i8* [[ARRAYIDX_ASCAST]]
//
char *fromcap_member(struct S * __capability s) {
  return (__cheri_fromcap char *)&s->buf[0];
}
