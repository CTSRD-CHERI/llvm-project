// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN:  %cheri_purecap_cc1 -o - -O0 -emit-llvm %s | FileCheck %s
// RUN:  %cheri_purecap_cc1 -o - -O2 -emit-llvm %s | FileCheck %s --check-prefix=OPT

// CHECK-LABEL: define {{[^@]+}}@test_long
// CHECK-SAME: () addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca double, align 8, addrspace(200)
// CHECK-NEXT:    [[L:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    [[D2:%.*]] = alloca double, align 8, addrspace(200)
// CHECK-NEXT:    store double 0x40934A456D5CFAAD, double addrspace(200)* [[D]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double, double addrspace(200)* [[D]], align 8
// CHECK-NEXT:    [[CONV:%.*]] = fptosi double [[TMP0]] to i64
// CHECK-NEXT:    store i64 [[CONV]], i64 addrspace(200)* [[L]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i64, i64 addrspace(200)* [[L]], align 8
// CHECK-NEXT:    [[CONV1:%.*]] = sitofp i64 [[TMP1]] to double
// CHECK-NEXT:    store double [[CONV1]], double addrspace(200)* [[D2]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load double, double addrspace(200)* [[D2]], align 8
// CHECK-NEXT:    ret double [[TMP2]]
//
// OPT-LABEL: define {{[^@]+}}@test_long
// OPT-SAME: () local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
// OPT-NEXT:  entry:
// OPT-NEXT:    ret double 1.234000e+03
//
double test_long(void) {
  double d = 1234.5678;
  long l = d;
  double d2 = l;
  return d2;

}

// CHECK-LABEL: define {{[^@]+}}@test_intcap
// CHECK-SAME: () addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca double, align 8, addrspace(200)
// CHECK-NEXT:    [[CAP:%.*]] = alloca i8 addrspace(200)*, align 16, addrspace(200)
// CHECK-NEXT:    [[D2:%.*]] = alloca double, align 8, addrspace(200)
// CHECK-NEXT:    store double 0x40934A456D5CFAAD, double addrspace(200)* [[D]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double, double addrspace(200)* [[D]], align 8
// CHECK-NEXT:    [[CONV:%.*]] = fptosi double [[TMP0]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[CONV]]
// CHECK-NEXT:    store i8 addrspace(200)* [[TMP1]], i8 addrspace(200)* addrspace(200)* [[CAP]], align 16
// CHECK-NEXT:    [[TMP2:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[CAP]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP2]])
// CHECK-NEXT:    [[CONV1:%.*]] = sitofp i64 [[TMP3]] to double
// CHECK-NEXT:    store double [[CONV1]], double addrspace(200)* [[D2]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load double, double addrspace(200)* [[D2]], align 8
// CHECK-NEXT:    ret double [[TMP4]]
//
// OPT-LABEL: define {{[^@]+}}@test_intcap
// OPT-SAME: () local_unnamed_addr addrspace(200) #[[ATTR0]] {
// OPT-NEXT:  entry:
// OPT-NEXT:    ret double 1.234000e+03
//
double test_intcap(void) {
  double d = 1234.5678;
  __intcap_t cap = d;
  double d2 = cap;
  return d2;

}

// CHECK-LABEL: define {{[^@]+}}@test_ulong
// CHECK-SAME: () addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca double, align 8, addrspace(200)
// CHECK-NEXT:    [[L:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    [[D2:%.*]] = alloca double, align 8, addrspace(200)
// CHECK-NEXT:    store double 0x40934A456D5CFAAD, double addrspace(200)* [[D]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double, double addrspace(200)* [[D]], align 8
// CHECK-NEXT:    [[CONV:%.*]] = fptoui double [[TMP0]] to i64
// CHECK-NEXT:    store i64 [[CONV]], i64 addrspace(200)* [[L]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load i64, i64 addrspace(200)* [[L]], align 8
// CHECK-NEXT:    [[CONV1:%.*]] = uitofp i64 [[TMP1]] to double
// CHECK-NEXT:    store double [[CONV1]], double addrspace(200)* [[D2]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load double, double addrspace(200)* [[D2]], align 8
// CHECK-NEXT:    ret double [[TMP2]]
//
// OPT-LABEL: define {{[^@]+}}@test_ulong
// OPT-SAME: () local_unnamed_addr addrspace(200) #[[ATTR0]] {
// OPT-NEXT:  entry:
// OPT-NEXT:    ret double 1.234000e+03
//
double test_ulong(void) {
  double d = 1234.5678;
  unsigned long l = d;
  double d2 = l;
  return d2;

}

// CHECK-LABEL: define {{[^@]+}}@test_uintcap
// CHECK-SAME: () addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca double, align 8, addrspace(200)
// CHECK-NEXT:    [[CAP:%.*]] = alloca i8 addrspace(200)*, align 16, addrspace(200)
// CHECK-NEXT:    [[D2:%.*]] = alloca double, align 8, addrspace(200)
// CHECK-NEXT:    store double 0x40934A456D5CFAAD, double addrspace(200)* [[D]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load double, double addrspace(200)* [[D]], align 8
// CHECK-NEXT:    [[CONV:%.*]] = fptoui double [[TMP0]] to i64
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[CONV]]
// CHECK-NEXT:    store i8 addrspace(200)* [[TMP1]], i8 addrspace(200)* addrspace(200)* [[CAP]], align 16
// CHECK-NEXT:    [[TMP2:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[CAP]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP2]])
// CHECK-NEXT:    [[CONV1:%.*]] = uitofp i64 [[TMP3]] to double
// CHECK-NEXT:    store double [[CONV1]], double addrspace(200)* [[D2]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = load double, double addrspace(200)* [[D2]], align 8
// CHECK-NEXT:    ret double [[TMP4]]
//
// OPT-LABEL: define {{[^@]+}}@test_uintcap
// OPT-SAME: () local_unnamed_addr addrspace(200) #[[ATTR0]] {
// OPT-NEXT:  entry:
// OPT-NEXT:    ret double 1.234000e+03
//
double test_uintcap(void) {
  double d = 1234.5678;
  __uintcap_t cap = d;
  double d2 = cap;
  return d2;

}

// original minimized test case:
#if 0
typedef __intcap_t __intptr_t;
struct kevent {
  __intptr_t data;
};
int getopt(int, char *[], const char *);

struct {
  double pa_duration;
} args;
struct kevent main_kev;

int main(int argc, char **argv) {
  if (getopt(argc, argv, "CDEFGMNOPRSTWacdefgklmnopqrstvwz")) {
    struct kevent *kevp = &main_kev;
    kevp->data = args.pa_duration;
  }
  return 0;
}
#endif
