// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// We pipe through opt -mem2reg to make the test checks shorter (but keep -O0 to avoid seeing any instcombine folds)
// RUN: %cheri_cc1 -Wno-error=cheri-capability-misuse -verify -emit-llvm -o - -disable-O0-optnone %s | opt -S -mem2reg -o - | FileCheck %s --check-prefix=CHECK
// RUN: %cheri_cc1 -Wno-cheri-capability-misuse -ast-dump %s | FileCheck %s --check-prefix=AST
// RUN: %cheri_purecap_cc1 -Wno-cheri-capability-misuse -verify=purecap -emit-llvm -o - -disable-O0-optnone %s | opt -S -mem2reg -o - | FileCheck %s --check-prefix=PURECAP
// purecap-no-diagnostics
// TODO: could split this into a Sema+CodeGen test, but having both here is easier

/// char* __capability -> non-cap
// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_long
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.to.pointer.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP1]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_capptr_to_long
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    ret i64 [[TMP0]]
//
long test_capptr_to_long(char *__capability cap) {
  return (long)cap; // expected-warning{{will result in a CToPtr operation}} // expected-note{{to get the virtual address use}}
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_long
  // AST:       CStyleCastExpr {{.+}} 'long' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_default
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_capptr_to_ptr_default
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* [[CAP]]
//
char *test_capptr_to_ptr_default(char *__capability cap) {
  return (char *)cap; // expected-warning{{cast from capability type 'char * __capability' to non-capability type 'char *' is most likely an error}}
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_default
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_capptr_to_ptr_fromcap
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* [[CAP]]
//
char *test_capptr_to_ptr_fromcap(char *__capability cap) {
  return (__cheri_fromcap char *)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_fromcap
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_addr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_capptr_to_ptr_addr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP0]]
// PURECAP-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char *test_capptr_to_ptr_addr(char *__capability cap) {
  return (char *)(__cheri_addr long)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

/// intcap_t -> non-cap
// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_long
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_intcap_to_long
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    ret i64 [[TMP0]]
//
long test_intcap_to_long(__intcap cap) {
  return (long)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_long
  // AST:       CStyleCastExpr {{.+}} 'long' <IntegralCast>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_long_implicit
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_intcap_to_long_implicit
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    ret i64 [[TMP0]]
//
long test_intcap_to_long_implicit(__intcap cap) {
  return cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_long_implicit
  // AST:       ImplicitCastExpr {{.+}} 'long' <IntegralCast>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap' <LValueToRValue>
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.to.pointer.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to i8*
// CHECK-NEXT:    ret i8* [[TMP2]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_intcap_to_ptr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* [[CAP]]
//
char *test_intcap_to_ptr(__intcap cap) {
  return (char *)cap; // expected-warning{{will result in a CToPtr operation}} // expected-note{{to get the virtual address use}}
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_intcap_to_ptr_fromcap
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* [[CAP]]
//
char *test_intcap_to_ptr_fromcap(__intcap cap) {
  return (__cheri_fromcap void *)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_fromcap
  // AST:       ImplicitCastExpr {{.+}} 'char *' <BitCast>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void *' <CHERICapabilityToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_addr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_intcap_to_ptr_addr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP0]]
// PURECAP-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char *test_intcap_to_ptr_addr(__intcap cap) {
  return (char *)(__cheri_addr long)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap' <LValueToRValue> part_of_explicit_cast
}

/// char* __capability -> non-cap with intermediate cast to __intcap
// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_long_via_intcap
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_capptr_to_long_via_intcap
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    ret i64 [[TMP0]]
//
long test_capptr_to_long_via_intcap(char *__capability cap) {
  return (long)(__intcap)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_long_via_intcap
  // AST:       CStyleCastExpr {{.+}} 'long' <IntegralCast>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_long_via_intcap_implicit
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_capptr_to_long_via_intcap_implicit
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    ret i64 [[TMP0]]
//
long test_capptr_to_long_via_intcap_implicit(char *__capability cap) {
  return (__intcap)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_long_via_intcap_implicit
  // AST:       ImplicitCastExpr {{.+}} 'long' <IntegralCast>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_via_intcap_default
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.to.pointer.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to i8*
// CHECK-NEXT:    ret i8* [[TMP2]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_capptr_to_ptr_via_intcap_default
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* [[CAP]]
//
char *test_capptr_to_ptr_via_intcap_default(char *__capability cap) {
  return (char *)(__intcap)cap; // expected-warning{{will result in a CToPtr operation}} // expected-note{{to get the virtual address use}}
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_via_intcap_default
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_via_intcap_fromcap
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_capptr_to_ptr_via_intcap_fromcap
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* [[CAP]]
//
char *test_capptr_to_ptr_via_intcap_fromcap(char *__capability cap) {
  return (__cheri_fromcap char *)(__intcap)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_via_intcap_fromcap
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_capptr_to_ptr_via_intcap_addr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_capptr_to_ptr_via_intcap_addr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP0]]
// PURECAP-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char *test_capptr_to_ptr_via_intcap_addr(char *__capability cap) {
  return (char *)(__cheri_addr long)(__intcap)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_capptr_to_ptr_via_intcap_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap' <PointerToIntegral>
  // AST-NEXT:  ImplicitCastExpr {{.+}} 'char * __capability' <LValueToRValue> part_of_explicit_cast
}

/// intcap_t -> non-cap with intermediate cast to void* __capability
// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_long_via_capptr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.to.pointer.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    ret i64 [[TMP1]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_intcap_to_long_via_capptr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    ret i64 [[TMP0]]
//
long test_intcap_to_long_via_capptr(__intcap cap) {
  return (long)(void *__capability)cap; // expected-warning{{will result in a CToPtr operation}} // expected-note{{to get the virtual address use}}
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_long_via_capptr
  // AST:       CStyleCastExpr {{.+}} 'long' <PointerToIntegral>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_via_capptr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_intcap_to_ptr_via_capptr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* [[CAP]]
//
char *test_intcap_to_ptr_via_capptr(__intcap cap) {
  return (char *)(void *__capability)cap; // expected-warning{{cast from capability type 'void * __capability' to non-capability type 'char *' is most likely an error}}
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_via_capptr
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_via_capptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = addrspacecast i8 addrspace(200)* [[CAP]] to i8*
// CHECK-NEXT:    ret i8* [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_intcap_to_ptr_via_capptr_fromcap
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* [[CAP]]
//
char *test_intcap_to_ptr_via_capptr_fromcap(__intcap cap) {
  return (__cheri_fromcap void *)(void *__capability)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_via_capptr_fromcap
  // AST:       ImplicitCastExpr {{.+}} 'char *' <BitCast>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap' <LValueToRValue> part_of_explicit_cast
}

// CHECK-LABEL: define {{[^@]+}}@test_intcap_to_ptr_via_capptr_addr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_intcap_to_ptr_via_capptr_addr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[CAP]])
// PURECAP-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP0]]
// PURECAP-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char *test_intcap_to_ptr_via_capptr_addr(__intcap cap) {
  return (char *)(__cheri_addr long)(void *__capability)cap;
  // AST-LABEL: FunctionDecl {{.+}} test_intcap_to_ptr_via_capptr_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'void * __capability' <IntegralToPointer>
  // AST-NEXT:  ImplicitCastExpr {{.+}} '__intcap' <LValueToRValue> part_of_explicit_cast
}

/// NULL/constant conversions:

// CHECK-LABEL: define {{[^@]+}}@test_constant_intcap_to_ptr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.to.pointer.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1))
// CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to i8*
// CHECK-NEXT:    ret i8* [[TMP2]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_constant_intcap_to_ptr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1)
//
char *test_constant_intcap_to_ptr(__intcap cap) {
  return (char *)(__intcap)1; // expected-warning{{will result in a CToPtr operation}} // expected-note{{to get the virtual address use}}
  // AST-LABEL: FunctionDecl {{.+}} test_constant_intcap_to_ptr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap __attribute__((cheri_no_provenance))':'__intcap' <IntegralCast>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 1
}

// CHECK-LABEL: define {{[^@]+}}@test_constant_zero_intcap_to_ptr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8* null
//
// PURECAP-LABEL: define {{[^@]+}}@test_constant_zero_intcap_to_ptr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* null
//
char *test_constant_zero_intcap_to_ptr(__intcap cap) {
  return (char *)(__intcap)0;
  // AST-LABEL: FunctionDecl {{.+}} test_constant_zero_intcap_to_ptr
  // AST:       CStyleCastExpr {{.+}} 'char *' <NullToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap __attribute__((cheri_no_provenance))':'__intcap' <IntegralCast>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 0
}

// CHECK-LABEL: define {{[^@]+}}@test_constant_intcap_to_ptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8* addrspacecast (i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1) to i8*)
//
// PURECAP-LABEL: define {{[^@]+}}@test_constant_intcap_to_ptr_fromcap
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1)
//
char *test_constant_intcap_to_ptr_fromcap(__intcap cap) {
  return (__cheri_fromcap char *)(__intcap)1;
  // AST-LABEL: FunctionDecl {{.+}} test_constant_intcap_to_ptr_fromcap
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap __attribute__((cheri_no_provenance))':'__intcap' <IntegralCast>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 1
}

// CHECK-LABEL: define {{[^@]+}}@test_constant_zero_intcap_to_ptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8* null
//
// PURECAP-LABEL: define {{[^@]+}}@test_constant_zero_intcap_to_ptr_fromcap
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* null
//
char *test_constant_zero_intcap_to_ptr_fromcap(__intcap cap) {
  return (__cheri_fromcap char *)(__intcap)0;
  // AST-LABEL: FunctionDecl {{.+}} test_constant_zero_intcap_to_ptr_fromcap
  // TODO: this should be NullToPointer
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap __attribute__((cheri_no_provenance))':'__intcap' <IntegralCast>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 0
}

// CHECK-LABEL: define {{[^@]+}}@test_null_capptr_to_ptr_default
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8* null
//
// PURECAP-LABEL: define {{[^@]+}}@test_null_capptr_to_ptr_default
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* null
//
char *test_null_capptr_to_ptr_default(__intcap cap) {
  return (char *)(char *__capability)0; // expected-warning{{cast from capability type 'char * __capability __attribute__((cheri_no_provenance))' to non-capability type 'char *' is most likely an error; use __cheri_fromcap to convert between pointers and capabilities}}
  // AST-LABEL: FunctionDecl {{.+}} test_null_capptr_to_ptr_default
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'char * __capability __attribute__((cheri_no_provenance))':'char * __capability' <NullToPointer>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 0
}

// CHECK-LABEL: define {{[^@]+}}@test_null_capptr_to_ptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8* null
//
// PURECAP-LABEL: define {{[^@]+}}@test_null_capptr_to_ptr_fromcap
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* null
//
char *test_null_capptr_to_ptr_fromcap(__intcap cap) {
  return (__cheri_fromcap char *)(char *__capability)0;
  // AST-LABEL: FunctionDecl {{.+}} test_null_capptr_to_ptr_fromcap
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'char * __capability __attribute__((cheri_no_provenance))':'char * __capability' <NullToPointer>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 0
}

// CHECK-LABEL: define {{[^@]+}}@test_null_capptr_to_ptr_addr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* null)
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_null_capptr_to_ptr_addr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* null)
// PURECAP-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP0]]
// PURECAP-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char *test_null_capptr_to_ptr_addr(__intcap cap) {
  return (char *)(__cheri_addr long)(char *__capability)0;
  // AST-LABEL: FunctionDecl {{.+}} test_null_capptr_to_ptr_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'char * __capability __attribute__((cheri_no_provenance))':'char * __capability' <NullToPointer>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 0
}

// CHECK-LABEL: define {{[^@]+}}@test_constant_capptr_to_ptr_default
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8* addrspacecast (i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1) to i8*)
//
// PURECAP-LABEL: define {{[^@]+}}@test_constant_capptr_to_ptr_default
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1)
//
char *test_constant_capptr_to_ptr_default(__intcap cap) {
  return (char *)(char *__capability)(__intcap)1; // expected-warning{{cast from capability type 'char * __capability __attribute__((cheri_no_provenance))' to non-capability type 'char *' is most likely an error; use __cheri_fromcap to convert between pointers and capabilities}}
  // AST-LABEL: FunctionDecl {{.+}} test_constant_capptr_to_ptr_default
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'char * __capability __attribute__((cheri_no_provenance))':'char * __capability' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap __attribute__((cheri_no_provenance))':'__intcap' <IntegralCast>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 1
}

// CHECK-LABEL: define {{[^@]+}}@test_constant_capptr_to_ptr_fromcap
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i8* addrspacecast (i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1) to i8*)
//
// PURECAP-LABEL: define {{[^@]+}}@test_constant_capptr_to_ptr_fromcap
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    ret i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1)
//
char *test_constant_capptr_to_ptr_fromcap(__intcap cap) {
  return (__cheri_fromcap char *)(char *__capability)(__intcap)1;
  // AST-LABEL: FunctionDecl {{.+}} test_constant_capptr_to_ptr_fromcap
  // AST:       CStyleCastExpr {{.+}} 'char *' <CHERICapabilityToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'char * __capability __attribute__((cheri_no_provenance))':'char * __capability' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap __attribute__((cheri_no_provenance))':'__intcap' <IntegralCast>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 1
}

// CHECK-LABEL: define {{[^@]+}}@test_constant_capptr_to_ptr_addr
// CHECK-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1))
// CHECK-NEXT:    [[TMP1:%.*]] = inttoptr i64 [[TMP0]] to i8*
// CHECK-NEXT:    ret i8* [[TMP1]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_constant_capptr_to_ptr_addr
// PURECAP-SAME: (i8 addrspace(200)* noundef [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1))
// PURECAP-NEXT:    [[TMP1:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[TMP0]]
// PURECAP-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
char *test_constant_capptr_to_ptr_addr(__intcap cap) {
  return (char *)(__cheri_addr long)(char *__capability)(__intcap)1;
  // AST-LABEL: FunctionDecl {{.+}} test_constant_capptr_to_ptr_addr
  // AST:       CStyleCastExpr {{.+}} 'char *' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'long' <CHERICapabilityToAddress>
  // AST-NEXT:  CStyleCastExpr {{.+}} 'char * __capability __attribute__((cheri_no_provenance))':'char * __capability' <IntegralToPointer>
  // AST-NEXT:  CStyleCastExpr {{.+}} '__intcap __attribute__((cheri_no_provenance))':'__intcap' <IntegralCast>
  // AST-NEXT:  IntegerLiteral {{.+}} 'int' 1
}
