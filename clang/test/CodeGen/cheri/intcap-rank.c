// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %riscv32_cheri_cc1 -o - -emit-llvm -disable-O0-optnone %s \
// RUN:    | opt -S -passes=mem2reg | FileCheck %s --check-prefix=CHECK32
// RUN: %cheri128_cc1 -o - -emit-llvm -disable-O0-optnone %s \
// RUN:    | opt -S -passes=mem2reg | FileCheck %s --check-prefix=CHECK64
// RUN: %riscv64_cheri_cc1 -o - -emit-llvm -disable-O0-optnone %s \
// RUN:    | opt -S -passes=mem2reg | FileCheck %s --check-prefix=CHECK64

// Test that __intcap always has higher rank than any other integer type in
// order to ensure preservation of valid provenance even in the face of using
// oversized (or right-sized but still higher rank than size_t, as is the case
// for long long on LP64/L64PC128 architectures) types.

// CHECK32-LABEL: @test_sl(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i32 [[Y:%.*]]
// CHECK32-NEXT:    [[TMP1:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[X:%.*]])
// CHECK32-NEXT:    [[TMP2:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[TMP0]])
// CHECK32-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], [[TMP2]]
// CHECK32-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i32(ptr addrspace(200) [[X]], i32 [[ADD]])
// CHECK32-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
// CHECK64-LABEL: @test_sl(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i64 [[Y:%.*]]
// CHECK64-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[X:%.*]])
// CHECK64-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK64-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP1]], [[TMP2]]
// CHECK64-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[X]], i64 [[ADD]])
// CHECK64-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
__intcap_t test_sl(__intcap_t x, long y) {
  return x + y;
}

// CHECK32-LABEL: @test_ul(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i32 [[Y:%.*]]
// CHECK32-NEXT:    [[TMP1:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[X:%.*]])
// CHECK32-NEXT:    [[TMP2:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[TMP0]])
// CHECK32-NEXT:    [[ADD:%.*]] = add i32 [[TMP1]], [[TMP2]]
// CHECK32-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i32(ptr addrspace(200) [[X]], i32 [[ADD]])
// CHECK32-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
// CHECK64-LABEL: @test_ul(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i64 [[Y:%.*]]
// CHECK64-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[X:%.*]])
// CHECK64-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK64-NEXT:    [[ADD:%.*]] = add i64 [[TMP1]], [[TMP2]]
// CHECK64-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[X]], i64 [[ADD]])
// CHECK64-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
__intcap_t test_ul(__intcap_t x, unsigned long y) {
  return x + y;
}

// CHECK32-LABEL: @test_sll(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[CONV:%.*]] = trunc i64 [[Y:%.*]] to i32
// CHECK32-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i32 [[CONV]]
// CHECK32-NEXT:    [[TMP1:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[X:%.*]])
// CHECK32-NEXT:    [[TMP2:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[TMP0]])
// CHECK32-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], [[TMP2]]
// CHECK32-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i32(ptr addrspace(200) [[X]], i32 [[ADD]])
// CHECK32-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
// CHECK64-LABEL: @test_sll(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i64 [[Y:%.*]]
// CHECK64-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[X:%.*]])
// CHECK64-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK64-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP1]], [[TMP2]]
// CHECK64-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[X]], i64 [[ADD]])
// CHECK64-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
__intcap_t test_sll(__intcap_t x, long long y) {
  return x + y;
}

// CHECK32-LABEL: @test_ull(
// CHECK32-NEXT:  entry:
// CHECK32-NEXT:    [[CONV:%.*]] = trunc i64 [[Y:%.*]] to i32
// CHECK32-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i32 [[CONV]]
// CHECK32-NEXT:    [[TMP1:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[X:%.*]])
// CHECK32-NEXT:    [[TMP2:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[TMP0]])
// CHECK32-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP1]], [[TMP2]]
// CHECK32-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i32(ptr addrspace(200) [[X]], i32 [[ADD]])
// CHECK32-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
// CHECK64-LABEL: @test_ull(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i64 [[Y:%.*]]
// CHECK64-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[X:%.*]])
// CHECK64-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK64-NEXT:    [[ADD:%.*]] = add i64 [[TMP1]], [[TMP2]]
// CHECK64-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[X]], i64 [[ADD]])
// CHECK64-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
__intcap_t test_ull(__intcap_t x, unsigned long long y) {
  return x + y;
}

#ifdef __SIZEOF_INT128__
// CHECK64-LABEL: @test_s128(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[CONV:%.*]] = trunc i128 [[Y:%.*]] to i64
// CHECK64-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i64 [[CONV]]
// CHECK64-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[X:%.*]])
// CHECK64-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK64-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP1]], [[TMP2]]
// CHECK64-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[X]], i64 [[ADD]])
// CHECK64-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
__intcap_t test_s128(__intcap_t x, __int128 y) {
  return x + y;
}

// CHECK64-LABEL: @test_u128(
// CHECK64-NEXT:  entry:
// CHECK64-NEXT:    [[CONV:%.*]] = trunc i128 [[Y:%.*]] to i64
// CHECK64-NEXT:    [[TMP0:%.*]] = getelementptr i8, ptr addrspace(200) null, i64 [[CONV]]
// CHECK64-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[X:%.*]])
// CHECK64-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK64-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP1]], [[TMP2]]
// CHECK64-NEXT:    [[TMP3:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[X]], i64 [[ADD]])
// CHECK64-NEXT:    ret ptr addrspace(200) [[TMP3]]
//
__intcap_t test_u128(__intcap_t x, unsigned __int128 y) {
  return x + y;
}
#endif
