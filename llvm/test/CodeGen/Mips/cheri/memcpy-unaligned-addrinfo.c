// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri128_purecap_cc1 %s -emit-llvm -O0 -o - | FileCheck %s -check-prefix OPTNONE
// RUN-NOT: %cheri128_purecap_cc1 %s -emit-llvm -O2 -o - -debug-info-kind=standalone | FileCheck %s
// RUN: %cheri128_purecap_cc1 %s -S -O2 -o - -verify -debug-info-kind=standalone | FileCheck %s -check-prefix ASM
// REQUIRES: clang
//
// FIXME
// This test is checking a load of detail in the debug info and I can't tell
// what it actually wants to be testing, so I've disabled the middle test.
// It's also a horrible layering violation having a test that depends on clang
// in the LLVM back end.

struct addrinfo {
  char *b;
};

// CHECK-LABEL: @c(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.dbg.value(metadata i8 addrspace(200)* [[A:%.*]], metadata !21, metadata !DIExpression()), !dbg !23
// CHECK-NEXT:    [[RETVAL_SROA_0_0_A_ADDR_0__SROA_CAST:%.*]] = bitcast i8 addrspace(200)* [[A]] to i8 addrspace(200)* addrspace(200)*, !dbg !24
// CHECK-NEXT:    [[RETVAL_SROA_0_0_COPYLOAD:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[RETVAL_SROA_0_0_A_ADDR_0__SROA_CAST]], align 1, !dbg 
// CHECK-NEXT:    call void @llvm.dbg.value(metadata i8 addrspace(200)* [[RETVAL_SROA_0_0_COPYLOAD]], metadata !22, metadata !DIExpression()), !dbg 
// CHECK-NEXT:    [[DOTFCA_0_INSERT:%.*]] = insertvalue { i8 addrspace(200)* } undef, i8 addrspace(200)* [[RETVAL_SROA_0_0_COPYLOAD]], 0, !dbg ![[DEBUG_ID:[0-9]+]]
// CHECK-NEXT:    ret { i8 addrspace(200)* } [[DOTFCA_0_INSERT]], !dbg ![[DEBUG_ID]]
//
struct addrinfo c(char* a) {
  struct addrinfo d;
  __builtin_memcpy(&d, a, sizeof(struct addrinfo));
  // expected-warning@-1{{found underaligned load of capability type (aligned to 1 bytes instead of 16). Will use memcpy() instead of capability load to preserve tags if it is aligned correctly at runtime}}
  // expected-note@-2{{use __builtin_assume_aligned() or cast}}
  return d;

// ASM:      clcbi	$c12, %capcall20(memcpy)($c1)
// ASM-NEXT: .Ltmp1:
// ASM-NEXT: .loc 1 28 0 prologue_end
// ASM-NEXT: csetbounds	$c3, $c11, 16
// ASM-NEXT: .Ltmp2:
// ASM-NEXT: cjalr	$c12, $c17
// ASM-NEXT: daddiu	$4, $zero, 16
}


struct group {
  char *b;
};
void do_stuff(struct group* g);
// CHECK-LABEL: @copy_group(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUFFER:%.*]] = alloca i8 addrspace(200)*, align 16, addrspace(200)
// CHECK-NEXT:    call void @llvm.dbg.value(metadata i8 addrspace(200)* [[A:%.*]], metadata ![[DEBUG_ID:[0-9]+]], metadata !DIExpression()), !dbg
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i8 addrspace(200)* addrspace(200)* [[BUFFER]] to i8 addrspace(200)*, !dbg 
// CHECK-NEXT:    call void @llvm.lifetime.start.p200i8(i64 16, i8 addrspace(200)* nonnull [[TMP0]]) #5, !dbg 
// CHECK-NEXT:    call void @llvm.dbg.value(metadata i8 addrspace(200)* [[A]], metadata ![[DEBUG_ID2:[0-9]+]], metadata !DIExpression()), !dbg
// CHECK-NEXT:    store i8 addrspace(200)* [[A]], i8 addrspace(200)* addrspace(200)* [[BUFFER]], align 16, !dbg
// CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* addrspace(200)* [[BUFFER]] to [[STRUCT_GROUP:%.*]] addrspace(200)*, !dbg
// CHECK-NEXT:    call void @llvm.dbg.value(metadata [[STRUCT_GROUP]] addrspace(200)* [[TMP1]], metadata !38, metadata !DIExpression()), !dbg
// CHECK-NEXT:    call void @do_stuff(%struct.group addrspace(200)* nonnull [[TMP1]]) #5, !dbg
// CHECK-NEXT:    call void @llvm.lifetime.end.p200i8(i64 16, i8 addrspace(200)* nonnull [[TMP0]]) #5, !dbg
// CHECK-NEXT:    ret void, !dbg
//
void copy_group(const char* a) {
  // derived from the unaligned memcpy used in getgrent
  // NOTE: this buffer will be aligned sensibly at -O2 so that we can use a csc/clc
  char buffer[sizeof(struct group)];
  __builtin_memcpy(buffer, &a, sizeof(char*));
  struct group* g = (struct group*)buffer;
  do_stuff(g);
}

// CHECK-LABEL: @copy_group2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    call void @llvm.dbg.value(metadata i8 addrspace(200)* [[A:%.*]], metadata !49, metadata !DIExpression()), !dbg !52
// CHECK-NEXT:    call void @llvm.dbg.value(metadata i8 addrspace(200)* [[BUFFER:%.*]], metadata !50, metadata !DIExpression()), !dbg !52
// CHECK-NEXT:    [[A_ADDR_0_BUFFER_ADDR_0__SROA_CAST:%.*]] = bitcast i8 addrspace(200)* [[BUFFER]] to i8 addrspace(200)* addrspace(200)*, !dbg !53
// CHECK-NEXT:    store i8 addrspace(200)* [[A]], i8 addrspace(200)* addrspace(200)* [[A_ADDR_0_BUFFER_ADDR_0__SROA_CAST]], align 1, !dbg !53
// CHECK-NEXT:    [[TMP0:%.*]] = bitcast i8 addrspace(200)* [[BUFFER]] to [[STRUCT_GROUP:%.*]] addrspace(200)*, !dbg !54
// CHECK-NEXT:    call void @llvm.dbg.value(metadata [[STRUCT_GROUP]] addrspace(200)* [[TMP0]], metadata !51, metadata !DIExpression()), !dbg !54
// CHECK-NEXT:    tail call void @do_stuff(%struct.group addrspace(200)* [[TMP0]]) #5, !dbg !55
// CHECK-NEXT:    ret void, !dbg !56
//
void copy_group2(const char* a, char* buffer) {
  // OPTNONE-LABEL: @copy_group2
  // OPTNONE-LABEL:  call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 1 %{{.+}}, i8 addrspace(200)* align 16 %{{.+}}, i64 16, i1 false) #3

  // derived from the unaligned memcpy used in getgrent
  // Note: this will result in an unaligned memcpy
  __builtin_memcpy(buffer, &a, sizeof(char*));
  // expected-warning@-1{{found underaligned store of capability type (aligned to 1 bytes instead of 16). Will use memcpy() instead of capability load to preserve tags if it is aligned correctly at runtime}}
  // expected-note@-2{{use __builtin_assume_aligned()}}
  struct group* g = (struct group*)buffer;
  do_stuff(g);
}

void copy_group3(char *buffer, struct group a, long size) {
  // derived from the unaligned memcpy used in getgrent
  __builtin_memcpy(buffer, &a, size);
  struct group *g = (struct group *)buffer;
  do_stuff(g);
}

// OPTNONE: attributes #3 = { "frontend-memtransfer-type"="'const char * __capability'" "must-preserve-cheri-tags" }
