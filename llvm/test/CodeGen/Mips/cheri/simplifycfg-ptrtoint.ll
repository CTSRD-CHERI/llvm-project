; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: opt -data-layout="E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200" -S -instcombine %s -o - | FileCheck -check-prefix INSTCOMBINE %s
; RUN: opt -data-layout="E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200" -S -O2 %s -o - | FileCheck -check-prefix IR %s
; RUN: opt -data-layout="E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200" -S -O2 %s -o - | %cheri_purecap_llc -O2 -o - | %cheri_FileCheck %s -check-prefix ASM

; After fixing valuetracking to look through address set intrinsics,
; SimplifyCFG would create a ptrtoint for this three value check:

; Original C source code:
; typedef __UINTPTR_TYPE__ uintptr_t;
; void finalizer(void (*fn)(void)) {
;   if ((uintptr_t) fn != 0 && (uintptr_t) fn != 1 && (uintptr_t) fn != 2)
;     (fn)();
; }

; target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
target triple = "cheri-unknown-freebsd"

; Function Attrs: nounwind
define void @cannot_fold_tag_unknown(void () addrspace(200)* %fn) local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: cannot_fold_tag_unknown:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    cincoffset $c1, $cnull, 2
; ASM-NEXT:    ceq $1, $c3, $c1
; ASM-NEXT:    bnez $1, .LBB0_4
; ASM-NEXT:    nop
; ASM-NEXT:  # %bb.1: # %entry
; ASM-NEXT:    cbez $c3, .LBB0_4
; ASM-NEXT:    nop
; ASM-NEXT:  # %bb.2: # %entry
; ASM-NEXT:    cincoffset $c1, $cnull, 1
; ASM-NEXT:    ceq $1, $c3, $c1
; ASM-NEXT:    bnez $1, .LBB0_4
; ASM-NEXT:    nop
; ASM-NEXT:  # %bb.3: # %if.then
; ASM-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    csc $c17, $zero, 0($c11)
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    clcbi $c12, %capcall20(foo)($c1)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    nop
; ASM-NEXT:    clc $c17, $zero, 0($c11)
; ASM-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
; ASM-NEXT:  .LBB0_4: # %if.end
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    nop
; INSTCOMBINE-LABEL: define {{[^@]+}}@cannot_fold_tag_unknown
; INSTCOMBINE-SAME: (void () addrspace(200)* [[FN:%.*]]) local_unnamed_addr addrspace(200)
; INSTCOMBINE-NEXT:  entry:
; INSTCOMBINE-NEXT:    [[TMP0:%.*]] = bitcast void () addrspace(200)* [[FN]] to i8 addrspace(200)*
; INSTCOMBINE-NEXT:    [[CMP:%.*]] = icmp eq void () addrspace(200)* [[FN]], null
; INSTCOMBINE-NEXT:    br i1 [[CMP]], label [[IF_END:%.*]], label [[LAND_LHS_TRUE:%.*]]
; INSTCOMBINE:       land.lhs.true:
; INSTCOMBINE-NEXT:    [[CMP1:%.*]] = icmp eq void () addrspace(200)* [[FN]], bitcast (i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1) to void () addrspace(200)*)
; INSTCOMBINE-NEXT:    br i1 [[CMP1]], label [[IF_END]], label [[LAND_LHS_TRUE2:%.*]]
; INSTCOMBINE:       land.lhs.true2:
; INSTCOMBINE-NEXT:    [[CMP3:%.*]] = icmp eq void () addrspace(200)* [[FN]], bitcast (i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 2) to void () addrspace(200)*)
; INSTCOMBINE-NEXT:    br i1 [[CMP3]], label [[IF_END]], label [[IF_THEN:%.*]]
; INSTCOMBINE:       if.then:
; INSTCOMBINE-NEXT:    tail call void @foo(i8 addrspace(200)* nonnull [[TMP0]])
; INSTCOMBINE-NEXT:    br label [[IF_END]]
; INSTCOMBINE:       if.end:
; INSTCOMBINE-NEXT:    ret void
; IR-LABEL: define {{[^@]+}}@cannot_fold_tag_unknown
; IR-SAME: (void () addrspace(200)* [[FN:%.*]]) local_unnamed_addr addrspace(200)
; IR-NEXT:  entry:
; IR-NEXT:    [[CMP:%.*]] = icmp eq void () addrspace(200)* [[FN]], null
; IR-NEXT:    [[CMP1:%.*]] = icmp eq void () addrspace(200)* [[FN]], bitcast (i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1) to void () addrspace(200)*)
; IR-NEXT:    [[OR_COND:%.*]] = or i1 [[CMP]], [[CMP1]]
; IR-NEXT:    [[CMP3:%.*]] = icmp eq void () addrspace(200)* [[FN]], bitcast (i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 2) to void () addrspace(200)*)
; IR-NEXT:    [[OR_COND1:%.*]] = or i1 [[CMP3]], [[OR_COND]]
; IR-NEXT:    br i1 [[OR_COND1]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; IR:       if.then:
; IR-NEXT:    [[TMP0:%.*]] = bitcast void () addrspace(200)* [[FN]] to i8 addrspace(200)*
; IR-NEXT:    tail call void @foo(i8 addrspace(200)* nonnull [[TMP0]])
; IR-NEXT:    br label [[IF_END]]
; IR:       if.end:
; IR-NEXT:    ret void
entry:
  %0 = bitcast void () addrspace(200)* %fn to i8 addrspace(200)*
  %cmp = icmp eq void () addrspace(200)* %fn, null
  br i1 %cmp, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* null, i64 1)
  %cmp1 = icmp eq i8 addrspace(200)* %1, %0
  br i1 %cmp1, label %if.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* null, i64 2)
  %cmp3 = icmp eq i8 addrspace(200)* %2, %0
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  tail call void @foo(i8 addrspace(200)* %0) #2
  br label %if.end

if.end:                                           ; preds = %land.lhs.true2, %land.lhs.true, %entry, %if.then
  ret void
}

define void @can_fold_tag_unset(void () addrspace(200)* %fn_tagged) local_unnamed_addr nounwind {
; Running instcombine should convert this to a vaddr compare and simplifycfg will then convert it to a single cmp
; INSTCOMBINE-LABEL: define {{[^@]+}}@can_fold_tag_unset
; INSTCOMBINE-SAME: (void () addrspace(200)* [[FN_TAGGED:%.*]]) local_unnamed_addr addrspace(200)
; INSTCOMBINE-NEXT:  entry:
; INSTCOMBINE-NEXT:    [[FN_I8:%.*]] = bitcast void () addrspace(200)* [[FN_TAGGED]] to i8 addrspace(200)*
; INSTCOMBINE-NEXT:    [[TMP0:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.tag.clear(i8 addrspace(200)* [[FN_I8]])
; INSTCOMBINE-NEXT:    [[OP0_ADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP0]])
; INSTCOMBINE-NEXT:    [[CMP:%.*]] = icmp eq i64 [[OP0_ADDR]], 0
; INSTCOMBINE-NEXT:    br i1 [[CMP]], label [[IF_END:%.*]], label [[LAND_LHS_TRUE:%.*]]
; INSTCOMBINE:       land.lhs.true:
; INSTCOMBINE-NEXT:    [[OP0_ADDR1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP0]])
; INSTCOMBINE-NEXT:    [[CMP1:%.*]] = icmp eq i64 [[OP0_ADDR1]], 1
; INSTCOMBINE-NEXT:    br i1 [[CMP1]], label [[IF_END]], label [[LAND_LHS_TRUE2:%.*]]
; INSTCOMBINE:       land.lhs.true2:
; INSTCOMBINE-NEXT:    [[OP0_ADDR2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP0]])
; INSTCOMBINE-NEXT:    [[CMP3:%.*]] = icmp eq i64 [[OP0_ADDR2]], 2
; INSTCOMBINE-NEXT:    br i1 [[CMP3]], label [[IF_END]], label [[IF_THEN:%.*]]
; INSTCOMBINE:       if.then:
; INSTCOMBINE-NEXT:    tail call void @foo(i8 addrspace(200)* [[FN_I8]])
; INSTCOMBINE-NEXT:    br label [[IF_END]]
; INSTCOMBINE:       if.end:
; INSTCOMBINE-NEXT:    ret void
;
; IR-LABEL: define {{[^@]+}}@can_fold_tag_unset
; IR-SAME: (void () addrspace(200)* [[FN_TAGGED:%.*]]) local_unnamed_addr addrspace(200)
; IR-NEXT:  entry:
; IR-NEXT:    [[FN_I8:%.*]] = bitcast void () addrspace(200)* [[FN_TAGGED]] to i8 addrspace(200)*
; IR-NEXT:    [[TMP0:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.tag.clear(i8 addrspace(200)* [[FN_I8]])
; IR-NEXT:    [[OP0_ADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP0]])
; IR-NEXT:    [[SWITCH:%.*]] = icmp ult i64 [[OP0_ADDR]], 3
; IR-NEXT:    br i1 [[SWITCH]], label [[IF_END:%.*]], label [[IF_THEN:%.*]]
; IR:       if.then:
; IR-NEXT:    tail call void @foo(i8 addrspace(200)* [[FN_I8]])
; IR-NEXT:    br label [[IF_END]]
; IR:       if.end:
; IR-NEXT:    ret void
;
; Much better with simplifycfg:
; ASM-LABEL: can_fold_tag_unset:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    ccleartag $c1, $c3
; ASM-NEXT:    cgetaddr $1, $c1
; ASM-NEXT:    sltiu $1, $1, 3
; ASM-NEXT:    bnez $1, .LBB1_2
; ASM-NEXT:    nop
; ASM-NEXT:  # %bb.1: # %if.then
; ASM-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    csc $c17, $zero, 0($c11)
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    clcbi $c12, %capcall20(foo)($c1)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    nop
; ASM-NEXT:    clc $c17, $zero, 0($c11)
; ASM-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
; ASM-NEXT:  .LBB1_2: # %if.end
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    nop
entry:
  %fn_i8 = bitcast void () addrspace(200)* %fn_tagged to i8 addrspace(200)*
  %0 = call i8 addrspace(200)* @llvm.cheri.cap.tag.clear(i8 addrspace(200)* %fn_i8)
  %cmp = icmp eq i8 addrspace(200)* %0, null
  br i1 %cmp, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* null, i64 1)
  %cmp1 = icmp eq i8 addrspace(200)* %1, %0
  br i1 %cmp1, label %if.end, label %land.lhs.true2

land.lhs.true2:                                   ; preds = %land.lhs.true
  %2 = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* null, i64 2)
  %cmp3 = icmp eq i8 addrspace(200)* %2, %0
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true2
  tail call void @foo(i8 addrspace(200)* %fn_i8) #2
  br label %if.end

if.end:                                           ; preds = %land.lhs.true2, %land.lhs.true, %entry, %if.then
  ret void
}

; Function Attrs: nounwind readnone
declare i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)*, i64) #1
declare i8 addrspace(200)* @llvm.cheri.cap.tag.clear(i8 addrspace(200)*) #1

; Function Attrs: nounwind readnone
declare i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)*) #1
declare void @foo(i8 addrspace(200)*) #1

; Function Attrs: nounwind readnone
declare i8 addrspace(200)* @llvm.cheri.cap.offset.increment.i64(i8 addrspace(200)*, i64) #1
