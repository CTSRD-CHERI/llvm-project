; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: rm -f %t.dbg
; RUN: %cheri_purecap_llc %s -o - -collect-csetbounds-stats=csv 2>%t.dbg| %cheri_FileCheck %s -check-prefixes CHECK,%cheri_type
; RUN: %cheri_llc %s -o - | %cheri_FileCheck %s -check-prefix=HYBRID
; RUN: FileCheck %s -input-file=%t.dbg -check-prefix=DBG

; Check that expanding unaligned capability loads and stores works (but generates a warning)
; DBG: warning: <unknown>:0:0: in function load_unaligned i8 addrspace(200)* (i8 addrspace(200)*): found underaligned load of capability type (aligned to 4 bytes instead of {{16|32}}). Will use memcpy() instead of capability load to preserve tags if it is aligned correctly at runtime
; DBG-NEXT: warning: sroa-libunwind.cxx:9:3: in function store_unaligned void (i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*): found underaligned store of capability type (aligned to 4 bytes instead of {{16|32}}). Will use memcpy() instead of capability load to preserve tags if it is aligned correctly at runtime
; DBG-NEXT: warning: <unknown>:0:0: in function store_of_unaligned_load void (i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*): found underaligned store of underaligned load of capability type (aligned to 8 bytes instead of {{16|32}}). Will use memmove() to preserve tags if it is aligned correctly at runtime
; DBG-NEXT: {{4|5}},{{16|32}},s,"<somewhere in load_unaligned>","expanding unaligned capability load/store","expanding unaligned capability load stack destination"
; DBG-NEXT: {{4|5}},{{16|32}},s,"<somewhere in load_unaligned>","expanding unaligned capability load/store","expanding unaligned capability load memcpy source"
; DBG-NEXT: {{4|5}},{{16|32}},s,"sroa-libunwind.cxx:9:3","expanding unaligned capability load/store","expanding unaligned capability store stack source"
; DBG-NEXT: {{4|5}},{{16|32}},s,"sroa-libunwind.cxx:9:3","expanding unaligned capability load/store","expanding unaligned capability store memcpy destination"
; DBG-NEXT: {{4|5}},{{16|32}},s,"<somewhere in store_of_unaligned_load>","expanding unaligned capability load/store","expanding unaligned capability store+load memmove src"
; DBG-NEXT: {{4|5}},{{16|32}},s,"<somewhere in store_of_unaligned_load>","expanding unaligned capability load/store","expanding unaligned capability store+load memmove dest"
; DBG-EMPTY:

; Function Attrs: nounwind readonly uwtable
define i8 addrspace(200)* @load_unaligned(i8 addrspace(200)* %unaligned) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: load_unaligned:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:32|64]]
; CHECK-NEXT:    .cfi_def_cfa_offset [[STACKFRAME_SIZE]]
; CHECK-NEXT:    csc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    .cfi_offset 89, -[[#CAP_SIZE * 1]]
; CHECK-NEXT:    lui $1, %hi(%neg(%captab_rel(load_unaligned)))
; CHECK-NEXT:    daddiu $1, $1, %lo(%neg(%captab_rel(load_unaligned)))
; CHECK-NEXT:    cincoffset $c1, $c12, $1
; CHECK-NEXT:    csetbounds $c4, $c3, [[#CAP_SIZE]]
; CHECK-NEXT:    clcbi $c12, %capcall20(memcpy)($c1)
; stack offset is zero so no need for cincoffset
; CHECK-NEXT:    csetbounds $c3, $c11, [[#CAP_SIZE]]
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    daddiu $4, $zero, [[#CAP_SIZE]]
; CHECK-NEXT:    clc $c3, $zero, 0($c11)
; CHECK-NEXT:    clc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]

; HYBRID-LABEL: load_unaligned:
; HYBRID:      csetbounds	$c4, $c3, [[#CAP_SIZE]]
; HYBRID-NEXT: daddiu	$16, $sp, 0
; HYBRID-NEXT: cfromddc	$c3, $16
; HYBRID-NEXT: jal	memcpy_c
; HYBRID-NEXT: daddiu	$4, $zero, [[#CAP_SIZE]] 
; HYBRID-NEXT: clc	$c3, $16, 0($ddc)

entry:
  %r.0..sroa_cast = bitcast i8 addrspace(200)* %unaligned to i8 addrspace(200)* addrspace(200)*
  %r.0.copyload = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %r.0..sroa_cast, align 4
  ret i8 addrspace(200)* %r.0.copyload
}

define void @store_unaligned(i8 addrspace(200)* %unused, i8 addrspace(200)* %unaligned, i8 addrspace(200)* %value) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: store_unaligned:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:32|64]]
; CHECK-NEXT:    .cfi_def_cfa_offset [[STACKFRAME_SIZE]]
; CHECK-NEXT:    csc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    .cfi_offset 89, -[[#CAP_SIZE * 1]]
; CHECK-NEXT:    lui $1, %hi(%neg(%captab_rel(store_unaligned)))
; CHECK-NEXT:    daddiu $1, $1, %lo(%neg(%captab_rel(store_unaligned)))
; CHECK-NEXT:    cincoffset $c1, $c12, $1
; CHECK-NEXT:    csetbounds $c3, $c4, [[#CAP_SIZE]]
; CHECK-NEXT:    csc $c5, $zero, 0($c11)
; CHECK-NEXT:    clcbi $c12, %capcall20(memcpy)($c1)
; stack offset is zero so no need for cincoffset
; CHECK-NEXT:    csetbounds $c4, $c11, [[#CAP_SIZE]]
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    daddiu $4, $zero, [[#CAP_SIZE]]
; CHECK-NEXT:    clc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]

; HYBRID-LABEL: store_unaligned:
; HYBRID:      csetbounds	$c3, $c4, [[#CAP_SIZE]]
; HYBRID-NEXT: daddiu	$1, $sp, 0
; HYBRID-NEXT: csc	$c5, $1, 0($ddc)
; HYBRID-NEXT: cfromddc	$c4, $1
; HYBRID-NEXT: jal	memcpy_c
; HYBRID-NEXT: daddiu	$4, $zero, [[#CAP_SIZE]]

entry:
  %r.0..sroa_cast = bitcast i8 addrspace(200)* %unaligned to i8 addrspace(200)* addrspace(200)*
  store i8 addrspace(200)* %value, i8 addrspace(200)* addrspace(200)* %r.0..sroa_cast, align 4, !dbg !11
  ret void
}

; This should be turned into a memmove:
define void @store_of_unaligned_load(i8 addrspace(200)* %src, i8 addrspace(200)* %dest, i8 addrspace(200)* %value) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: store_of_unaligned_load:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -[[STACKFRAME_SIZE:16|32]]
; CHECK-NEXT:    .cfi_def_cfa_offset [[STACKFRAME_SIZE]]
; CHECK-NEXT:    csc $c17, $zero, 0($c11)
; CHECK-NEXT:    .cfi_offset 89,
; CHECK-NEXT:    lui $1, %hi(%neg(%captab_rel(store_of_unaligned_load)))
; CHECK-NEXT:    daddiu $1, $1, %lo(%neg(%captab_rel(store_of_unaligned_load)))
; CHECK-NEXT:    cincoffset $c2, $c12, $1
; Bound source abd dest for memmove call:
; dest
; CHECK-NEXT:    csetbounds $c1, $c4, [[#CAP_SIZE]]
; src
; CHECK-NEXT:    csetbounds $c4, $c3, [[#CAP_SIZE]]
; CHECK-NEXT:    clcbi $c12, %capcall20(memmove)($c2)
; CHECK-NEXT:    daddiu $4, $zero, [[#CAP_SIZE]]
; CHECK-NEXT:    cjalr $c12, $c17
; Move bounded dest to src (not sure why it is wasting another register here)
; CHECK-NEXT:    cmove $c3, $c1
; CHECK-NEXT:    clc $c17, $zero, 0($c11)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, [[STACKFRAME_SIZE]]

; HYBRID-LABEL: store_of_unaligned_load:
; HYBRID:      csetbounds	$c1, $c4, [[#CAP_SIZE]]
; HYBRID-NEXT: csetbounds	$c4, $c3, [[#CAP_SIZE]]
; HYBRID-NEXT: daddiu $4, $zero, [[#CAP_SIZE]]
; HYBRID-NEXT: jal	memmove_c
; HYBRID-NEXT: cmove	$c3,  $c1

entry:
  %src_cast = bitcast i8 addrspace(200)* %src to i8 addrspace(200)* addrspace(200)*
  %dest_cast = bitcast i8 addrspace(200)* %dest to i8 addrspace(200)* addrspace(200)*
  %unaligned_load = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %src_cast, align 4
  store i8 addrspace(200)* %unaligned_load, i8 addrspace(200)* addrspace(200)* %dest_cast, align 8
  ret void
}

; Function Attrs: nounwind readnone
declare i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)*, i64) addrspace(200) #1

; Function Attrs: nounwind readnone
declare i8 addrspace(200)* @llvm.cheri.cap.offset.increment.i64(i8 addrspace(200)*, i64) addrspace(200) #1

; Function Attrs: nounwind readnone
declare i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)*) addrspace(200) #1

attributes #0 = { nounwind readonly uwtable }
attributes #1 = { nounwind readnone }

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!3, !4}

!0 = distinct !DICompileUnit(language: DW_LANG_C_plus_plus, file: !8, isOptimized: true, runtimeVersion: 0, emissionKind: LineTablesOnly, enums: !2, nameTableKind: None)
!1 = !DIFile(filename: "sroa-libunwind.cxx", directory: "/some/dir")
!2 = !{}
!3 = !{i32 2, !"Dwarf Version", i32 5}
!4 = !{i32 2, !"Debug Info Version", i32 3}
!7 = distinct !DISubprogram(name: "store_unaligned", scope: !8, file: !8, line: 7, scopeLine: 7, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !2)
!8 = !DIFile(filename: "sroa-libunwind.cxx", directory: "/foo")
!11 = !DILocation(line: 9, column: 3, scope: !7)
