; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri128_purecap_llc -cheri-cap-table-abi=pcrel -O2 -o - %s | %cheri_FileCheck %s -check-prefixes PCREL
; ModuleID = 'libxo.i'

%struct.xo_handle_s = type { i8 addrspace(200)* }

@b = common addrspace(200) global %struct.xo_handle_s zeroinitializer, align 32

; Function Attrs: nounwind
; Check that locally creating a va_list and then storing it to a global works
; (Yes, this is an odd thing to do.  See libxo for a real-world example)
; This is similar to cheri-sandbox-vaargs.ll, but ensures CheriBoundAllocas can
; handle the optimiser turning AddrSpaceCast instructions into ConstantExpr's
define void @xo_emit(i8 addrspace(200)* %fmt, ...) nounwind {
; PCREL-LABEL: xo_emit:
; PCREL:       # %bb.0: # %entry
; PCREL-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; PCREL-NEXT:    csc $c24, $zero, [[#STACKFRAME_SIZE - CAP_SIZE]]($c11)
; PCREL-NEXT:    csc $c17, $zero, [[#STACKFRAME_SIZE - (2 * CAP_SIZE)]]($c11)
; PCREL-NEXT:    cincoffset $c24, $c11, $zero
; PCREL-NEXT:    cgetaddr $1, $c11
; PCREL-NEXT:    daddiu $2, $zero, -32
; PCREL-NEXT:    and $1, $1, $2
; PCREL-NEXT:    csetaddr $c11, $c11, $1
; PCREL-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PCREL-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PCREL-NEXT:    cgetpccincoffset $c1, $1
; PCREL-NEXT:    clcbi $c1, %captab20(b)($c1)
; PCREL-NEXT:    csc $c3, $zero, 32($c11)
; PCREL-NEXT:    csc $c1, $zero, 0($c11)
; PCREL-NEXT:    csc $c13, $zero, 0($c1)
; PCREL-NEXT:    cgetnull $c13
; PCREL-NEXT:    cincoffset $c11, $c24, $zero
; PCREL-NEXT:    clc $c17, $zero, [[#STACKFRAME_SIZE - (2 * CAP_SIZE)]]($c11)
; PCREL-NEXT:    clc $c24, $zero, [[#STACKFRAME_SIZE - CAP_SIZE]]($c11)
; PCREL-NEXT:    cjr $c17
; PCREL-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
entry:
  %fmt.addr = alloca i8 addrspace(200)*, align 32, addrspace(200)
  %c = alloca %struct.xo_handle_s addrspace(200)*, align 32, addrspace(200)
  store i8 addrspace(200)* %fmt, i8 addrspace(200)* addrspace(200)* %fmt.addr, align 32
  store %struct.xo_handle_s addrspace(200)* @b, %struct.xo_handle_s addrspace(200)* addrspace(200)* %c, align 32
  %0 = load %struct.xo_handle_s addrspace(200)*, %struct.xo_handle_s addrspace(200)* addrspace(200)* %c, align 32
  %xo_vap = getelementptr inbounds %struct.xo_handle_s, %struct.xo_handle_s addrspace(200)* %0, i32 0, i32 0
  %xo_vap1 = bitcast i8 addrspace(200)* addrspace(200)* %xo_vap to i8 addrspace(200)*
  ; Load the address of b
  ; Store the va_list (passed in $c13) in the global
  call void @llvm.va_start.p200i8(i8 addrspace(200)* %xo_vap1)
  ret void
}

; Function Attrs: nounwind
declare void @llvm.va_start.p200i8(i8 addrspace(200)*) #0

attributes #0 = { nounwind }

