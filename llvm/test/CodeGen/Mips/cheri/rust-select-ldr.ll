; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: sed 's/addrspace(200)/addrspace(0)/g' %s | %cheri_llc -verify-machineinstrs -O0 -o - | FileCheck %s -check-prefix MIPS
; RUN: %cheri_purecap_llc -verify-machineinstrs -O0 -o - %s | %cheri_FileCheck %s -check-prefix PURECAP
; REQUIRES: cheri_is_128
; This rust-derived IR was generating a LDL instruction for the extractvalue of the hidden sret paramter:

declare dso_local i128 @"_ZN3lib6option15Option$LT$T$GT$6unwrap17h50e7a820126dcfe5E"(i64, i128) unnamed_addr addrspace(200) #0

declare dso_local { i64, i128 } @"_ZN63_$LT$main..Counter$u20$as$u20$lib..iter..iterator..Iterator$GT$4next17h229c875ab7438d23E"(i128 addrspace(200)*) unnamed_addr addrspace(200) #0

define internal void @_ZN4main4main17hfe98083a4c87500fE() unnamed_addr addrspace(200) nounwind {
; MIPS-LABEL: _ZN4main4main17hfe98083a4c87500fE:
; MIPS:       # %bb.0: # %start
; MIPS-NEXT:    daddiu $sp, $sp, -[[#STACKFRAME_SIZE:]]
; MIPS-NEXT:    sd $ra, 56($sp) # 8-byte Folded Spill
; MIPS-NEXT:    daddiu $4, $sp, 8
; MIPS-NEXT:    daddiu $5, $sp, 32
; MIPS-NEXT:    jal _ZN63_$LT$main..Counter$u20$as$u20$lib..iter..iterator..Iterator$GT$4next17h229c875ab7438d23E
; MIPS-NEXT:    nop
; MIPS-NEXT:    ld $6, 24($sp)
; MIPS-NEXT:    ld $5, 16($sp)
; MIPS-NEXT:    ld $4, 8($sp)
; MIPS-NEXT:    jal _ZN3lib6option15Option$LT$T$GT$6unwrap17h50e7a820126dcfe5E
; MIPS-NEXT:    nop
; MIPS-NEXT:    ld $ra, 56($sp) # 8-byte Folded Reload
; MIPS-NEXT:    daddiu $sp, $sp, [[#STACKFRAME_SIZE]]
; MIPS-NEXT:    jr $ra
; MIPS-NEXT:    nop
;
; PURECAP-LABEL: _ZN4main4main17hfe98083a4c87500fE:
; PURECAP:       # %bb.0: # %start
; PURECAP-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; PURECAP-NEXT:    csc $c17, $zero, [[#STACKFRAME_SIZE - CAP_SIZE]]($c11)
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    cincoffset $c4, $c11, 48
; PURECAP-NEXT:    csetbounds $c4, $c4, 16
; PURECAP-NEXT:    clcbi $c12, %capcall20(_ZN63_$LT$main..Counter$u20$as$u20$lib..iter..iterator..Iterator$GT$4next17h229c875ab7438d23E)($c1)
; PURECAP-NEXT:    cincoffset $c3, $c11, 24
; PURECAP-NEXT:    cgetnull $c13
; PURECAP-NEXT:    csc $c1, $zero, 0($c11)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    cld $6, $zero, 40($c11)
; PURECAP-NEXT:    cld $5, $zero, 32($c11)
; PURECAP-NEXT:    cld $4, $zero, 24($c11)
; PURECAP-NEXT:    clc $c1, $zero, 0($c11)
; PURECAP-NEXT:    clcbi $c12, %capcall20(_ZN3lib6option15Option$LT$T$GT$6unwrap17h50e7a820126dcfe5E)($c1)
; PURECAP-NEXT:    cgetnull $c13
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    clc $c17, $zero, [[#STACKFRAME_SIZE - CAP_SIZE]]($c11)
; PURECAP-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop

; This is an insanely slow sequence of instructions but at least it no longer asserts:
start:
  %ctr = alloca i128, align 16, addrspace(200)
  %0 = call { i64, i128 } @"_ZN63_$LT$main..Counter$u20$as$u20$lib..iter..iterator..Iterator$GT$4next17h229c875ab7438d23E"(i128 addrspace(200)* align 16 dereferenceable(16) %ctr)
  %1 = extractvalue { i64, i128 } %0, 0
  %2 = extractvalue { i64, i128 } %0, 1
  %3 = call i128 @"_ZN3lib6option15Option$LT$T$GT$6unwrap17h50e7a820126dcfe5E"(i64 %1, i128 %2)
  ret void
}

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"RtLibUseGOT", i32 1}
