; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; This used to split the memcpy/memmove in sroa and create broken output
; RUNs: %cheri_purecap_opt -sroa -S %s -o - | FileCheck %s -check-prefix SROA
; RUN: %cheri_purecap_opt -sroa -S %s -o %t.ll
; RUN: FileCheck %s -check-prefix SROA -input-file=%t.ll
; RUN: %cheri_purecap_llc -O2 %t.ll -o - | FileCheck %s -check-prefixes=CHECK,WITH-SROA
; RUN: %cheri_purecap_llc -O2 %s -o - | FileCheck %s  -check-prefixes=CHECK,WITHOUT-SROA
target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"

%struct.addrinfo = type { i8 addrspace(200)* }

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* nocapture writeonly, i8 addrspace(200)* nocapture readonly, i64, i1) addrspace(200) #1
declare void @llvm.memmove.p200i8.p200i8.i64(i8 addrspace(200)* nocapture writeonly, i8 addrspace(200)* nocapture readonly, i64, i1) addrspace(200) #1

; Function Attrs: noinline nounwind optnone
define inreg { i8 addrspace(200)* } @do_not_split_cap_memcpy(i8 addrspace(200)* %a) addrspace(200) #0 {
; SROA-LABEL: @do_not_split_cap_memcpy(
; SROA-NEXT:  entry:
; SROA-NEXT:    [[RETVAL_SROA_0_0_A_ADDR_0__SROA_CAST:%.*]] = bitcast i8 addrspace(200)* [[A:%.*]] to i8 addrspace(200)* addrspace(200)*
; SROA-NEXT:    [[RETVAL_SROA_0_0_COPYLOAD:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[RETVAL_SROA_0_0_A_ADDR_0__SROA_CAST]], align 1
; SROA-NEXT:    [[DOTFCA_0_INSERT:%.*]] = insertvalue { i8 addrspace(200)* } undef, i8 addrspace(200)* [[RETVAL_SROA_0_0_COPYLOAD]], 0
; SROA-NEXT:    ret { i8 addrspace(200)* } [[DOTFCA_0_INSERT]]
;
entry:
  %retval = alloca %struct.addrinfo, align 16, addrspace(200)
  %a.addr = alloca i8 addrspace(200)*, align 16, addrspace(200)
  store i8 addrspace(200)* %a, i8 addrspace(200)* addrspace(200)* %a.addr, align 16
  %0 = bitcast %struct.addrinfo addrspace(200)* %retval to i8 addrspace(200)*
  %1 = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %a.addr, align 16
  call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 %0, i8 addrspace(200)* align 1 %1, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %struct.addrinfo, %struct.addrinfo addrspace(200)* %retval, i32 0, i32 0
  %2 = bitcast i8 addrspace(200)* addrspace(200)* %coerce.dive to { i8 addrspace(200)* } addrspace(200)*
  %3 = load { i8 addrspace(200)* }, { i8 addrspace(200)* } addrspace(200)* %2, align 16
  ret { i8 addrspace(200)* } %3
}

; CHECK-LABEL: do_not_split_cap_memcpy:
; CHECK:	clcbi	$c12, %capcall20(memcpy)($c1)
; CHECK-DAG:	csetbounds	$c3, $c{{3|11}}, 16
; CHECK-DAG:	cjalr	$c12, $c17
; CHECK-DAG:	daddiu	$4, $zero, 16
; CHECK: cjr $c17

; Function Attrs: noinline nounwind optnone
define inreg { i8 addrspace(200)* } @do_not_split_cap_memmove(i8 addrspace(200)* %a) addrspace(200) #0 {
; SROA-LABEL: @do_not_split_cap_memmove(
; SROA-NEXT:  entry:
; SROA-NEXT:    [[RETVAL_SROA_0_0_A_ADDR_0__SROA_CAST:%.*]] = bitcast i8 addrspace(200)* [[A:%.*]] to i8 addrspace(200)* addrspace(200)*
; SROA-NEXT:    [[RETVAL_SROA_0_0_COPYLOAD:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* [[RETVAL_SROA_0_0_A_ADDR_0__SROA_CAST]], align 1
; SROA-NEXT:    [[DOTFCA_0_INSERT:%.*]] = insertvalue { i8 addrspace(200)* } undef, i8 addrspace(200)* [[RETVAL_SROA_0_0_COPYLOAD]], 0
; SROA-NEXT:    ret { i8 addrspace(200)* } [[DOTFCA_0_INSERT]]
;
entry:
  %retval = alloca %struct.addrinfo, align 16, addrspace(200)
  %a.addr = alloca i8 addrspace(200)*, align 16, addrspace(200)
  store i8 addrspace(200)* %a, i8 addrspace(200)* addrspace(200)* %a.addr, align 16
  %0 = bitcast %struct.addrinfo addrspace(200)* %retval to i8 addrspace(200)*
  %1 = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %a.addr, align 16
  call void @llvm.memmove.p200i8.p200i8.i64(i8 addrspace(200)* align 16 %0, i8 addrspace(200)* align 1 %1, i64 16, i1 false)
  %coerce.dive = getelementptr inbounds %struct.addrinfo, %struct.addrinfo addrspace(200)* %retval, i32 0, i32 0
  %2 = bitcast i8 addrspace(200)* addrspace(200)* %coerce.dive to { i8 addrspace(200)* } addrspace(200)*
  %3 = load { i8 addrspace(200)* }, { i8 addrspace(200)* } addrspace(200)* %2, align 16
  ret { i8 addrspace(200)* } %3
}
; CHECK-LABEL: do_not_split_cap_memmove:
; Converted to a memcpy to the stack
; WITH-SROA:	clcbi	$c12, %capcall20(memcpy)($c1)
; WITHOUT-SROA:	clcbi	$c12, %capcall20(memmove)($c1)
; CHECK-DAG:	csetbounds	$c3, $c{{3|11}}, 16
; CHECK-DAG:	cjalr	$c12, $c17
; CHECK-DAG:	daddiu	$4, $zero, 16
; CHECK: cjr $c17

attributes #0 = { noinline nounwind }
attributes #1 = { argmemonly nounwind }
