; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: sed 's/addrspace(200)/addrspace(0)/g' %s | %cheri128_llc -target-abi n64 -o - -verify-machineinstrs | FileCheck %s -check-prefix MIPS
; RUN: %cheri_purecap_llc -o - %s -verify-machineinstrs | %cheri_FileCheck %s -check-prefix CHERI

%struct.au_mask = type {}
%struct.tokenstr = type { i8, i8*, i64, %union.anon }
%union.anon = type { %struct.au_execarg_t }
%struct.au_execarg_t = type { i32, [128 x i8 addrspace(200)*] }

@maskp = external addrspace(200) global %struct.au_mask

define i32 @select_hdr32(%struct.tokenstr addrspace(200)* byval(%struct.tokenstr), i32 addrspace(200)* %optchkd) nounwind {
; MIPS-LABEL: select_hdr32:
; MIPS:       # %bb.0: # %entry
; MIPS-NEXT:    daddiu $sp, $sp, -[[#STACKFRAME_SIZE:]]
; MIPS-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $4, 16($sp)
; MIPS-NEXT:    sd $11, 72($sp)
; MIPS-NEXT:    sd $10, 64($sp)
; MIPS-NEXT:    sd $9, 56($sp)
; MIPS-NEXT:    sd $8, 48($sp)
; MIPS-NEXT:    sd $7, 40($sp)
; MIPS-NEXT:    sd $6, 32($sp)
; MIPS-NEXT:    sd $5, 24($sp)
; MIPS-NEXT:    lh $4, 16($sp)
; MIPS-NEXT:    lui $1, %highest(maskp)
; MIPS-NEXT:    daddiu $1, $1, %higher(maskp)
; MIPS-NEXT:    dsll $1, $1, 16
; MIPS-NEXT:    daddiu $1, $1, %hi(maskp)
; MIPS-NEXT:    dsll $1, $1, 16
; MIPS-NEXT:    daddiu $5, $1, %lo(maskp)
; MIPS-NEXT:    daddiu $6, $zero, 3
; MIPS-NEXT:    jal au_preselect
; MIPS-NEXT:    daddiu $7, $zero, 0
; MIPS-NEXT:    addiu $2, $zero, 0
; MIPS-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; MIPS-NEXT:    jr $ra
; MIPS-NEXT:    daddiu $sp, $sp, [[#STACKFRAME_SIZE]]
;
; CHERI-LABEL: select_hdr32:
; CHERI:       # %bb.0: # %entry
; CHERI-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; CHERI-NEXT:    csc $c17, $zero, 0($c11)
; CHERI-NEXT:    clh $4, $zero, 16($c11)
; CHERI-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHERI-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHERI-NEXT:    cgetpccincoffset $c1, $1
; CHERI-NEXT:    clcbi $c3, %captab20(maskp)($c1)
; CHERI-NEXT:    clcbi $c12, %capcall20(au_preselect)($c1)
; CHERI-NEXT:    daddiu $5, $zero, 3
; CHERI-NEXT:    cjalr $c12, $c17
; CHERI-NEXT:    daddiu $6, $zero, 0
; CHERI-NEXT:    addiu $2, $zero, 0
; CHERI-NEXT:    clc $c17, $zero, 0($c11)
; CHERI-NEXT:    cjr $c17
; CHERI-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
entry:
  %1 = getelementptr %struct.tokenstr, %struct.tokenstr addrspace(200)* %0, i64 0, i32 0
  %tok.sroa.1.0..sroa_idx = getelementptr i8, i8 addrspace(200)* %1
  %tok.sroa.1.0..sroa_cast = bitcast i8 addrspace(200)* %tok.sroa.1.0..sroa_idx to i16 addrspace(200)*
  %tok.sroa.1.0.copyload = load i16, i16 addrspace(200)* %tok.sroa.1.0..sroa_cast
  %call26 = call i32 @au_preselect(i16 %tok.sroa.1.0.copyload, %struct.au_mask addrspace(200)* @maskp, i32 3, i32 0)
  ret i32 0
}

define i32 @foo(i512 addrspace(200)* byval %x, %struct.tokenstr addrspace(200)* byval(%struct.tokenstr), i32 addrspace(200)* %optchkd) nounwind {
; MIPS-LABEL: foo:
; MIPS:       # %bb.0: # %entry
; MIPS-NEXT:    daddiu $sp, $sp, -[[#STACKFRAME_SIZE:]]
; MIPS-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $11, 72($sp)
; MIPS-NEXT:    sd $10, 64($sp)
; MIPS-NEXT:    sd $9, 56($sp)
; MIPS-NEXT:    sd $8, 48($sp)
; MIPS-NEXT:    sd $7, 40($sp)
; MIPS-NEXT:    sd $6, 32($sp)
; MIPS-NEXT:    lh $1, 80($sp)
; MIPS-NEXT:    sd $5, 24($sp)
; MIPS-NEXT:    sd $4, 16($sp)
; MIPS-NEXT:    lui $2, %highest(maskp)
; MIPS-NEXT:    daddiu $2, $2, %higher(maskp)
; MIPS-NEXT:    dsll $2, $2, 16
; MIPS-NEXT:    daddiu $2, $2, %hi(maskp)
; MIPS-NEXT:    dsll $2, $2, 16
; MIPS-NEXT:    daddiu $5, $2, %lo(maskp)
; MIPS-NEXT:    daddiu $6, $zero, 3
; MIPS-NEXT:    daddiu $7, $zero, 0
; MIPS-NEXT:    jal au_preselect
; MIPS-NEXT:    move $4, $1
; MIPS-NEXT:    addiu $2, $zero, 0
; MIPS-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; MIPS-NEXT:    jr $ra
; MIPS-NEXT:    daddiu $sp, $sp, [[#STACKFRAME_SIZE]]
;
; CHERI-LABEL: foo:
; CHERI:       # %bb.0: # %entry
; CHERI-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; CHERI-NEXT:    csc $c17, $zero, [[#STACKFRAME_SIZE - CAP_SIZE]]($c11)
; CHERI-NEXT:    clh $4, $zero, 96($c11)
; CHERI-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHERI-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHERI-NEXT:    cgetpccincoffset $c1, $1
; CHERI-NEXT:    clcbi $c3, %captab20(maskp)($c1)
; CHERI-NEXT:    clcbi $c12, %capcall20(au_preselect)($c1)
; CHERI-NEXT:    daddiu $5, $zero, 3
; CHERI-NEXT:    cjalr $c12, $c17
; CHERI-NEXT:    daddiu $6, $zero, 0
; CHERI-NEXT:    addiu $2, $zero, 0
; CHERI-NEXT:    clc $c17, $zero, [[#STACKFRAME_SIZE - CAP_SIZE]]($c11)
; CHERI-NEXT:    cjr $c17
; CHERI-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
entry:
  %1 = getelementptr %struct.tokenstr, %struct.tokenstr addrspace(200)* %0, i64 0, i32 0
  %tok.sroa.1.0..sroa_idx = getelementptr i8, i8 addrspace(200)* %1
  %tok.sroa.1.0..sroa_cast = bitcast i8 addrspace(200)* %tok.sroa.1.0..sroa_idx to i16 addrspace(200)*
  %tok.sroa.1.0.copyload = load i16, i16 addrspace(200)* %tok.sroa.1.0..sroa_cast
  %call26 = call i32 @au_preselect(i16 %tok.sroa.1.0.copyload, %struct.au_mask addrspace(200)* @maskp, i32 3, i32 0)
  ret i32 0
}

declare i32 @au_preselect(i16 signext, %struct.au_mask addrspace(200)*, i32, i32)

attributes #0 = { align=4 }
