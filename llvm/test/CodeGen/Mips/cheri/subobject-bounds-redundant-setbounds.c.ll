; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; REQUIRES: asserts
; RUN: rm -f %t.dbg-opt %t.dbg-llc
; RUN: %cheri_purecap_opt -cheri-bound-allocas -debug-only=cheri-bound-allocas -S -o - %s 2>%t.dbg-opt | FileCheck %s
; RUN: FileCheck %s -input-file=%t.dbg-opt -check-prefix DBG
; RUN: %cheri_purecap_llc -debug-only=cheri-bound-allocas -o - %s 2>%t.dbg-llc | %cheri_FileCheck %s -check-prefix ASM
; RUN: FileCheck %s -input-file=%t.dbg-llc -check-prefix DBG

; created from the following C source code (when compiled with subobject bounds):
; void use(void* arg);
;
;void use_inline(int* arg) {
;  *arg = 2;
;}
;
;int stack_array() {
;  int array[10];
;  use(array);
;  return array[5];
;}
;
;int stack_int() {
;  int value = 1;
;  use(&value);
;  return value;
;}
;
;int stack_int_inlined() {
;  int value = 1;
;  use_inline(&value);
;  return value;
;}

target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
target triple = "cheri-unknown-freebsd"

; Function Attrs: norecurse nounwind writeonly
define void @use_inline(i32 addrspace(200)* nocapture %arg) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: @use_inline(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 2, i32 addrspace(200)* [[ARG:%.*]], align 4
; CHECK-NEXT:    ret void
;
; ASM-LABEL: use_inline:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    addiu $1, $zero, 2
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    csw $1, $zero, 0($c3)
entry:
  store i32 2, i32 addrspace(200)* %arg, align 4
  ret void
}

; Function Attrs: nounwind
define signext i32 @stack_array() local_unnamed_addr addrspace(200) #1 {
; CHECK-LABEL: @stack_array(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[ARRAY:%.*]] = alloca [10 x i32], align 4, addrspace(200)
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast [10 x i32] addrspace(200)* [[ARRAY]] to i8 addrspace(200)*
; CHECK-NEXT:    call void @llvm.lifetime.start.p200i8(i64 40, i8 addrspace(200)* nonnull [[TMP0]]) [[ATTR6:#.*]]
; CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 40)
; CHECK-NEXT:    call void @use(i8 addrspace(200)* [[TMP1]]) [[ATTR6]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[TMP1]], i64 20
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[ARRAYIDX]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32 addrspace(200)* [[TMP2]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p200i8(i64 40, i8 addrspace(200)* nonnull [[TMP0]]) [[ATTR6]]
; CHECK-NEXT:    ret i32 [[TMP3]]
;
; ASM-LABEL: stack_array:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    csc $c18, $zero, [[#CAP_SIZE * 4]]($c11)
; ASM-NEXT:    csc $c17, $zero, [[#CAP_SIZE * 3]]($c11)
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    cincoffset $c2, $c11, 8
; ASM-NEXT:    csetbounds $c18, $c2, 40
; ASM-NEXT:    clcbi $c12, %capcall20(use)($c1)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cmove $c3, $c18
; ASM-NEXT:    clw $2, $zero, 20($c18)
; ASM-NEXT:    clc $c17, $zero, [[#CAP_SIZE * 3]]($c11)
; ASM-NEXT:    clc $c18, $zero, [[#CAP_SIZE * 4]]($c11)
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
entry:
  %array = alloca [10 x i32], align 4, addrspace(200)
  %0 = bitcast [10 x i32] addrspace(200)* %array to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 40, i8 addrspace(200)* nonnull %0) #6
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 40)
  call void @use(i8 addrspace(200)* %1) #6
  %arrayidx = getelementptr inbounds i8, i8 addrspace(200)* %1, i64 20
  %2 = bitcast i8 addrspace(200)* %arrayidx to i32 addrspace(200)*
  %3 = load i32, i32 addrspace(200)* %2, align 4
  call void @llvm.lifetime.end.p200i8(i64 40, i8 addrspace(200)* nonnull %0) #6
  ret i32 %3
}

; DBG-LABEL: Checking function stack_array
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast [10 x i32] addrspace(200)* %array to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.end.p200i8(i64 40, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for use in setbounds with smaller or equal size: original size=40, setbounds size=40 current offset=0:  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 40)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200i8(i64 40, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %0 = bitcast [10 x i32] addrspace(200)* %array to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: stack_array: 0 of 1 users need bounds for   %array = alloca [10 x i32], align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %array = alloca [10 x i32], align 4, addrspace(200)
; DBG-EMPTY:

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.start.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200) #2

declare void @use(i8 addrspace(200)*) local_unnamed_addr addrspace(200) #3

; Function Attrs: nounwind readnone
declare i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)*, i64) addrspace(200) #4

; Function Attrs: argmemonly nounwind
declare void @llvm.lifetime.end.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200) #2

; Function Attrs: nounwind
define signext i32 @stack_int() local_unnamed_addr addrspace(200) #1 {
; CHECK-LABEL: @stack_int(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VALUE:%.*]] = alloca i32, align 4, addrspace(200)
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[VALUE]] to i8 addrspace(200)*
; CHECK-NEXT:    call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull [[TMP0]]) [[ATTR6]]
; CHECK-NEXT:    store i32 1, i32 addrspace(200)* [[VALUE]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 4)
; CHECK-NEXT:    call void @use(i8 addrspace(200)* [[TMP1]]) [[ATTR6]]
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32 addrspace(200)* [[VALUE]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull [[TMP0]]) [[ATTR6]]
; CHECK-NEXT:    ret i32 [[TMP2]]
;
; ASM-LABEL: stack_int:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    csc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    addiu $1, $zero, 1
; ASM-NEXT:    csw $1, $zero, 12($c11)
; ASM-NEXT:    cincoffset $c2, $c11, 12
; ASM-NEXT:    clcbi $c12, %capcall20(use)($c1)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    csetbounds $c3, $c2, 4
; ASM-NEXT:    clw $2, $zero, 12($c11)
; ASM-NEXT:    clc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
entry:
  %value = alloca i32, align 4, addrspace(200)
  %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull %0) #6
  store i32 1, i32 addrspace(200)* %value, align 4
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 4)
  call void @use(i8 addrspace(200)* %1) #6
  %2 = load i32, i32 addrspace(200)* %value, align 4
  call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull %0) #6
  ret i32 %2
}

; DBG-LABEL: Checking function stack_int
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store i32 1, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   store i32 1, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for use in setbounds with smaller or equal size: original size=4, setbounds size=4 current offset=0:  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 4)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: stack_int: 0 of 3 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:


; Function Attrs: nounwind writeonly
define signext i32 @stack_int_inlined() local_unnamed_addr addrspace(200) #5 {
; CHECK-LABEL: @stack_int_inlined(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VALUE:%.*]] = alloca i32, align 4, addrspace(200)
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[VALUE]] to i8 addrspace(200)*
; CHECK-NEXT:    call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull [[TMP0]]) [[ATTR6]]
; CHECK-NEXT:    store i32 1, i32 addrspace(200)* [[VALUE]], align 4
; CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 4)
; CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP1]] to i32 addrspace(200)*
; CHECK-NEXT:    store i32 2, i32 addrspace(200)* [[ADDRESS_WITH_BOUNDS]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32 addrspace(200)* [[VALUE]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull [[TMP0]]) [[ATTR6]]
; CHECK-NEXT:    ret i32 [[TMP2]]
;
; ASM-LABEL: stack_int_inlined:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    addiu $1, $zero, 1
; ASM-NEXT:    csw $1, $zero, 12($c11)
; ASM-NEXT:    cincoffset $c1, $c11, 12
; ASM-NEXT:    csetbounds $c1, $c1, 4
; ASM-NEXT:    addiu $1, $zero, 2
; ASM-NEXT:    csw $1, $zero, 0($c1)
; ASM-NEXT:    clw $2, $zero, 12($c11)
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
entry:
  %value = alloca i32, align 4, addrspace(200)
  %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull %0) #6
  store i32 1, i32 addrspace(200)* %value, align 4
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 4)
  %address.with.bounds = bitcast i8 addrspace(200)* %1 to i32 addrspace(200)*
  store i32 2, i32 addrspace(200)* %address.with.bounds, align 4
  %2 = load i32, i32 addrspace(200)* %value, align 4
  call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull %0) #6
  ret i32 %2
}

; DBG-LABEL: Checking function stack_int_inlined
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store i32 1, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   store i32 1, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for use in setbounds with smaller or equal size: original size=4, setbounds size=4 current offset=0:  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 4)
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* nonnull %0)
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: stack_int_inlined: 0 of 3 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

define signext i32 @out_of_bounds_setbounds() local_unnamed_addr addrspace(200) #5 {
; ASM-LABEL: out_of_bounds_setbounds:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    cincoffset $c1, $c11, 12
; ASM-NEXT:    csetbounds $c1, $c1, 4
; ASM-NEXT:    csetbounds $c1, $c1, 5
; ASM-NEXT:    addiu $1, $zero, 2
; ASM-NEXT:    csw $1, $zero, 0($c1)
; ASM-NEXT:    clw $2, $zero, 12($c11)
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
; CHECK-LABEL: @out_of_bounds_setbounds(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VALUE:%.*]] = alloca i32, align 4, addrspace(200)
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[VALUE]] to i8 addrspace(200)*
; CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.bounded.stack.cap.i64(i8 addrspace(200)* [[TMP0]], i64 4)
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[TMP1]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i32 addrspace(200)* [[TMP2]] to i8 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP3]], i64 5)
; CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP4]] to i32 addrspace(200)*
; CHECK-NEXT:    store i32 2, i32 addrspace(200)* [[ADDRESS_WITH_BOUNDS]], align 4
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32 addrspace(200)* [[VALUE]], align 4
; CHECK-NEXT:    ret i32 [[TMP5]]
;
entry:
  %value = alloca i32, align 4, addrspace(200)
  ; TOO big, cannot elide the setbonds:
  %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 5)
  %address.with.bounds = bitcast i8 addrspace(200)* %1 to i32 addrspace(200)*
  store i32 2, i32 addrspace(200)* %address.with.bounds, align 4
  %2 = load i32, i32 addrspace(200)* %value, align 4
  ret i32 %2
}

; DBG-NEXT: Checking function out_of_bounds_setbounds
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -out_of_bounds_setbounds: setbounds use offset OUT OF BOUNDS and will trap -> adding csetbounds:   %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 5)
; DBG-NEXT: cheri-bound-allocas:  -Adding stack bounds since bitcast user needs bounds:   %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 5)
; DBG-NEXT: cheri-bound-allocas: Found alloca use that needs bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: out_of_bounds_setbounds: 1 of 2 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: out_of_bounds_setbounds: setting bounds on stack alloca to 4  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

define signext i32 @setbounds_escapes() local_unnamed_addr addrspace(200) #5 {
; ASM-LABEL: setbounds_escapes:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    csc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    cincoffset $c2, $c11, 12
; ASM-NEXT:    csetbounds $c3, $c2, 4
; ASM-NEXT:    addiu $1, $zero, 2
; ASM-NEXT:    csw $1, $zero, 0($c3)
; ASM-NEXT:    clcbi $c12, %capcall20(use)($c1)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    nop
; ASM-NEXT:    clw $2, $zero, 12($c11)
; ASM-NEXT:    clc $c17, $zero, [[#CAP_SIZE * 1]]($c11)
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
; CHECK-LABEL: @setbounds_escapes(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[VALUE:%.*]] = alloca i32, align 4, addrspace(200)
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast i32 addrspace(200)* [[VALUE]] to i8 addrspace(200)*
; CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[TMP0]], i64 4)
; CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = bitcast i8 addrspace(200)* [[TMP1]] to i32 addrspace(200)*
; CHECK-NEXT:    store i32 2, i32 addrspace(200)* [[ADDRESS_WITH_BOUNDS]], align 4
; CHECK-NEXT:    call void @use(i8 addrspace(200)* [[TMP1]])
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, i32 addrspace(200)* [[VALUE]], align 4
; CHECK-NEXT:    ret i32 [[TMP2]]
;
entry:
  %value = alloca i32, align 4, addrspace(200)
  ; TOO big, cannot elide the setbonds:
  %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 4)
  %address.with.bounds = bitcast i8 addrspace(200)* %1 to i32 addrspace(200)*
  store i32 2, i32 addrspace(200)* %address.with.bounds, align 4
  call void @use(i8 addrspace(200)* %1)
  %2 = load i32, i32 addrspace(200)* %value, align 4
  ret i32 %2
}

; DBG-NEXT: Checking function setbounds_escapes
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %2 = load i32, i32 addrspace(200)* %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -No need for stack bounds for use in setbounds with smaller or equal size: original size=4, setbounds size=4 current offset=0:  %1 = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %0, i64 4)
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %0 = bitcast i32 addrspace(200)* %value to i8 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas: setbounds_escapes: 0 of 2 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

define void @assume_aligned() local_unnamed_addr addrspace(200) nounwind {
; CHECK-LABEL: @assume_aligned(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP0:%.*]] = alloca [4 x i8], align 4, addrspace(200)
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"([4 x i8] addrspace(200)* [[TMP0]], i64 4) ]
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast [4 x i8] addrspace(200)* [[TMP0]] to i32 addrspace(200)*
; CHECK-NEXT:    store i32 1, i32 addrspace(200)* [[TMP1]], align 4
; CHECK-NEXT:    ret void
;
entry:
  %0 = alloca [4 x i8], align 4, addrspace(200)
  call void @llvm.assume(i1 true) [ "align"([4 x i8] addrspace(200)* %0, i64 4) ]
  %1 = bitcast [4 x i8] addrspace(200)* %0 to i32 addrspace(200)*
  store i32 1, i32 addrspace(200)* %1
  ret void
}

; DBG-NEXT: Checking function assume_aligned
; DBG-NEXT: cheri-bound-allocas:  -Checking if bitcast needs stack bounds:   %1 = bitcast [4 x i8] addrspace(200)* %0 to i32 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:   -Checking if load/store needs bounds (GEP offset is 0):   store i32 1, i32 addrspace(200)* %1, align 4
; DBG-NEXT: cheri-bound-allocas:    -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:    -Load/store is in bounds -> can reuse $csp for   store i32 1, i32 addrspace(200)* %1, align 4
; DBG-NEXT: cheri-bound-allocas:  -no bitcast users need bounds:   %1 = bitcast [4 x i8] addrspace(200)* %0 to i32 addrspace(200)*
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for assume:   call void @llvm.assume(i1 true) [ "align"([4 x i8] addrspace(200)* %0, i64 4) ]
; DBG-NEXT: cheri-bound-allocas: assume_aligned: 0 of 2 users need bounds for   %0 = alloca [4 x i8], align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %0 = alloca [4 x i8], align 4, addrspace(200)
; DBG-EMPTY:

declare void @llvm.assume(i1) addrspace(200) #1

attributes #0 = { norecurse nounwind writeonly }
attributes #1 = { nounwind }
attributes #2 = { argmemonly nounwind }
attributes #3 = { nounwind }
attributes #4 = { nounwind readnone }
attributes #5 = { nounwind writeonly }
attributes #6 = { nounwind }

