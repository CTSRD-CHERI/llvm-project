; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri128_purecap_llc -O0 %s -o - | FileCheck %s
; RUN: %cheri256_purecap_llc -O0 %s -o - | FileCheck %s -check-prefix CHERI256
; Reduced test case for index.c no longer compiling after memset optimization
; See https://github.com/CTSRD-CHERI/llvm/issues/265
%struct.am = type { %struct.n, %struct.m, [8 x i8] }
%struct.n = type { %struct.n addrspace(200)* }
%struct.m = type { i32, i32, i8, i8, i8, i8, i8, i32, i32 }

@q = common addrspace(200) global %struct.am zeroinitializer, align 16
@p = common addrspace(200) global %struct.am zeroinitializer, align 16

; Function Attrs: noinline nounwind optnone
define void @r() #0 {
; CHECK-LABEL: r:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c2, %captab20(q)($c1)
; CHECK-NEXT:    clcbi $c1, %captab20(p)($c1)
; CHECK-NEXT:    cld $1, $zero, 32($c1)
; CHECK-NEXT:    csd $1, $zero, 32($c2)
; CHECK-NEXT:    clc $c1, $zero, 16($c1)
; CHECK-NEXT:    csc $c1, $zero, 16($c2)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
;
; CHERI256-LABEL: r:
; CHERI256:       # %bb.0:
; CHERI256-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHERI256-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHERI256-NEXT:    cgetpccincoffset $c1, $1
; CHERI256-NEXT:    clcbi $c2, %captab20(q)($c1)
; CHERI256-NEXT:    clcbi $c1, %captab20(p)($c1)
; CHERI256-NEXT:    cld $1, $zero, 48($c1)
; CHERI256-NEXT:    csd $1, $zero, 48($c2)
; CHERI256-NEXT:    cld $1, $zero, 40($c1)
; CHERI256-NEXT:    csd $1, $zero, 40($c2)
; CHERI256-NEXT:    cld $1, $zero, 32($c1)
; CHERI256-NEXT:    csd $1, $zero, 32($c2)
; CHERI256-NEXT:    cjr $c17
; CHERI256-NEXT:    nop
  call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 bitcast (%struct.m addrspace(200)* getelementptr inbounds (%struct.am, %struct.am addrspace(200)* @q, i32 0, i32 1) to i8 addrspace(200)*), i8 addrspace(200)* align 16 bitcast (%struct.m addrspace(200)* getelementptr inbounds (%struct.am, %struct.am addrspace(200)* @p, i32 0, i32 1) to i8 addrspace(200)*), i64 24, i1 false)
; Check that we do a 24-byte copy as a capability load/store followed by a double load / store

  ret void
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* nocapture writeonly, i8 addrspace(200)* nocapture readonly, i64, i1) #1

attributes #0 = { noinline nounwind optnone }
attributes #1 = { argmemonly nounwind }
