; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: %cheri128_opt -instcombine -o - -S %s -data-layout="Eme-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128" | FileCheck %s -check-prefix CHERI128
; RUN: %cheri128_opt -data-layout="Eme-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128" -o - \
; RUN:     -O2 -S %s | %cheri128_llc - -o - | FileCheck %s -check-prefixes ASM,N64-CHERI128-BAD-CODE

; source_filename = "/Users/alex/cheri/llvm/tools/clang/test/CodeGen/cheri/libcxx-filesystem-crash.cpp-reduce.ll"
; target datalayout = "Eme-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128"
; target datalayout = "Eme-pf200:256:256:256:64-i8:8:32-i16:16:32-i64:64-n32:64-S128"

%class.duration = type { i128 }

; Previously this input would result in an invalid ptrtoint instruction and a crash for CHERI128 (CHERI256 works fine)
; TODO: On CHERI we convert the memcpy to a i8 addrspace(200)* load/store which results in worse output assembly

define i128 @test2(%class.duration* dereferenceable(16) %e) local_unnamed_addr nounwind {
; CHERI128-LABEL: @test2(
; CHERI128-NEXT:  entry:
; CHERI128-NEXT:    [[REF_TMP:%.*]] = alloca i8 addrspace(200)*, align 16
; CHERI128-NEXT:    [[TMPCAST:%.*]] = bitcast i8 addrspace(200)** [[REF_TMP]] to %class.duration*
; CHERI128-NEXT:    [[TMP0:%.*]] = bitcast %class.duration* [[E:%.*]] to i8 addrspace(200)**
; CHERI128-NEXT:    [[TMP1:%.*]] = load i8 addrspace(200)*, i8 addrspace(200)** [[TMP0]], align 16
; CHERI128-NEXT:    store i8 addrspace(200)* [[TMP1]], i8 addrspace(200)** [[REF_TMP]], align 16
; CHERI128-NEXT:    [[CALL:%.*]] = call i128 @_ZN8durationInE1fEv(%class.duration* nonnull [[TMPCAST]])
; CHERI128-NEXT:    ret i128 [[CALL]]
;
entry:
  %ref.tmp = alloca %class.duration, align 16
  %0 = bitcast %class.duration* %ref.tmp to i8*
  %1 = bitcast %class.duration* %e to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %0, i8* align 16 %1, i64 16, i1 false)
  %call = call i128 @_ZN8durationInE1fEv(%class.duration* %ref.tmp)
  ret i128 %call
}
; ASM-LABEL: test2:
; ASM:       # %bb.0:
; Currently we spill to the stack and reload for CHERI128
; N64-ASM-NEXT:  ld $2, 0($4)
; N64-ASM-NEXT:  ld $3, 8($4)
; N64-ASM-NEXT:  jr $ra
; N64-ASM-NEXT:  nop
; N64-CHERI128-BAD-CODE-NEXT: daddiu	$sp, $sp, -16
; N64-CHERI128-BAD-CODE-NEXT: clc	$c1, $4, 0($ddc)
; N64-CHERI128-BAD-CODE-NEXT: daddiu	$1, $sp, 0
; N64-CHERI128-BAD-CODE-NEXT: csc	$c1, $1, 0($ddc)
; N64-CHERI128-BAD-CODE-NEXT: ld $2, 0($sp)
; N64-CHERI128-BAD-CODE-NEXT: ld $3, 8($sp)
; N64-CHERI128-BAD-CODE-NEXT: jr $ra
; N64-CHERI128-BAD-CODE-NEXT: daddiu $sp, $sp, 16
; ASM:       .end test2


define i128 @_ZN8durationInE1fEv(%class.duration* %h) {
; CHERI128-LABEL: define i128 @_ZN8durationInE1fEv(
; CHERI128-NEXT:  entry:
; CHERI128-NEXT:    [[AS:%.*]] = getelementptr [[CLASS_DURATION:%.*]], %class.duration* [[H:%.*]], i64 0, i32 0
; CHERI128-NEXT:    [[TMP0:%.*]] = load i128, i128* [[AS]], align 16
; CHERI128-NEXT:    ret i128 [[TMP0]]
;
entry:
  %as = getelementptr %class.duration, %class.duration* %h, i64 0, i32 0
  %0 = load i128, i128* %as, align 16
  ret i128 %0
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1)
declare void @llvm.lifetime.start.p0i8(i64, i8*)
declare void @llvm.lifetime.end.p0i8(i64, i8*)
