; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_purecap_llc -verify-machineinstrs -O0 -o - %s | %cheri_FileCheck %s

; Check that sret of capability tuples does not result in a memcpy
; Similar issue was found compiling rust-derived IR that was generating a LDL instruction for i128.
; Again the sret value is align 1

declare dso_local void @use_tuple_cap(i8 addrspace(200)*) unnamed_addr addrspace(200) #0
declare dso_local void @use_tuple_i64(i64) unnamed_addr addrspace(200) #0
declare dso_local void @use_huge_value(i1024) unnamed_addr addrspace(200) #0

declare dso_local { i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)* } @get_tuple_cap(i8 addrspace(200)*) unnamed_addr addrspace(200) #0
declare dso_local { i64, i64, i64, i64 } @get_tuple_i64(i8 addrspace(200)*) unnamed_addr addrspace(200) #0
declare dso_local i1024 @get_huge_type(i8 addrspace(200)*) unnamed_addr addrspace(200) #0

define internal void @test(i8 addrspace(200)* align 16 dereferenceable(16) %ctr) unnamed_addr addrspace(200) nounwind #0 {
; CHECK-LABEL: test:
; CHECK:       # %bb.0: # %start
; CHECK-NEXT:    cincoffset $c11, $c11, -96
; CHECK-NEXT:    csc $c17, $zero, 80($c11) # 16-byte Folded Spill
; CHECK-NEXT:    cmove $c4, $c3
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    csc $c1, $zero, 0($c11) # 16-byte Folded Spill
; CHECK-NEXT:    clcbi $c12, %capcall20(get_tuple_cap)($c1)
; CHECK-NEXT:    cincoffset $c3, $c11, 16
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clc $c1, $zero, 0($c11) # 16-byte Folded Reload
; CHECK-NEXT:    clc $c3, $zero, 64($c11)
; CHECK-NEXT:    clcbi $c12, %capcall20(use_tuple_cap)($c1)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clc $c17, $zero, 80($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cincoffset $c11, $c11, 96
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
start:
  %0 = call { i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)* } @get_tuple_cap(i8 addrspace(200)* align 16 dereferenceable(16) %ctr)
  %sret = extractvalue { i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)* } %0, 3
  call void @use_tuple_cap(i8 addrspace(200)* %sret)
  ret void
}

define internal void @test2(i8 addrspace(200)* align 16 dereferenceable(16) %ctr) unnamed_addr addrspace(200) nounwind {
; CHECK-LABEL: test2:
; CHECK:       # %bb.0: # %start
; CHECK-NEXT:    cincoffset $c11, $c11, -64
; CHECK-NEXT:    csc $c17, $zero, 48($c11) # 16-byte Folded Spill
; CHECK-NEXT:    cmove $c4, $c3
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    csc $c1, $zero, 0($c11) # 16-byte Folded Spill
; CHECK-NEXT:    clcbi $c12, %capcall20(get_tuple_i64)($c1)
; CHECK-NEXT:    cincoffset $c3, $c11, 16
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clc $c1, $zero, 0($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cld $4, $zero, 40($c11)
; CHECK-NEXT:    clcbi $c12, %capcall20(use_tuple_i64)($c1)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clc $c17, $zero, 48($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cincoffset $c11, $c11, 64
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
start:
  %0 = call { i64, i64, i64, i64 } @get_tuple_i64(i8 addrspace(200)* align 16 dereferenceable(16) %ctr)
  %sret = extractvalue { i64, i64, i64, i64 } %0, 3
  call void @use_tuple_i64(i64 %sret)
  ret void
}

define internal void @test3(i8 addrspace(200)* align 16 dereferenceable(16) %ctr) unnamed_addr addrspace(200) nounwind {
; CHECK-LABEL: test3:
; CHECK:       # %bb.0: # %start
; CHECK-NEXT:    cincoffset $c11, $c11, -240
; CHECK-NEXT:    csc $c17, $zero, 224($c11) # 16-byte Folded Spill
; CHECK-NEXT:    cmove $c4, $c3
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    csc $c1, $zero, 80($c11) # 16-byte Folded Spill
; CHECK-NEXT:    clcbi $c12, %capcall20(get_huge_type)($c1)
; CHECK-NEXT:    cincoffset $c3, $c11, 96
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clc $c1, $zero, 80($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cld $11, $zero, 152($c11)
; CHECK-NEXT:    cld $10, $zero, 144($c11)
; CHECK-NEXT:    cld $9, $zero, 136($c11)
; CHECK-NEXT:    cld $8, $zero, 128($c11)
; CHECK-NEXT:    cld $7, $zero, 120($c11)
; CHECK-NEXT:    cld $6, $zero, 112($c11)
; CHECK-NEXT:    cld $5, $zero, 104($c11)
; CHECK-NEXT:    cld $4, $zero, 96($c11)
; CHECK-NEXT:    cld $1, $zero, 168($c11)
; CHECK-NEXT:    cld $2, $zero, 176($c11)
; CHECK-NEXT:    cld $3, $zero, 184($c11)
; CHECK-NEXT:    cld $12, $zero, 192($c11)
; CHECK-NEXT:    cld $13, $zero, 200($c11)
; CHECK-NEXT:    cld $14, $zero, 208($c11)
; CHECK-NEXT:    cld $15, $zero, 216($c11)
; CHECK-NEXT:    cld $24, $zero, 160($c11)
; CHECK-NEXT:    cmove $c2, $c11
; CHECK-NEXT:    csd $24, $zero, 0($c2)
; CHECK-NEXT:    csd $15, $zero, 56($c2)
; CHECK-NEXT:    csd $14, $zero, 48($c2)
; CHECK-NEXT:    csd $13, $zero, 40($c2)
; CHECK-NEXT:    csd $12, $zero, 32($c2)
; CHECK-NEXT:    csd $3, $zero, 24($c2)
; CHECK-NEXT:    csd $2, $zero, 16($c2)
; CHECK-NEXT:    csd $1, $zero, 8($c2)
; CHECK-NEXT:    csetbounds $c2, $c2, 64
; CHECK-NEXT:    ori $1, $zero, 65495
; CHECK-NEXT:    candperm $c13, $c2, $1
; CHECK-NEXT:    clcbi $c12, %capcall20(use_huge_value)($c1)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clc $c17, $zero, 224($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cincoffset $c11, $c11, 240
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
start:
  %0 = call i1024 @get_huge_type(i8 addrspace(200)* align 16 dereferenceable(16) %ctr)
  call void @use_huge_value(i1024 %0)
  ret void
}

define internal { i64, i64, i64, i64 } @get_tuple_i64_impl() unnamed_addr addrspace(200) nounwind {
; CHECK-LABEL: get_tuple_i64_impl:
; CHECK:       # %bb.0:
; CHECK-NEXT:    # kill: def $c1 killed $c3
; CHECK-NEXT:    daddiu $1, $zero, 10
; CHECK-NEXT:    csd $1, $zero, 0($c3)
; CHECK-NEXT:    daddiu $1, $zero, 40
; CHECK-NEXT:    csd $1, $zero, 24($c3)
; CHECK-NEXT:    daddiu $1, $zero, 30
; CHECK-NEXT:    csd $1, $zero, 16($c3)
; CHECK-NEXT:    daddiu $1, $zero, 20
; CHECK-NEXT:    csd $1, $zero, 8($c3)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
  ret { i64, i64, i64, i64 } { i64 10,  i64 20,  i64 30, i64 40 }
}

define internal { i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)* } @get_tuple_cap_impl() unnamed_addr addrspace(200) nounwind {
; CHECK-LABEL: get_tuple_cap_impl:
; CHECK:       # %bb.0:
; CHECK-NEXT:    # kill: def $c1 killed $c3
; CHECK-NEXT:    cincoffset $c1, $cnull, 10
; CHECK-NEXT:    csc $c1, $zero, 0($c3)
; CHECK-NEXT:    cincoffset $c1, $cnull, 40
; CHECK-NEXT:    csc $c1, $zero, 48($c3)
; CHECK-NEXT:    cincoffset $c1, $cnull, 30
; CHECK-NEXT:    csc $c1, $zero, 32($c3)
; CHECK-NEXT:    cincoffset $c1, $cnull, 20
; CHECK-NEXT:    csc $c1, $zero, 16($c3)
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
  ret { i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)*, i8 addrspace(200)* } {
     i8 addrspace(200)* inttoptr (i64 10 to i8 addrspace(200)*),
     i8 addrspace(200)* inttoptr (i64 20 to i8 addrspace(200)*),
     i8 addrspace(200)* inttoptr (i64 30 to i8 addrspace(200)*),
     i8 addrspace(200)* inttoptr (i64 40 to i8 addrspace(200)*)
  }
}
