; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUNs: %cheri128_purecap_opt -data-layout="E-m:m-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200" -atomic-expand -S -cheri-cap-table-abi=pcrel %s -o - -debug-only=atomic-expand -print-before-all
; RUNs: %cheri128_purecap_opt -data-layout="E-m:m-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200" -atomic-expand -S -cheri-cap-table-abi=pcrel %s -o - -debug-only=atomic-expand -print-before-all
; RUsN: %cheri_purecap_llc -cheri-cap-table-abi=pcrel %s -o - -O0 -print-before=atomic-expand -print-after=atomic-expand -debug-only=atomic-expand
; RUN: %cheri_purecap_llc -verify-machineinstrs -cheri-cap-table-abi=pcrel %s -o - -O2 | FileCheck %s
; TODO: | FileCheck %s -enable-var-scope
; ModuleID = 'atomic.c'

@cap = common addrspace(200) global ptr addrspace(200) null, align 32

declare void @test(ptr addrspace(200) nocapture, i1)

define i32 @cmpxchg_cap(ptr addrspace(200) nocapture %exp, ptr addrspace(200) %newval) nounwind {
; CHECK-LABEL: cmpxchg_cap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -16
; CHECK-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c2, $1
; CHECK-NEXT:    clcbi $c5, %captab20(cap)($c2)
; CHECK-NEXT:    sync
; CHECK-NEXT:  .LBB0_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c5
; CHECK-NEXT:    ceq $1, $c1, $c3
; CHECK-NEXT:    beqz $1, .LBB0_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB0_1 Depth=1
; CHECK-NEXT:    cscc $1, $c4, $c5
; CHECK-NEXT:    beqz $1, .LBB0_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB0_3: # %entry
; CHECK-NEXT:    ceq $4, $c1, $c3
; CHECK-NEXT:    sync
; CHECK-NEXT:    clcbi $c12, %capcall20(test)($c2)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    cmove $c3, $c1
; CHECK-NEXT:    addiu $2, $zero, 42
; CHECK-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 16
entry:
  %0 = cmpxchg ptr addrspace(200) @cap, ptr addrspace(200) %exp, ptr addrspace(200) %newval seq_cst seq_cst, align 16
  %1 = extractvalue { ptr addrspace(200), i1 } %0, 0
  %2 = extractvalue { ptr addrspace(200), i1 } %0, 1
  call void @test(ptr addrspace(200) nocapture %1, i1 %2)
  ret i32 42
}

define ptr addrspace(200) @atomic_fetch_swap_cap(ptr addrspace(200) %x) nounwind {
; CHECK-LABEL: atomic_fetch_swap_cap:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c2, %captab20(cap)($c1)
; CHECK-NEXT:  .LBB1_1: # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c2
; CHECK-NEXT:    cscc $1, $c3, $c2
; CHECK-NEXT:    beqz $1, .LBB1_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cmove $c3, $c1
  %t1 = atomicrmw xchg ptr addrspace(200) @cap, ptr addrspace(200) %x acquire, align 16
  ret ptr addrspace(200) %t1
}
