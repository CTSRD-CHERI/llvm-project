# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# Check that MachineLICM doesn't hoist a instructions that could potentially trap but are not guaranteed to execute
# FIXME: this is a baseline test showing the current incorrect behaviour
# See also llvm/test/CodeGen/MIPS/machinelicm-hoist.mir for CHERI-MIPS
# See https://github.com/CTSRD-CHERI/llvm-project/issues/348 and https://github.com/CTSRD-CHERI/llvm-project/issues/359
# RUN: %cheri_purecap_llc -o - %s -run-pass=early-machinelicm -avoid-speculation=false -hoist-cheap-insts -machinelicm-ignore-reg-pressure | FileCheck %s
--- |
  ; ModuleID = '/Users/alex/cheri/llvm-project/llvm/test/CodeGen/CHERI-Generic/test.ll'
  source_filename = "/Users/alex/cheri/llvm-project/llvm/test/CodeGen/CHERI-Generic/test.ll"
  target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200"
  target triple = "riscv64-unknown-freebsd"

  %struct.foo = type { i32, i32 }

  ; Function Attrs: nounwind
  define dso_local void @hoist_csetbounds(i64 %arg, %struct.foo addrspace(200)* %f, %struct.foo addrspace(200)* %f2) local_unnamed_addr addrspace(200) #0 {
  entry:
    br label %for.body

  for.cond.cleanup:                                 ; preds = %for.inc
    ret void

  for.body:                                         ; preds = %for.inc, %entry
    br i1 undef, label %for.inc, label %if.then

  if.then:                                          ; preds = %for.body
    br label %for.inc

  for.inc:                                          ; preds = %if.then, %for.body
    br i1 undef, label %for.body, label %for.cond.cleanup
  }

  attributes #0 = { nounwind }
  attributes #1 = { nounwind readnone willreturn }

...
---
name:            hoist_csetbounds
alignment:       4
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
liveins:
  - { reg: '$at_64', virtual-reg: '%0' }
  - { reg: '$c3', virtual-reg: '%1' }
  - { reg: '$c4', virtual-reg: '%2' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  stackProtector:  ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
constants:       []
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: hoist_csetbounds
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $a0_64, $c3, $c4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $a0_64
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:cherigpr = COPY $c3
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:cherigpr = COPY $c4
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:cherigpr = COPY $c4
  ; CHECK-NEXT:   [[CIncOffsetImm:%[0-9]+]]:cherigpr = CIncOffsetImm [[COPY1]], 4
  ; CHECK-NEXT:   [[CAndPerms:%[0-9]+]]:cherigpr = CAndPerms [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CGetPerms:%[0-9]+]]:gpr64 = CGetPerms [[COPY2]]
  ; CHECK-NEXT:   [[CGetType:%[0-9]+]]:gpr64 = CGetType [[COPY2]]
  ; CHECK-NEXT:   [[CGetBase:%[0-9]+]]:gpr64 = CGetBase [[COPY2]]
  ; CHECK-NEXT:   [[CGetLength:%[0-9]+]]:gpr64 = CGetLength [[COPY2]]
  ; CHECK-NEXT:   [[CGetTag:%[0-9]+]]:gpr64 = CGetTag [[COPY2]]
  ; CHECK-NEXT:   [[CGetSealed:%[0-9]+]]:gpr64 = CGetSealed [[COPY2]]
  ; CHECK-NEXT:   [[CGetOffset:%[0-9]+]]:gpr64 = CGetOffset [[COPY2]]
  ; CHECK-NEXT:   [[CGetPCC:%[0-9]+]]:cherigpr = CGetPCC
  ; CHECK-NEXT:   [[CGetAddr:%[0-9]+]]:gpr64 = CGetAddr [[COPY2]]
  ; CHECK-NEXT:   [[CGetAndAddr:%[0-9]+]]:gpr64 = CGetAndAddr [[COPY2]], [[COPY]]
  ; CHECK-NEXT:   [[CGetFlags:%[0-9]+]]:gpr64 = CGetFlags [[COPY2]]
  ; CHECK-NEXT:   [[CClearTag:%[0-9]+]]:cherigpr = CClearTag [[COPY1]]
  ; CHECK-NEXT:   [[CSetPCCOffset:%[0-9]+]]:cherigpr = CSetPCCOffset [[COPY]]
  ; CHECK-NEXT:   [[CGetPCCIncOffset:%[0-9]+]]:cherigpr = CGetPCCIncOffset [[COPY]]
  ; CHECK-NEXT:   [[CGetPCCSetAddr:%[0-9]+]]:cherigpr = CGetPCCSetAddr [[COPY]]
  ; CHECK-NEXT:   [[CSub:%[0-9]+]]:gpr64 = CSub [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CMove:%[0-9]+]]:cherigpr = CMove [[COPY1]]
  ; CHECK-NEXT:   [[CMOVZ:%[0-9]+]]:cherigpr = CMOVZ [[COPY1]], [[COPY]], [[COPY1]]
  ; CHECK-NEXT:   [[CMOVN:%[0-9]+]]:cherigpr = CMOVN [[COPY1]], [[COPY]], [[COPY1]]
  ; CHECK-NEXT:   [[CEQ:%[0-9]+]]:gpr64 = CEQ [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CLT:%[0-9]+]]:gpr64 = CLT [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CLE:%[0-9]+]]:gpr64 = CLE [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CLTU:%[0-9]+]]:gpr64 = CLTU [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CLEU:%[0-9]+]]:gpr64 = CLEU [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CNEXEQ:%[0-9]+]]:gpr64 = CNEXEQ [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CEXEQ:%[0-9]+]]:gpr64 = CEXEQ [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CTestSubset:%[0-9]+]]:gpr64 = CTestSubset [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CRRL:%[0-9]+]]:gpr64 = CRRL [[COPY]]
  ; CHECK-NEXT:   [[CRAM:%[0-9]+]]:gpr64 = CRAM [[COPY]]
  ; CHECK-NEXT:   B %bb.2, implicit-def $at
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.for.cond.cleanup:
  ; CHECK-NEXT:   CapRetPseudo
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.for.body:
  ; CHECK-NEXT:   successors: %bb.4(0x30000000), %bb.3(0x50000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   CBEZ [[COPY1]], %bb.4, implicit-def $at
  ; CHECK-NEXT:   B %bb.3, implicit-def $at
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.if.then:
  ; CHECK-NEXT:   successors: %bb.4(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[CSeal:%[0-9]+]]:cherigpr = CSeal [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CUnSeal:%[0-9]+]]:cherigpr = CUnSeal [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CAndPerms1:%[0-9]+]]:cherigpr = CAndPerms [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetFlags:%[0-9]+]]:cherigpr = CSetFlags [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetOffset:%[0-9]+]]:cherigpr = CSetOffset [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffset:%[0-9]+]]:cherigpr = CIncOffset [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffsetImm1:%[0-9]+]]:cherigpr = CIncOffsetImm [[COPY1]], 10
  ; CHECK-NEXT:   [[CSetBounds:%[0-9]+]]:cherigpr = CSetBounds [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsExact:%[0-9]+]]:cherigpr = CSetBoundsExact [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsImm:%[0-9]+]]:cherigpr = CSetBoundsImm [[COPY1]], 10
  ; CHECK-NEXT:   [[CBuildCap:%[0-9]+]]:cherigpr = CBuildCap [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CCopyType:%[0-9]+]]:cherigpr = CCopyType [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CCSeal:%[0-9]+]]:cherigpr = CCSeal [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CSetAddr:%[0-9]+]]:cherigpr = CSetAddr [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CAndAddr:%[0-9]+]]:cherigpr = CAndAddr [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSealEntry:%[0-9]+]]:cherigpr = CSealEntry [[COPY1]]
  ; CHECK-NEXT:   [[CToPtr:%[0-9]+]]:gpr64 = CToPtr [[COPY1]], [[COPY3]]
  ; CHECK-NEXT:   [[CFromPtr:%[0-9]+]]:cherigpr = CFromPtr [[COPY3]], [[COPY]]
  ; CHECK-NEXT:   [[CGetCause:%[0-9]+]]:gpr64 = CGetCause
  ; CHECK-NEXT:   CSetCause [[COPY]]
  ; CHECK-NEXT:   CCheckPerm [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   CCheckType [[COPY1]], [[COPY2]]
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.for.inc:
  ; CHECK-NEXT:   successors: %bb.2(0x7c000000), %bb.1(0x04000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   CBEZ [[COPY1]], %bb.2, implicit-def $at
  ; CHECK-NEXT:   B %bb.1, implicit-def $at
  bb.0.entry:
    successors: %bb.2(0x80000000)
    liveins: $a0_64, $c3, $c4

    %0:gpr64 = COPY $a0_64
    %1:cherigpr = COPY $c3
    %2:cherigpr = COPY $c4
    %3:cherigpr = COPY $c4
    ; %4 should be known to be unsealed (since CIncOffset succeeded)
    %4:cherigpr = CIncOffsetImm %1, 4
    ; %5 should be known to be tagged and unsealed
    %5:cherigpr = CAndPerms %1, %0


    B %bb.2, implicit-def $at

  bb.1.for.cond.cleanup:
    CapRetPseudo

  bb.2.for.body:
    successors: %bb.4(0x30000000), %bb.3(0x50000000)
    CBEZ %1, %bb.4, implicit-def $at
    B %bb.3, implicit-def $at

  bb.3.if.then:
    successors: %bb.4(0x80000000)
    ; Note: Please keep these in order of the ISA spec definitions
    ; B.1.1: Capability-Inspection Instructions
    %10:gpr64 = CGetPerms %2
    %11:gpr64 = CGetType %2
    %12:gpr64 = CGetBase %2
    %13:gpr64 = CGetLength %2
    %14:gpr64 = CGetTag %2
    %15:gpr64 = CGetSealed %2
    %16:gpr64 = CGetOffset %2
    %18:cherigpr = CGetPCC
    %19:gpr64 = CGetAddr %2
    %20:gpr64 = CGetAndAddr %2, %0
    %21:gpr64 = CGetFlags %2

    ; B.1.2 Capability-Modification Instructions
    ; However, mutators can't since the input could be sealed/untagged/other constraints
    %30:cherigpr = CSeal %1, %2
    %31:cherigpr = CUnSeal %1, %2
    %32:cherigpr = CAndPerms %1, %0
    %33:cherigpr = CSetFlags %1, %0
    %34:cherigpr = CSetOffset %1, %0
    %35:cherigpr = CIncOffset %1, %0
    %36:cherigpr = CIncOffsetImm %1, 10
    %37:cherigpr = CSetBounds %1, %0
    %38:cherigpr = CSetBoundsExact %1, %0
    %39:cherigpr = CSetBoundsImm %1, 10
    %40:cherigpr = CClearTag %1 ; Note: CClearTag can be hoisted since it can't trap
    %41:cherigpr = CBuildCap %1, %2
    %42:cherigpr = CCopyType %1, %2
    %43:cherigpr = CCSeal %1, %2
    %44:cherigpr = CSetAddr %1, %0
    %45:cherigpr = CAndAddr %1, %0
    %46:cherigpr = CSetPCCOffset %0
    %47:cherigpr = CGetPCCIncOffset %0
    %48:cherigpr = CGetPCCSetAddr %0
    %49:cherigpr = CSealEntry %1

    ; B.1.3 Pointer-arithmetic instructions
    %60:gpr64 = CToPtr %1, %3  ; can trap
    %61:cherigpr = CFromPtr %3, %0 ; can trap
    %62:gpr64 = CSub %1, %2 ; never traps
    %63:cherigpr = CMove %1 ; never traps
    %64:cherigpr = CMOVZ %1, %0, %1 ; never traps
    %65:cherigpr = CMOVN %1, %0, %1 ; never traps

    ; B.1.4 Pointer-Comparison Instructions
    %70:gpr64 = CEQ %1, %2
    %71:gpr64 = CLT %1, %2
    %72:gpr64 = CLE %1, %2
    %73:gpr64 = CLTU %1, %2
    %74:gpr64 = CLEU %1, %2
    %75:gpr64 = CNEXEQ %1, %2
    %76:gpr64 = CEXEQ %1, %2

    ; B.1.5 Exception-Handling Instructions
    %80:gpr64 = CGetCause
    CSetCause %0

    ; B.1.6 Control-Flow (not tested here)

    ; B.1.7 Assertion Instructions
    CCheckPerm %1, %0
    CCheckType %1, %2
    ; CCheckTag %1; Exists iIn spec but not implemented in LLVM
    %90:gpr64 = CTestSubset %1, %2

    ; B.1.8 Special-Purpose Register access Instructions
    ;%100:cherigpr = CReadHwr 0
    ;CWriteHwr 0, %1

    ; B.1.9 Fast Register-Clearing Instructions
    ; TODO: find out how to spell the operands in textual MIR
    ; ClearLo
    ; ClearHi
    ; CClearLo
    ; CClearHi

    ; B.1.10Adjusting to Compressed Capability Precision
    %110:gpr64 = CRRL %0
    %111:gpr64 = CRAM %0

  bb.4.for.inc:
    successors: %bb.2(0x7c000000), %bb.1(0x04000000)

    CBEZ %1, %bb.2, implicit-def $at
    B %bb.1, implicit-def $at
...
