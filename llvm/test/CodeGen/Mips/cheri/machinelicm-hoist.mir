# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# Check that MachineLICM doesn't hoist a instructions that could potentially trap but are not guaranteed to execute
# See also llvm/test/CodeGen/RISCV/machinelicm-hoist.mir for CHERI-RISC-V
# See https://github.com/CTSRD-CHERI/llvm-project/issues/348 and https://github.com/CTSRD-CHERI/llvm-project/issues/359
# RUN: %cheri_purecap_llc -o - %s -run-pass=early-machinelicm -avoid-speculation=false -hoist-cheap-insts -machinelicm-ignore-reg-pressure | FileCheck %s
--- |
  ; ModuleID = '/Users/alex/cheri/llvm-project/llvm/test/CodeGen/CHERI-Generic/test.ll'
  source_filename = "/Users/alex/cheri/llvm-project/llvm/test/CodeGen/CHERI-Generic/test.ll"
  target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200"
  target triple = "riscv64-unknown-freebsd"

  %struct.foo = type { i32, i32 }

  ; Function Attrs: nounwind
  define dso_local void @hoist_csetbounds(i64 %arg, %struct.foo addrspace(200)* %f, %struct.foo addrspace(200)* %f2) local_unnamed_addr addrspace(200) #0 {
  entry:
    br label %for.body

  for.cond.cleanup:                                 ; preds = %for.inc
    ret void

  for.body:                                         ; preds = %for.inc, %entry
    br i1 undef, label %for.inc, label %if.then

  if.then:                                          ; preds = %for.body
    br label %for.inc

  for.inc:                                          ; preds = %if.then, %for.body
    br i1 undef, label %for.body, label %for.cond.cleanup
  }

  attributes #0 = { nounwind }
  attributes #1 = { nounwind readnone willreturn }

...
---
name:            hoist_csetbounds
alignment:       4
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
liveins:
  - { reg: '$at_64', virtual-reg: '%0' }
  - { reg: '$c3', virtual-reg: '%1' }
  - { reg: '$c4', virtual-reg: '%2' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  stackProtector:  ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
constants:       []
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: hoist_csetbounds
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $a0_64, $c3, $c4
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $a0_64
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:cherigpr = COPY $c3
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:cherigpr = COPY $c4
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:cherigpr = COPY $c4
  ; CHECK-NEXT:   [[CIncOffsetImm:%[0-9]+]]:cherigpr = CIncOffsetImm [[COPY1]], 4
  ; CHECK-NEXT:   [[CAndPerms:%[0-9]+]]:cherigpr = CAndPerms [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CGetPerms:%[0-9]+]]:gpr64 = CGetPerms [[COPY2]]
  ; CHECK-NEXT:   [[CGetType:%[0-9]+]]:gpr64 = CGetType [[COPY2]]
  ; CHECK-NEXT:   [[CGetBase:%[0-9]+]]:gpr64 = CGetBase [[COPY2]]
  ; CHECK-NEXT:   [[CGetLength:%[0-9]+]]:gpr64 = CGetLength [[COPY2]]
  ; CHECK-NEXT:   [[CGetTag:%[0-9]+]]:gpr64 = CGetTag [[COPY2]]
  ; CHECK-NEXT:   [[CGetSealed:%[0-9]+]]:gpr64 = CGetSealed [[COPY2]]
  ; CHECK-NEXT:   [[CGetOffset:%[0-9]+]]:gpr64 = CGetOffset [[COPY2]]
  ; CHECK-NEXT:   [[CGetPCC:%[0-9]+]]:cherigpr = CGetPCC
  ; CHECK-NEXT:   [[CGetAddr:%[0-9]+]]:gpr64 = CGetAddr [[COPY2]]
  ; CHECK-NEXT:   [[CGetAndAddr:%[0-9]+]]:gpr64 = CGetAndAddr [[COPY2]], [[COPY]]
  ; CHECK-NEXT:   [[CGetFlags:%[0-9]+]]:gpr64 = CGetFlags [[COPY2]]
  ; CHECK-NEXT:   [[CClearTag:%[0-9]+]]:cherigpr = CClearTag [[COPY1]]
  ; CHECK-NEXT:   [[CSetPCCOffset:%[0-9]+]]:cherigpr = CSetPCCOffset [[COPY]]
  ; CHECK-NEXT:   [[CGetPCCIncOffset:%[0-9]+]]:cherigpr = CGetPCCIncOffset [[COPY]]
  ; CHECK-NEXT:   [[CGetPCCSetAddr:%[0-9]+]]:cherigpr = CGetPCCSetAddr [[COPY]]
  ; CHECK-NEXT:   [[CSub:%[0-9]+]]:gpr64 = CSub [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CMove:%[0-9]+]]:cherigpr = CMove [[COPY1]]
  ; CHECK-NEXT:   [[CMOVZ:%[0-9]+]]:cherigpr = CMOVZ [[COPY1]], [[COPY]], [[COPY1]]
  ; CHECK-NEXT:   [[CMOVN:%[0-9]+]]:cherigpr = CMOVN [[COPY1]], [[COPY]], [[COPY1]]
  ; CHECK-NEXT:   [[CEQ:%[0-9]+]]:gpr64 = CEQ [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CLT:%[0-9]+]]:gpr64 = CLT [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CLE:%[0-9]+]]:gpr64 = CLE [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CLTU:%[0-9]+]]:gpr64 = CLTU [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CLEU:%[0-9]+]]:gpr64 = CLEU [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CNEXEQ:%[0-9]+]]:gpr64 = CNEXEQ [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CEXEQ:%[0-9]+]]:gpr64 = CEXEQ [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CTestSubset:%[0-9]+]]:gpr64 = CTestSubset [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CRRL:%[0-9]+]]:gpr64 = CRRL [[COPY]]
  ; CHECK-NEXT:   [[CRAM:%[0-9]+]]:gpr64 = CRAM [[COPY]]
  ; CHECK-NEXT:   [[CSetFlags:%[0-9]+]]:cherigpr = CSetFlags [[CIncOffsetImm]], [[COPY]]
  ; CHECK-NEXT:   [[CSetOffset:%[0-9]+]]:cherigpr = CSetOffset [[CIncOffsetImm]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffset:%[0-9]+]]:cherigpr = CIncOffset [[CIncOffsetImm]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffsetImm1:%[0-9]+]]:cherigpr = CIncOffsetImm [[CIncOffsetImm]], 10
  ; CHECK-NEXT:   [[CClearTag1:%[0-9]+]]:cherigpr = CClearTag [[CIncOffsetImm]]
  ; CHECK-NEXT:   [[CSetAddr:%[0-9]+]]:cherigpr = CSetAddr [[CIncOffsetImm]], [[COPY]]
  ; CHECK-NEXT:   [[CAndAddr:%[0-9]+]]:cherigpr = CAndAddr [[CIncOffsetImm]], [[COPY]]
  ; CHECK-NEXT:   [[CSetFlags1:%[0-9]+]]:cherigpr = CSetFlags [[CAndPerms]], [[COPY]]
  ; CHECK-NEXT:   [[CSetOffset1:%[0-9]+]]:cherigpr = CSetOffset [[CAndPerms]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffset1:%[0-9]+]]:cherigpr = CIncOffset [[CAndPerms]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffsetImm2:%[0-9]+]]:cherigpr = CIncOffsetImm [[CAndPerms]], 10
  ; CHECK-NEXT:   [[CClearTag2:%[0-9]+]]:cherigpr = CClearTag [[CAndPerms]]
  ; CHECK-NEXT:   [[CSetAddr1:%[0-9]+]]:cherigpr = CSetAddr [[CAndPerms]], [[COPY]]
  ; CHECK-NEXT:   [[CAndAddr1:%[0-9]+]]:cherigpr = CAndAddr [[CAndPerms]], [[COPY]]
  ; CHECK-NEXT:   [[CSetFlags2:%[0-9]+]]:cherigpr = CSetFlags $cnull, [[COPY]]
  ; CHECK-NEXT:   [[CSetOffset2:%[0-9]+]]:cherigpr = CSetOffset $cnull, [[COPY]]
  ; CHECK-NEXT:   [[CIncOffset2:%[0-9]+]]:cherigpr = CIncOffset $cnull, [[COPY]]
  ; CHECK-NEXT:   [[CIncOffsetImm3:%[0-9]+]]:cherigpr = CIncOffsetImm $cnull, 10
  ; CHECK-NEXT:   [[CClearTag3:%[0-9]+]]:cherigpr = CClearTag $cnull
  ; CHECK-NEXT:   [[CSetAddr2:%[0-9]+]]:cherigpr = CSetAddr $cnull, [[COPY]]
  ; CHECK-NEXT:   [[CAndAddr2:%[0-9]+]]:cherigpr = CAndAddr $cnull, [[COPY]]
  ; CHECK-NEXT:   B %bb.2, implicit-def $at
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.for.cond.cleanup:
  ; CHECK-NEXT:   CapRetPseudo
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.for.body:
  ; CHECK-NEXT:   successors: %bb.4(0x30000000), %bb.3(0x50000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   CBEZ [[COPY1]], %bb.4, implicit-def $at
  ; CHECK-NEXT:   B %bb.3, implicit-def $at
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.if.then:
  ; CHECK-NEXT:   successors: %bb.4(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[CSeal:%[0-9]+]]:cherigpr = CSeal [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CUnSeal:%[0-9]+]]:cherigpr = CUnSeal [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CAndPerms1:%[0-9]+]]:cherigpr = CAndPerms [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetFlags3:%[0-9]+]]:cherigpr = CSetFlags [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetOffset3:%[0-9]+]]:cherigpr = CSetOffset [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffset3:%[0-9]+]]:cherigpr = CIncOffset [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffsetImm4:%[0-9]+]]:cherigpr = CIncOffsetImm [[COPY1]], 10
  ; CHECK-NEXT:   [[CSetBounds:%[0-9]+]]:cherigpr = CSetBounds [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsExact:%[0-9]+]]:cherigpr = CSetBoundsExact [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsImm:%[0-9]+]]:cherigpr = CSetBoundsImm [[COPY1]], 10
  ; CHECK-NEXT:   [[CBuildCap:%[0-9]+]]:cherigpr = CBuildCap [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CCopyType:%[0-9]+]]:cherigpr = CCopyType [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CCSeal:%[0-9]+]]:cherigpr = CCSeal [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CSetAddr3:%[0-9]+]]:cherigpr = CSetAddr [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CAndAddr3:%[0-9]+]]:cherigpr = CAndAddr [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSealEntry:%[0-9]+]]:cherigpr = CSealEntry [[COPY1]]
  ; CHECK-NEXT:   [[CToPtr:%[0-9]+]]:gpr64 = CToPtr [[COPY1]], [[COPY3]]
  ; CHECK-NEXT:   [[CFromPtr:%[0-9]+]]:cherigpr = CFromPtr [[COPY3]], [[COPY]]
  ; CHECK-NEXT:   [[CGetCause:%[0-9]+]]:gpr64 = CGetCause
  ; CHECK-NEXT:   CSetCause [[COPY]]
  ; CHECK-NEXT:   CCheckPerm [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   CCheckType [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CSeal1:%[0-9]+]]:cherigpr = CSeal [[CIncOffsetImm]], [[COPY2]]
  ; CHECK-NEXT:   [[CUnSeal1:%[0-9]+]]:cherigpr = CUnSeal [[CIncOffsetImm]], [[COPY2]]
  ; CHECK-NEXT:   [[CAndPerms2:%[0-9]+]]:cherigpr = CAndPerms [[CIncOffsetImm]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBounds1:%[0-9]+]]:cherigpr = CSetBounds [[CIncOffsetImm]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsExact1:%[0-9]+]]:cherigpr = CSetBoundsExact [[CIncOffsetImm]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsImm1:%[0-9]+]]:cherigpr = CSetBoundsImm [[CIncOffsetImm]], 10
  ; CHECK-NEXT:   [[CBuildCap1:%[0-9]+]]:cherigpr = CBuildCap [[CIncOffsetImm]], [[COPY2]]
  ; CHECK-NEXT:   [[CCopyType1:%[0-9]+]]:cherigpr = CCopyType [[CIncOffsetImm]], [[COPY2]]
  ; CHECK-NEXT:   [[CCSeal1:%[0-9]+]]:cherigpr = CCSeal [[CIncOffsetImm]], [[COPY2]]
  ; CHECK-NEXT:   [[CSealEntry1:%[0-9]+]]:cherigpr = CSealEntry [[CIncOffsetImm]]
  ; CHECK-NEXT:   [[CSeal2:%[0-9]+]]:cherigpr = CSeal [[CAndPerms]], [[COPY2]]
  ; CHECK-NEXT:   [[CUnSeal2:%[0-9]+]]:cherigpr = CUnSeal [[CAndPerms]], [[COPY2]]
  ; CHECK-NEXT:   [[CAndPerms3:%[0-9]+]]:cherigpr = CAndPerms [[CAndPerms]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBounds2:%[0-9]+]]:cherigpr = CSetBounds [[CAndPerms]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsExact2:%[0-9]+]]:cherigpr = CSetBoundsExact [[CAndPerms]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsImm2:%[0-9]+]]:cherigpr = CSetBoundsImm [[CAndPerms]], 10
  ; CHECK-NEXT:   [[CBuildCap2:%[0-9]+]]:cherigpr = CBuildCap [[CAndPerms]], [[COPY2]]
  ; CHECK-NEXT:   [[CCopyType2:%[0-9]+]]:cherigpr = CCopyType [[CAndPerms]], [[COPY2]]
  ; CHECK-NEXT:   [[CCSeal2:%[0-9]+]]:cherigpr = CCSeal [[CAndPerms]], [[COPY2]]
  ; CHECK-NEXT:   [[CSealEntry2:%[0-9]+]]:cherigpr = CSealEntry [[CAndPerms]]
  ; CHECK-NEXT:   [[CSeal3:%[0-9]+]]:cherigpr = CSeal $cnull, [[COPY2]]
  ; CHECK-NEXT:   [[CUnSeal3:%[0-9]+]]:cherigpr = CUnSeal $cnull, [[COPY2]]
  ; CHECK-NEXT:   [[CAndPerms4:%[0-9]+]]:cherigpr = CAndPerms $cnull, [[COPY]]
  ; CHECK-NEXT:   [[CSetBounds3:%[0-9]+]]:cherigpr = CSetBounds $cnull, [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsExact3:%[0-9]+]]:cherigpr = CSetBoundsExact $cnull, [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsImm3:%[0-9]+]]:cherigpr = CSetBoundsImm $cnull, 10
  ; CHECK-NEXT:   [[CCopyType3:%[0-9]+]]:cherigpr = CCopyType $cnull, [[COPY2]]
  ; CHECK-NEXT:   [[CCSeal3:%[0-9]+]]:cherigpr = CCSeal $cnull, [[COPY2]]
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.for.inc:
  ; CHECK-NEXT:   successors: %bb.2(0x7c000000), %bb.1(0x04000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   CBEZ [[COPY1]], %bb.2, implicit-def $at
  ; CHECK-NEXT:   B %bb.1, implicit-def $at
  bb.0.entry:
    successors: %bb.2(0x80000000)
    liveins: $a0_64, $c3, $c4

    %0:gpr64 = COPY $a0_64
    %1:cherigpr = COPY $c3
    %2:cherigpr = COPY $c4
    %3:cherigpr = COPY $c4
    ; %4 should be known to be unsealed (since CIncOffset succeeded)
    %4:cherigpr = CIncOffsetImm %1, 4
    ; %5 should be known to be tagged and unsealed
    %5:cherigpr = CAndPerms %1, %0


    B %bb.2, implicit-def $at

  bb.1.for.cond.cleanup:
    CapRetPseudo

  bb.2.for.body:
    successors: %bb.4(0x30000000), %bb.3(0x50000000)
    CBEZ %1, %bb.4, implicit-def $at
    B %bb.3, implicit-def $at

  bb.3.if.then:
    successors: %bb.4(0x80000000)
    ; Note: Please keep these in order of the ISA spec definitions
    ; B.1.1: Capability-Inspection Instructions
    %10:gpr64 = CGetPerms %2
    %11:gpr64 = CGetType %2
    %12:gpr64 = CGetBase %2
    %13:gpr64 = CGetLength %2
    %14:gpr64 = CGetTag %2
    %15:gpr64 = CGetSealed %2
    %16:gpr64 = CGetOffset %2
    %18:cherigpr = CGetPCC
    %19:gpr64 = CGetAddr %2
    %20:gpr64 = CGetAndAddr %2, %0
    %21:gpr64 = CGetFlags %2

    ; B.1.2 Capability-Modification Instructions
    ; However, mutators can't since the input could be sealed/untagged/other constraints
    %30:cherigpr = CSeal %1, %2
    %31:cherigpr = CUnSeal %1, %2
    %32:cherigpr = CAndPerms %1, %0
    %33:cherigpr = CSetFlags %1, %0
    %34:cherigpr = CSetOffset %1, %0
    %35:cherigpr = CIncOffset %1, %0
    %36:cherigpr = CIncOffsetImm %1, 10
    %37:cherigpr = CSetBounds %1, %0
    %38:cherigpr = CSetBoundsExact %1, %0
    %39:cherigpr = CSetBoundsImm %1, 10
    %40:cherigpr = CClearTag %1 ; Note: CClearTag can be hoisted since it can't trap
    %41:cherigpr = CBuildCap %1, %2
    %42:cherigpr = CCopyType %1, %2
    %43:cherigpr = CCSeal %1, %2
    %44:cherigpr = CSetAddr %1, %0
    %45:cherigpr = CAndAddr %1, %0
    %46:cherigpr = CSetPCCOffset %0
    %47:cherigpr = CGetPCCIncOffset %0
    %48:cherigpr = CGetPCCSetAddr %0
    %49:cherigpr = CSealEntry %1

    ; B.1.3 Pointer-arithmetic instructions
    %60:gpr64 = CToPtr %1, %3  ; can trap
    %61:cherigpr = CFromPtr %3, %0 ; can trap
    %62:gpr64 = CSub %1, %2 ; never traps
    %63:cherigpr = CMove %1 ; never traps
    %64:cherigpr = CMOVZ %1, %0, %1 ; never traps
    %65:cherigpr = CMOVN %1, %0, %1 ; never traps

    ; B.1.4 Pointer-Comparison Instructions
    %70:gpr64 = CEQ %1, %2
    %71:gpr64 = CLT %1, %2
    %72:gpr64 = CLE %1, %2
    %73:gpr64 = CLTU %1, %2
    %74:gpr64 = CLEU %1, %2
    %75:gpr64 = CNEXEQ %1, %2
    %76:gpr64 = CEXEQ %1, %2

    ; B.1.5 Exception-Handling Instructions
    %80:gpr64 = CGetCause
    CSetCause %0

    ; B.1.6 Control-Flow (not tested here)

    ; B.1.7 Assertion Instructions
    CCheckPerm %1, %0
    CCheckType %1, %2
    ; CCheckTag %1; Exists iIn spec but not implemented in LLVM
    %90:gpr64 = CTestSubset %1, %2

    ; B.1.8 Special-Purpose Register access Instructions
    ;%100:cherigpr = CReadHwr 0
    ;CWriteHwr 0, %1

    ; B.1.9 Fast Register-Clearing Instructions
    ; TODO: find out how to spell the operands in textual MIR
    ; ClearLo
    ; ClearHi
    ; CClearLo
    ; CClearHi

    ; B.1.10Adjusting to Compressed Capability Precision
    %110:gpr64 = CRRL %0
    %111:gpr64 = CRAM %0

    ; Try using the mutators on a known unsealed cap:
    %130:cherigpr = CSeal %4, %2
    %131:cherigpr = CUnSeal %4, %2
    %132:cherigpr = CAndPerms %4, %0
    %133:cherigpr = CSetFlags %4, %0
    %134:cherigpr = CSetOffset %4, %0
    %135:cherigpr = CIncOffset %4, %0
    %136:cherigpr = CIncOffsetImm %4, 10
    %137:cherigpr = CSetBounds %4, %0
    %138:cherigpr = CSetBoundsExact %4, %0
    %139:cherigpr = CSetBoundsImm %4, 10
    %140:cherigpr = CClearTag %4
    %141:cherigpr = CBuildCap %4, %2
    %142:cherigpr = CCopyType %4, %2
    %143:cherigpr = CCSeal %4, %2
    %144:cherigpr = CSetAddr %4, %0
    %145:cherigpr = CAndAddr %4, %0
    %149:cherigpr = CSealEntry %4

    ; Try using the mutators on a known tagger+unsealed cap:
    %230:cherigpr = CSeal %5, %2
    %231:cherigpr = CUnSeal %5, %2
    %232:cherigpr = CAndPerms %5, %0
    %233:cherigpr = CSetFlags %5, %0
    %234:cherigpr = CSetOffset %5, %0
    %235:cherigpr = CIncOffset %5, %0
    %236:cherigpr = CIncOffsetImm %5, 10
    %237:cherigpr = CSetBounds %5, %0
    %238:cherigpr = CSetBoundsExact %5, %0
    %239:cherigpr = CSetBoundsImm %5, 10
    %240:cherigpr = CClearTag %5
    %241:cherigpr = CBuildCap %5, %2
    %242:cherigpr = CCopyType %5, %2
    %243:cherigpr = CCSeal %5, %2
    %244:cherigpr = CSetAddr %5, %0
    %245:cherigpr = CAndAddr %5, %0
    %249:cherigpr = CSealEntry %5

    ; Try using the mutators on $cnull
    %330:cherigpr = CSeal $cnull, %2
    %331:cherigpr = CUnSeal $cnull, %2
    %332:cherigpr = CAndPerms $cnull, %0
    %333:cherigpr = CSetFlags $cnull, %0
    %334:cherigpr = CSetOffset $cnull, %0
    %335:cherigpr = CIncOffset $cnull, %0
    %336:cherigpr = CIncOffsetImm $cnull, 10
    %337:cherigpr = CSetBounds $cnull, %0
    %338:cherigpr = CSetBoundsExact $cnull, %0
    %339:cherigpr = CSetBoundsImm $cnull, 10
    %340:cherigpr = CClearTag $cnull
    ; Invalid since it uses $ddc for zero: %341:cherigpr = CBuildCap $cnull, %2
    %342:cherigpr = CCopyType $cnull, %2
    %343:cherigpr = CCSeal $cnull, %2
    %344:cherigpr = CSetAddr $cnull, %0
    %345:cherigpr = CAndAddr $cnull, %0
    ; Invalid since it uses $ddc for zero: %349:cherigpr = CSealEntry $cnull

  bb.4.for.inc:
    successors: %bb.2(0x7c000000), %bb.1(0x04000000)

    CBEZ %1, %bb.2, implicit-def $at
    B %bb.1, implicit-def $at
...
