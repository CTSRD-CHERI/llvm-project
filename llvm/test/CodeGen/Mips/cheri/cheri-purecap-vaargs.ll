; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri128_purecap_llc %s -o - -O1 | FileCheck %s

@va_copy = common addrspace(200) global ptr addrspace(200) null, align 32

define void @copy_to_global(ptr addrspace(200) nocapture readnone %y, i32 signext %x, ...) addrspace(200) nounwind {
; CHECK-LABEL: copy_to_global:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cincoffset $c11, $c11, -64
; CHECK-NEXT:    csc $c24, $zero, 48($c11) # 16-byte Folded Spill
; CHECK-NEXT:    csc $c17, $zero, 32($c11) # 16-byte Folded Spill
; CHECK-NEXT:    cincoffset $c24, $c11, $zero
; CHECK-NEXT:    cgetaddr $1, $c11
; CHECK-NEXT:    daddiu $2, $zero, -32
; CHECK-NEXT:    and $1, $1, $2
; CHECK-NEXT:    csetaddr $c11, $c11, $1
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    csetbounds $c2, $c11, 16
; CHECK-NEXT:    csc $c13, $zero, 0($c2)
; CHECK-NEXT:    clc $c2, $zero, 0($c2)
; CHECK-NEXT:    clcbi $c1, %captab20(va_copy)($c1)
; CHECK-NEXT:    csc $c2, $zero, 0($c1)
; CHECK-NEXT:    cgetnull $c13
; CHECK-NEXT:    cincoffset $c11, $c24, $zero
; CHECK-NEXT:    clc $c17, $zero, 32($c11) # 16-byte Folded Reload
; CHECK-NEXT:    clc $c24, $zero, 48($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 64
  %1 = alloca ptr addrspace(200), align 32, addrspace(200)
  %2 = bitcast ptr addrspace(200) %1 to ptr addrspace(200)
  %3 = addrspacecast ptr addrspace(200) %2 to ptr
  call void @llvm.va_start.p200(ptr addrspace(200) %2)
  call void @llvm.va_copy.p200.p200(ptr addrspace(200) @va_copy, ptr addrspace(200) %2)
  call void @llvm.va_end.p200(ptr addrspace(200) %2)
  ret void
}

declare void @llvm.va_start.p200(ptr addrspace(200)) addrspace(200)

declare void @llvm.va_copy.p200.p200(ptr addrspace(200), ptr addrspace(200)) addrspace(200)

declare void @llvm.va_end.p200(ptr addrspace(200)) addrspace(200)

define ptr addrspace(200) @copy_from_global() addrspace(200) nounwind {
; CHECK-LABEL: copy_from_global:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cincoffset $c11, $c11, -64
; CHECK-NEXT:    csc $c24, $zero, 48($c11) # 16-byte Folded Spill
; CHECK-NEXT:    csc $c17, $zero, 32($c11) # 16-byte Folded Spill
; CHECK-NEXT:    cincoffset $c24, $c11, $zero
; CHECK-NEXT:    cgetaddr $1, $c11
; CHECK-NEXT:    daddiu $2, $zero, -32
; CHECK-NEXT:    and $1, $1, $2
; CHECK-NEXT:    csetaddr $c11, $c11, $1
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(va_copy)($c1)
; CHECK-NEXT:    clc $c1, $zero, 0($c1)
; CHECK-NEXT:    csetbounds $c2, $c11, 16
; CHECK-NEXT:    csc $c1, $zero, 0($c2)
; CHECK-NEXT:    clc $c3, $zero, 0($c11)
; CHECK-NEXT:    cincoffset $c11, $c24, $zero
; CHECK-NEXT:    clc $c17, $zero, 32($c11) # 16-byte Folded Reload
; CHECK-NEXT:    clc $c24, $zero, 48($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 64
  %1 = alloca ptr addrspace(200), align 32, addrspace(200)
  %2 = bitcast ptr addrspace(200) %1 to ptr addrspace(200)
  call void @llvm.va_copy.p200.p200(ptr addrspace(200) %2, ptr addrspace(200) @va_copy)
  %3 = load ptr addrspace(200), ptr addrspace(200) %1, align 32
  ret ptr addrspace(200) %3
}

; When calling from a variadic function to one that takes a va_list, we should
; simply move the va capability from $c13 to the relevant argument register,
; but also make sure to clear $c13.
; TODO: this could be a simple cmove!
define void @pass_va_list(ptr addrspace(200) nocapture readnone %y, i32 signext %x, ...) addrspace(200) nounwind {
; CHECK-LABEL: pass_va_list:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cincoffset $c11, $c11, -64
; CHECK-NEXT:    csc $c24, $zero, 48($c11) # 16-byte Folded Spill
; CHECK-NEXT:    csc $c17, $zero, 32($c11) # 16-byte Folded Spill
; CHECK-NEXT:    cincoffset $c24, $c11, $zero
; CHECK-NEXT:    cgetaddr $1, $c11
; CHECK-NEXT:    daddiu $2, $zero, -32
; CHECK-NEXT:    and $1, $1, $2
; CHECK-NEXT:    csetaddr $c11, $c11, $1
; CHECK-NEXT:    csetbounds $c1, $c11, 16
; CHECK-NEXT:    csc $c13, $zero, 0($c1)
; CHECK-NEXT:    clc $c3, $zero, 0($c11)
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c12, %capcall20(f)($c1)
; CHECK-NEXT:    daddiu $4, $zero, 1
; CHECK-NEXT:    daddiu $5, $zero, 2
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    cgetnull $c13
; CHECK-NEXT:    cgetnull $c13
; CHECK-NEXT:    cincoffset $c11, $c24, $zero
; CHECK-NEXT:    clc $c17, $zero, 32($c11) # 16-byte Folded Reload
; CHECK-NEXT:    clc $c24, $zero, 48($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 64
  %1 = alloca ptr addrspace(200), align 32, addrspace(200)
  %2 = bitcast ptr addrspace(200) %1 to ptr addrspace(200)
  call void @llvm.va_start.p200(ptr addrspace(200) %2)
  %3 = load ptr addrspace(200), ptr addrspace(200) %1, align 32
  %4 = call i32 @f(i32 signext 1, i32 signext 2, ptr addrspace(200) %3)
  call void @llvm.va_end.p200(ptr addrspace(200) %2)
  ret void
}

declare i32 @f(i32 signext, i32 signext, ptr addrspace(200)) addrspace(200)

; When calling a variadic function, we should set $c13 to the size of the
; arguments.
define void @check_bounded(ptr addrspace(200) %x, ptr addrspace(200) %y) addrspace(200) nounwind {
; CHECK-LABEL: check_bounded:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cincoffset $c11, $c11, -128
; CHECK-NEXT:    csc $c24, $zero, 112($c11) # 16-byte Folded Spill
; CHECK-NEXT:    csc $c17, $zero, 96($c11) # 16-byte Folded Spill
; CHECK-NEXT:    cincoffset $c24, $c11, $zero
; CHECK-NEXT:    cgetaddr $1, $c11
; CHECK-NEXT:    daddiu $2, $zero, -32
; CHECK-NEXT:    and $1, $1, $2
; CHECK-NEXT:    csetaddr $c11, $c11, $1
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    csc $c3, $zero, 64($c11)
; CHECK-NEXT:    csc $c4, $zero, 32($c11)
; CHECK-NEXT:    cincoffset $c2, $c11, 32
; CHECK-NEXT:    csetbounds $c2, $c2, 16
; CHECK-NEXT:    csc $c2, $zero, 0($c11)
; CHECK-NEXT:    csetbounds $c2, $c11, 16
; CHECK-NEXT:    ori $1, $zero, 65495
; CHECK-NEXT:    clcbi $c12, %capcall20(g)($c1)
; CHECK-NEXT:    candperm $c13, $c2, $1
; CHECK-NEXT:    cincoffset $c3, $c11, 64
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 16
; CHECK-NEXT:    cincoffset $c11, $c24, $zero
; CHECK-NEXT:    clc $c17, $zero, 96($c11) # 16-byte Folded Reload
; CHECK-NEXT:    clc $c24, $zero, 112($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 128
  %x.addr = alloca ptr addrspace(200), align 32, addrspace(200)
  %y.addr = alloca ptr addrspace(200), align 32, addrspace(200)
  store ptr addrspace(200) %x, ptr addrspace(200) %x.addr, align 32
  store ptr addrspace(200) %y, ptr addrspace(200) %y.addr, align 32
  %x.addr.cast = bitcast ptr addrspace(200) %x.addr to ptr addrspace(200)
  call void (ptr addrspace(200), ...) @g(ptr addrspace(200) %x.addr.cast, ptr addrspace(200) nonnull %y.addr)
  ret void
}

; When calling a variadic function without any arguments, we should set it to
; null rather than leave it uninitialised due to having no on-stack arguments.
; FIXME: This is currently not done.
define void @check_empty(ptr addrspace(200) %x) addrspace(200) nounwind {
; CHECK-LABEL: check_empty:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cincoffset $c11, $c11, -16
; CHECK-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c12, %capcall20(g)($c1)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    cgetnull $c13
; CHECK-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 16
  call void (ptr addrspace(200), ...) @g(ptr addrspace(200) %x)
  ret void
}

declare void @g(ptr addrspace(200), ...) addrspace(200)
