; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; ModuleID = '/Users/alex/cheri/llvm-project/clang/test/CodeGen/cheri/cheri-inregs-param-info.c'
; This previously crashed because we were attempting to rematerialize a bounded stack cap where the size was not an immediate
; This caused use of a dead register -> fix this by only rematerializing ones with immediates
; RUN: %cheri_purecap_llc %s -o %t.mir -stop-before="simple-register-coalescing"
; RUN: %cheri_purecap_llc %t.mir -o - -start-before="simple-register-coalescing" -stop-after="simple-register-coalescing" -verify-machineinstrs | FileCheck %s
; RUN: %cheri_purecap_llc %t.mir -o /dev/null -start-before="simple-register-coalescing" -verify-machineinstrs
; Try compiling the full thing
; RUN: %cheri_purecap_llc %s -o - -verify-machineinstrs | %cheri_FileCheck %s -check-prefix ASM

%struct.Dwarf_Error = type { [1024 x i32] }
%struct.Dwarf_Error_small = type { [128 x i32] }

@a = common addrspace(200) global %struct.Dwarf_Error zeroinitializer, align 4
@a_small = common addrspace(200) global %struct.Dwarf_Error_small zeroinitializer, align 4

declare void @fn2(...) addrspace(200)
declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* nocapture writeonly, i8 addrspace(200)* nocapture readonly, i64, i1) addrspace(200) argmemonly nounwind

define void @fn1() addrspace(200) #0 {
; ASM-LABEL: fn1:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    daddiu $1, $zero, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    cincoffset $c11, $c11, $1
; ASM-NEXT:    csc $c19, $zero, [[#STACKFRAME_SIZE - (1 * CAP_SIZE)]]($c11)
; ASM-NEXT:    csc $c18, $zero, [[#STACKFRAME_SIZE - (2 * CAP_SIZE)]]($c11)
; ASM-NEXT:    csc $c17, $zero, [[#STACKFRAME_SIZE - (3 * CAP_SIZE)]]($c11)
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c19, $1
; ASM-NEXT:    daddiu $1, $zero, 4096
; ASM-NEXT:    cincoffset $c18, $c11, [[#CAP_SIZE]]
; ASM-NEXT:    csetbounds $c18, $c18, $1
; ASM-NEXT:    clcbi $c4, %captab20(a)($c19)
; ASM-NEXT:    clcbi $c12, %capcall20(memcpy)($c19)
; ASM-NEXT:    cmove $c3, $c18
; ASM-NEXT:    daddiu $4, $zero, 4096
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cgetnull $c13
; ASM-NEXT:    clcbi $c12, %capcall20(fn2)($c19)
; ASM-NEXT:    cmove $c3, $c18
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cgetnull $c13
; ASM-NEXT:    clc $c17, $zero, [[#STACKFRAME_SIZE - (3 * CAP_SIZE)]]($c11)
; ASM-NEXT:    clc $c18, $zero, [[#STACKFRAME_SIZE - (2 * CAP_SIZE)]]($c11)
; ASM-NEXT:    clc $c19, $zero, [[#STACKFRAME_SIZE - (1 * CAP_SIZE)]]($c11)
; ASM-NEXT:    daddiu $1, $zero, [[#STACKFRAME_SIZE]]
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, $1
entry:
  %byval-temp = alloca %struct.Dwarf_Error, align 8, addrspace(200)
  %0 = bitcast %struct.Dwarf_Error addrspace(200)* %byval-temp to i8 addrspace(200)*
  call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 8 %0, i8 addrspace(200)* align 4 bitcast (%struct.Dwarf_Error addrspace(200)* @a to i8 addrspace(200)*), i64 4096, i1 false)
  call addrspace(200) void bitcast (void (...) addrspace(200)* @fn2 to void (%struct.Dwarf_Error addrspace(200)*) addrspace(200)*)(%struct.Dwarf_Error addrspace(200)* byval align 8 %byval-temp)
  ret void
}

; CHECK-LABEL: name: fn1
; CHECK: [[OFFSET:%.+]]:gpr64 = DADDiu $zero_64, 4096
; CHECK: [[STACK_CAP:%.+]]:cherigpr = CheriBoundedStackPseudo %stack.0.byval-temp, 0, [[OFFSET]]
; CHECK: [[A_CAP:%.+]]:cherigpr = LOADCAP_BigImm target-flags(mips-captable20) @a
; CHECK: $c3 = COPY [[STACK_CAP]]
; CHECK: $c4 = COPY [[A_CAP]]
; CHECK: $a0_64 = DADDiu $zero_64, 4096
; This previously got turned into a duplicate of the CheriBoundedStackPseudo but that used the killed %1 register!
; CHECK: [[JUMP_TARGET:%.+]]:cherigpr = LOADCAP_BigImm target-flags(mips-captable20-call) @fn2
; CHECK-NEXT: $c3 = COPY [[STACK_CAP]]
; CHECK-NEXT: $c13 = CMove $cnull
; CHECK-NEXT: $c12 = COPY [[JUMP_TARGET]]
; CHECK-NEXT: CapJumpLinkPseudo killed $c12, csr_cheri_purecap, implicit-def dead $c17, implicit-def dead $c26, implicit killed $c3, implicit killed $c13, implicit-def $c11



define void @small_stack_fn1() addrspace(200) #0 {
; ASM-LABEL: small_stack_fn1:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    cincoffset $c11, $c11, -[[#STACKFRAME_SIZE:]]
; ASM-NEXT:    csc $c18, $zero, [[#STACKFRAME_SIZE - (1 * CAP_SIZE)]]($c11)
; ASM-NEXT:    csc $c17, $zero, [[#STACKFRAME_SIZE - (2 * CAP_SIZE)]]($c11)
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c18, $1
; ASM-NEXT:    clcbi $c4, %captab20(a_small)($c18)
; ASM-NEXT:    clcbi $c12, %capcall20(memcpy)($c18)
; ASM-NEXT:    cincoffset $c3, $c11, [[#CAP_SIZE]]
; ASM-NEXT:    csetbounds $c3, $c3, 512
; ASM-NEXT:    daddiu $4, $zero, 512
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cgetnull $c13
; ASM-NEXT:    clcbi $c12, %capcall20(fn2)($c18)
; ASM-NEXT:    cincoffset $c3, $c11, [[#CAP_SIZE]]
; ASM-NEXT:    csetbounds $c3, $c3, 512
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cgetnull $c13
; ASM-NEXT:    clc $c17, $zero, [[#STACKFRAME_SIZE - (2 * CAP_SIZE)]]($c11)
; ASM-NEXT:    clc $c18, $zero, [[#STACKFRAME_SIZE - (1 * CAP_SIZE)]]($c11)
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, [[#STACKFRAME_SIZE]]
entry:
  %byval-temp = alloca %struct.Dwarf_Error_small, align 8, addrspace(200)
  %0 = bitcast %struct.Dwarf_Error_small addrspace(200)* %byval-temp to i8 addrspace(200)*
  call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 8 %0, i8 addrspace(200)* align 4 bitcast (%struct.Dwarf_Error_small addrspace(200)* @a_small to i8 addrspace(200)*), i64 512, i1 false)
  call addrspace(200) void bitcast (void (...) addrspace(200)* @fn2 to void (%struct.Dwarf_Error_small addrspace(200)*) addrspace(200)*)(%struct.Dwarf_Error_small addrspace(200)* byval align 8 %byval-temp)
  ret void
}
; Same thing with a smaller stack frame. In this case we can rematerialize it:
; CHECK-LABEL: name: small_stack_fn1
; CHECK-NOT: CheriBoundedStackPseudo
; Remat 1:
; CHECK: LOADCAP_BigImm target-flags(mips-captable20-call) &memcpy
; CHECK-NEXT: $c3 = CheriBoundedStackPseudo %stack.0.byval-temp, 0, 512
; CHECK-NOT: CheriBoundedStackPseudo
; Remat 2:
; CHECK: [[JUMP_TARGET:%.+]]:cherigpr = LOADCAP_BigImm target-flags(mips-captable20-call) @fn2
; CHECK-NEXT: $c3 = CheriBoundedStackPseudo %stack.0.byval-temp, 0, 512
; CHECK-NEXT: $c13 = CMove $cnull
; CHECK-NEXT: $c12 = COPY [[JUMP_TARGET]]
; CHECK-NEXT: CapJumpLinkPseudo killed $c12, csr_cheri_purecap, implicit-def dead $c17, implicit-def dead $c26, implicit killed $c3, implicit killed $c13, implicit-def $c11
; CHECK-NOT: CheriBoundedStackPseudo

attributes #0 = { noinline nounwind optnone }
