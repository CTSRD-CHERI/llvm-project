; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: sed 's/addrspace(200)//' %s | %cheri_llc -relocation-model=pic - -o - -O0 | FileCheck -check-prefix N64 %s
; RUN: %cheri_purecap_llc -cheri-cap-table-abi=pcrel -o - %s -O0 | FileCheck -check-prefix PURECAP %s

; This code now is not quite ideal (we should probably access the constants differently)
; but it mostly matches mips

define float @return_constant_pool() nounwind readnone {
; N64-LABEL: return_constant_pool:
; N64:       # %bb.0: # %entry
; N64-NEXT:    lui $1, %hi(%neg(%gp_rel(return_constant_pool)))
; N64-NEXT:    daddu $1, $1, $25
; N64-NEXT:    daddiu $1, $1, %lo(%neg(%gp_rel(return_constant_pool)))
; N64-NEXT:    ld $1, %got_page(.LCPI0_0)($1)
; N64-NEXT:    lwc1 $f0, %got_ofst(.LCPI0_0)($1)
; N64-NEXT:    jr $ra
; N64-NEXT:    nop
;
; PURECAP-LABEL: return_constant_pool:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    clcbi $c1, %captab20(.LCPI0_0)($c1)
; PURECAP-NEXT:    clw $1, $zero, 0($c1)
; PURECAP-NEXT:    mtc1 $1, $f0
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop


entry:
  ret float 8.0
}

define double @return_constant_pool2() nounwind readnone {
; N64-LABEL: return_constant_pool2:
; N64:       # %bb.0: # %entry
; N64-NEXT:    lui $1, %hi(%neg(%gp_rel(return_constant_pool2)))
; N64-NEXT:    daddu $1, $1, $25
; N64-NEXT:    daddiu $1, $1, %lo(%neg(%gp_rel(return_constant_pool2)))
; N64-NEXT:    ld $1, %got_page(.LCPI1_0)($1)
; N64-NEXT:    ldc1 $f0, %got_ofst(.LCPI1_0)($1)
; N64-NEXT:    jr $ra
; N64-NEXT:    nop
;
; PURECAP-LABEL: return_constant_pool2:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    clcbi $c1, %captab20(.LCPI1_0)($c1)
; PURECAP-NEXT:    cld $1, $zero, 0($c1)
; PURECAP-NEXT:    dmtc1 $1, $f0
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop


entry:
  ret double 12.0
}

%struct.a = type { }
define void @b() nounwind {
; N64-LABEL: b:
; N64:       # %bb.0:
; N64-NEXT:    daddiu $sp, $sp, -16
; N64-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; N64-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; N64-NEXT:    lui $1, %hi(%neg(%gp_rel(b)))
; N64-NEXT:    daddu $1, $1, $25
; N64-NEXT:    daddiu $1, $1, %lo(%neg(%gp_rel(b)))
; N64-NEXT:    ld $25, %call16(d)($1)
; N64-NEXT:    # implicit-def: $a0_64
; N64-NEXT:    # implicit-def: $c3
; N64-NEXT:    # implicit-def: $a1_64
; N64-NEXT:    # implicit-def: $d14_64
; N64-NEXT:    move $gp, $1
; N64-NEXT:    .reloc .Ltmp0, R_MIPS_JALR, d
; N64-NEXT:  .Ltmp0:
; N64-NEXT:    jalr $25
; N64-NEXT:    nop
;
; PURECAP-LABEL: b:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    clcbi $c12, %capcall20(d)($c1)
; PURECAP-NEXT:    # implicit-def: $c3
; PURECAP-NEXT:    # implicit-def: $c4
; PURECAP-NEXT:    # implicit-def: $a0_64
; PURECAP-NEXT:    # implicit-def: $d13_64
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
  %c = fmul double undef, undef
  call void @d(%struct.a addrspace(200)* undef, %struct.a addrspace(200)* undef, i32 undef, double %c)
  unreachable
}
declare void @d(%struct.a addrspace(200)*, %struct.a addrspace(200)*, i32 , double)
