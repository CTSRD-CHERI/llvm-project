; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_opt -S -instsimplify %s -o - | FileCheck %s -check-prefix IR
; RUN: %cheri_opt -S -instsimplify %s -o - | %cheri_llc -O3 -filetype=asm -o - | FileCheck %s -check-prefix OPT
; Test that we can assemble this at -O0 (used to be a problem before csetaddr was added)
; RUN: %cheri_llc -O0 %s -filetype=asm -o /dev/null
target datalayout = "E-m:e-pf200:128:128-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
target triple = "cheri-unknown-freebsd"

declare i64 @check_fold(i64) #0
declare i64 @check_fold_cap(i8 addrspace(200)*) #0
declare i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)*) #1
declare i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)*, i64) #1
declare i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)*, i64) #1

define i64 @null_get_vaddr() #1 {
; OPT-LABEL: null_get_vaddr:
; OPT:       # %bb.0:
; OPT-NEXT:    daddiu $sp, $sp
; OPT-NEXT:    sd $ra, {{8|24}}($sp) # 8-byte Folded Spill
; OPT-NEXT:    jal check_fold
; OPT-NEXT:    daddiu $4, $zero, 0
; OPT-NEXT:    ld $ra, {{8|24}}($sp) # 8-byte Folded Reload
; OPT-NEXT:    jr $ra
; OPT-NEXT:    daddiu $sp, $sp
; IR-LABEL: @null_get_vaddr(
; IR-NEXT:    [[RET_CHECK:%.*]] = call i64 @check_fold(i64 0)
; IR-NEXT:    ret i64 [[RET_CHECK]]
  %ret = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* null)
  %ret_check = call i64 @check_fold(i64 %ret)
  ret i64 %ret_check
}

define i64 @null_set_vaddr() #1 {
; OPT-LABEL: null_set_vaddr:
; OPT:       # %bb.0:
; OPT-NEXT:    daddiu $sp, $sp,
; OPT-NEXT:    sd $ra, {{8|24}}($sp) # 8-byte Folded Spill
; OPT-NEXT:    jal check_fold_cap
; OPT-NEXT:    cincoffset $c3, $cnull, 1023
; OPT-NEXT:    ld $ra, {{8|24}}($sp) # 8-byte Folded Reload
; OPT-NEXT:    jr $ra
; OPT-NEXT:    daddiu $sp, $sp
; IR-LABEL: @null_set_vaddr(
; IR-NEXT:    [[RET_CHECK:%.*]] = call i64 @check_fold_cap(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1023))
; IR-NEXT:    ret i64 [[RET_CHECK]]
  %ret = call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* null, i64 1023)
  %ret_check = call i64 @check_fold_cap(i8 addrspace(200)* %ret)
  ret i64 %ret_check
}

define void @infer_values_from_null_set_offset() #1 {
; OPT-LABEL: infer_values_from_null_set_offset:
; OPT:       # %bb.0:
; OPT-NEXT:    daddiu $sp, $sp,
; OPT-NEXT:    sd $ra, {{8|24}}($sp) # 8-byte Folded Spill
; OPT-NEXT:    jal check_fold
; OPT-NEXT:    daddiu $4, $zero, 50
; OPT-NEXT:    ld $ra, {{8|24}}($sp) # 8-byte Folded Reload
; OPT-NEXT:    jr $ra
; OPT-NEXT:    daddiu $sp, $sp
; IR-LABEL: @infer_values_from_null_set_offset(
; IR-NEXT:    [[VADDR_CHECK:%.*]] = call i64 @check_fold(i64 50)
; IR-NEXT:    ret void
  %with_offset = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* null, i64 50)
  %vaddr = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %with_offset)
  %vaddr_check = call i64 @check_fold(i64 %vaddr)
  ret void
}


attributes #0 = { nounwind }
attributes #1 = { nounwind readnone }
