; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_opt -S -cheri-expand-intrinsics %s -o - | FileCheck %s -check-prefix IR
; RUN: %cheri_llc -O3 %s -filetype=asm -o - | FileCheck %s -check-prefix OPT
; Test that we can assemble this at -O0 (to verify that the expand intrinisics pass runs)
; RUN: %cheri_llc -O0 %s -filetype=asm -o /dev/null
target datalayout = "E-m:e-pf200:256:256-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200"
target triple = "cheri-unknown-freebsd"

declare i64 @check_fold(i64) #0
declare i64 @check_fold_cap(i8 addrspace(200)*) #0
declare i64 @llvm.cheri.cap.address.get(i8 addrspace(200)*) #1
declare i8 addrspace(200)* @llvm.cheri.cap.address.set(i8 addrspace(200)*, i64) #1
declare i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)*, i64) #1

define i64 @null_get_vaddr() #1 {
; OPT-LABEL: null_get_vaddr:
; OPT:       # %bb.0:
; OPT-NEXT:    daddiu $sp, $sp
; OPT-NEXT:    sd $ra, {{8|24}}($sp) # 8-byte Folded Spill
; OPT-NEXT:    jal check_fold
; OPT-NEXT:    daddiu $4, $zero, 0
; OPT-NEXT:    ld $ra, {{8|24}}($sp) # 8-byte Folded Reload
; OPT-NEXT:    jr $ra
; OPT-NEXT:    daddiu $sp, $sp
; IR-LABEL: @null_get_vaddr(
; IR-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get(i8 addrspace(200)* null)
; IR-NEXT:    [[RET_CHECK:%.*]] = call i64 @check_fold(i64 [[TMP1]])
; IR-NEXT:    ret i64 [[RET_CHECK]]
  %ret = call i64 @llvm.cheri.cap.address.get(i8 addrspace(200)* null)
  %ret_check = call i64 @check_fold(i64 %ret)
  ret i64 %ret_check
}

define i64 @null_set_vaddr() #1 {
; OPT-LABEL: null_set_vaddr:
; OPT:       # %bb.0:
; OPT-NEXT:    daddiu $sp, $sp,
; OPT-NEXT:    sd $ra, {{8|24}}($sp) # 8-byte Folded Spill
; OPT-NEXT:    cgetnull $c1
; OPT-NEXT:    daddiu $1, $zero, 12345
; OPT-NEXT:    jal check_fold_cap
; OPT-NEXT:    cincoffset $c3, $c1, $1
; OPT-NEXT:    ld $ra, {{8|24}}($sp) # 8-byte Folded Reload
; OPT-NEXT:    jr $ra
; OPT-NEXT:    daddiu $sp, $sp
; IR-LABEL: @null_set_vaddr(
; IR-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get(i8 addrspace(200)* null)
; IR-NEXT:    [[TMP4:%.*]] = sub i64 12345, [[TMP1]]
; IR-NEXT:    [[TMP5:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.offset.increment(i8 addrspace(200)* null, i64 [[TMP4]])
; IR-NEXT:    [[RET_CHECK:%.*]] = call i64 @check_fold_cap(i8 addrspace(200)* [[TMP5]])
; IR-NEXT:    ret i64 [[RET_CHECK]]
  %ret = call i8 addrspace(200)* @llvm.cheri.cap.address.set(i8 addrspace(200)* null, i64 12345)
  %ret_check = call i64 @check_fold_cap(i8 addrspace(200)* %ret)
  ret i64 %ret_check
}

define void @infer_values_from_null_set_offset() #1 {
; OPT-LABEL: infer_values_from_null_set_offset:
; OPT:       # %bb.0:
; OPT-NEXT:    daddiu $sp, $sp,
; OPT-NEXT:    sd $ra, {{8|24}}($sp) # 8-byte Folded Spill
; OPT-NEXT:    jal check_fold
; OPT-NEXT:    daddiu $4, $zero, 50
; OPT-NEXT:    ld $ra, {{8|24}}($sp) # 8-byte Folded Reload
; OPT-NEXT:    jr $ra
; OPT-NEXT:    daddiu $sp, $sp
; IR-LABEL: @infer_values_from_null_set_offset(
; IR-NEXT:    [[WITH_OFFSET:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)* null, i64 50)
; IR-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get(i8 addrspace(200)* [[WITH_OFFSET]])
; IR-NEXT:    [[VADDR_CHECK:%.*]] = call i64 @check_fold(i64 [[TMP1]])
; IR-NEXT:    ret void
  %with_offset = call i8 addrspace(200)* @llvm.cheri.cap.offset.set(i8 addrspace(200)* null, i64 50)
  %vaddr = call i64 @llvm.cheri.cap.address.get(i8 addrspace(200)* %with_offset)
  %vaddr_check = call i64 @check_fold(i64 %vaddr)
  ret void
}


attributes #0 = { nounwind }
attributes #1 = { nounwind readnone }
