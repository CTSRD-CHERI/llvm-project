; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_purecap_llc -verify-machineinstrs %s -o - | FileCheck %s -enable-var-scope

@d = common addrspace(200) global i64 0, align 8
@w = common addrspace(200) global i32 0, align 4
@h = common addrspace(200) global i16 0, align 2
@b = common addrspace(200) global i8 0, align 1
@du = common addrspace(200) global i64 0, align 8
@wu = common addrspace(200) global i32 0, align 4
@hu = common addrspace(200) global i16 0, align 2
@bu = common addrspace(200) global i8 0, align 1
@x = common addrspace(200) global ptr addrspace(200) null, align 32

; Function Attrs: nounwind
define void @incd() #0 {
; CHECK-LABEL: incd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(d)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    daddiu $1, $zero, 1
; CHECK-NEXT:  .LBB0_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    clld $2, $c1
; CHECK-NEXT:    daddu $3, $2, $1
; CHECK-NEXT:    cscd $3, $3, $c1
; CHECK-NEXT:    beqz $3, .LBB0_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) @d, i64 1 seq_cst, align 8
  ret void
}

; Function Attrs: nounwind
define void @incw() #0 {
; CHECK-LABEL: incw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(w)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $1, $zero, 1
; CHECK-NEXT:  .LBB1_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllw $2, $c1
; CHECK-NEXT:    addu $3, $2, $1
; CHECK-NEXT:    cscw $3, $3, $c1
; CHECK-NEXT:    beqz $3, .LBB1_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) @w, i32 1 seq_cst, align 4
  ret void
}

; Function Attrs: nounwind
define void @inch() #0 {
; CHECK-LABEL: inch:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(h)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $1, $zero, 1
; CHECK-NEXT:  .LBB2_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllh $2, $c1
; CHECK-NEXT:    addu $3, $2, $1
; CHECK-NEXT:    csch $3, $3, $c1
; CHECK-NEXT:    beqz $3, .LBB2_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) @h, i16 1 seq_cst, align 2
  ret void
}

; Function Attrs: nounwind
define void @incb() #0 {
; CHECK-LABEL: incb:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(b)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $1, $zero, 1
; CHECK-NEXT:  .LBB3_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllb $2, $c1
; CHECK-NEXT:    addu $3, $2, $1
; CHECK-NEXT:    cscb $3, $3, $c1
; CHECK-NEXT:    beqz $3, .LBB3_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) @b, i8 1 seq_cst, align 1
  ret void
}

; Function Attrs: nounwind
define void @incdu() #0 {
; CHECK-LABEL: incdu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(du)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    daddiu $1, $zero, 1
; CHECK-NEXT:  .LBB4_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    clld $2, $c1
; CHECK-NEXT:    daddu $3, $2, $1
; CHECK-NEXT:    cscd $3, $3, $c1
; CHECK-NEXT:    beqz $3, .LBB4_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) @du, i64 1 seq_cst, align 8
  ret void
}

; Function Attrs: nounwind
define void @incwu() #0 {
; CHECK-LABEL: incwu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(wu)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $1, $zero, 1
; CHECK-NEXT:  .LBB5_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllw $2, $c1
; CHECK-NEXT:    addu $3, $2, $1
; CHECK-NEXT:    cscw $3, $3, $c1
; CHECK-NEXT:    beqz $3, .LBB5_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) @wu, i32 1 seq_cst, align 4
  ret void
}

; Function Attrs: nounwind
define void @inchu() #0 {
; CHECK-LABEL: inchu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(hu)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $1, $zero, 1
; CHECK-NEXT:  .LBB6_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllh $2, $c1
; CHECK-NEXT:    addu $3, $2, $1
; CHECK-NEXT:    csch $3, $3, $c1
; CHECK-NEXT:    beqz $3, .LBB6_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) @hu, i16 1 seq_cst, align 2
  ret void
}

; Function Attrs: nounwind
define void @incbu() #0 {
; CHECK-LABEL: incbu:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(bu)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $1, $zero, 1
; CHECK-NEXT:  .LBB7_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllb $2, $c1
; CHECK-NEXT:    addu $3, $2, $1
; CHECK-NEXT:    cscb $3, $3, $c1
; CHECK-NEXT:    beqz $3, .LBB7_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) @bu, i8 1 seq_cst, align 1
  ret void
}

; Function Attrs: nounwind
define i32 @swapd(ptr addrspace(200) nocapture %e, i64 signext %n) #0 {
; CHECK-LABEL: swapd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    cld $1, $zero, 0($c3)
; CHECK-NEXT:    clcbi $c1, %captab20(d)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:  .LBB8_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    clld $3, $c1
; CHECK-NEXT:    bne $3, $1, .LBB8_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; We have a different register for condition and value -> no need for the move
; CHECK-NEXT:    # in Loop: Header=BB8_1 Depth=1
; CHECK-NEXT:    cscd $2, $4, $c1
; CHECK-NEXT:    beqz $2, .LBB8_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB8_3: # %entry
; CHECK-NEXT:    xor $2, $3, $1
; CHECK-NEXT:    sltiu $2, $2, 1
; CHECK-NEXT:    sync
; CHECK-NEXT:    beq $3, $1, .LBB8_5
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.4: # %cmpxchg.store_expected
; CHECK-NEXT:    csd $3, $zero, 0($c3)
; CHECK-NEXT:  .LBB8_5: # %cmpxchg.continue
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = load i64, ptr addrspace(200) %e, align 8
  %1 = cmpxchg ptr addrspace(200) @d, i64 %0, i64 %n seq_cst seq_cst, align 8
  %2 = extractvalue { i64, i1 } %1, 1
  br i1 %2, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %entry
  %3 = extractvalue { i64, i1 } %1, 0
  store i64 %3, ptr addrspace(200) %e, align 8
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %entry
  %conv = zext i1 %2 to i32
  ret i32 %conv
}

; Function Attrs: nounwind
define i32 @swapw(ptr addrspace(200) nocapture %e, i32 signext %n) #0 {
; CHECK-LABEL: swapw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clw $1, $zero, 0($c3)
; CHECK-NEXT:    clcbi $c1, %captab20(w)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:  .LBB9_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllw $3, $c1
; CHECK-NEXT:    bne $3, $1, .LBB9_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; We have a different register for condition and value -> no need for the move
; CHECK-NEXT:    # in Loop: Header=BB9_1 Depth=1
; CHECK-NEXT:    cscw $2, $4, $c1
; CHECK-NEXT:    beqz $2, .LBB9_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB9_3: # %entry
; CHECK-NEXT:    xor $2, $3, $1
; CHECK-NEXT:    sltiu $2, $2, 1
; CHECK-NEXT:    sync
; CHECK-NEXT:    beq $3, $1, .LBB9_5
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.4: # %cmpxchg.store_expected
; CHECK-NEXT:    csw $3, $zero, 0($c3)
; CHECK-NEXT:  .LBB9_5: # %cmpxchg.continue
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = load i32, ptr addrspace(200) %e, align 4
  %1 = cmpxchg ptr addrspace(200) @w, i32 %0, i32 %n seq_cst seq_cst, align 4
  %2 = extractvalue { i32, i1 } %1, 1
  br i1 %2, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %entry
  %3 = extractvalue { i32, i1 } %1, 0
  store i32 %3, ptr addrspace(200) %e, align 4
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %entry
  %conv = zext i1 %2 to i32
  ret i32 %conv
}

; Function Attrs: nounwind
define i32 @swaph(ptr addrspace(200) nocapture %e, i16 signext %n) #0 {
; CHECK-LABEL: swaph:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clh $1, $zero, 0($c3)
; CHECK-NEXT:    clcbi $c1, %captab20(h)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:  .LBB10_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllh $3, $c1
; CHECK-NEXT:    bne $3, $1, .LBB10_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; We have a different register for condition and value -> no need for the move
; CHECK-NEXT:    # in Loop: Header=BB10_1 Depth=1
; CHECK-NEXT:    csch $2, $4, $c1
; CHECK-NEXT:    beqz $2, .LBB10_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB10_3: # %entry
; CHECK-NEXT:    sll $1, $1, 16
; CHECK-NEXT:    sra $1, $1, 16
; CHECK-NEXT:    xor $2, $3, $1
; CHECK-NEXT:    sltiu $2, $2, 1
; CHECK-NEXT:    sync
; CHECK-NEXT:    beq $3, $1, .LBB10_5
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.4: # %cmpxchg.store_expected
; CHECK-NEXT:    csh $3, $zero, 0($c3)
; CHECK-NEXT:  .LBB10_5: # %cmpxchg.continue
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = load i16, ptr addrspace(200) %e, align 2
  %1 = cmpxchg ptr addrspace(200) @h, i16 %0, i16 %n seq_cst seq_cst, align 2
  %2 = extractvalue { i16, i1 } %1, 1
  br i1 %2, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %entry
  %3 = extractvalue { i16, i1 } %1, 0
  store i16 %3, ptr addrspace(200) %e, align 2
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %entry
  %conv = zext i1 %2 to i32
  ret i32 %conv
}

; Function Attrs: nounwind
define i32 @swapb(ptr addrspace(200) nocapture %e, i8 signext %n) #0 {
; CHECK-LABEL: swapb:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clb $1, $zero, 0($c3)
; CHECK-NEXT:    clcbi $c1, %captab20(b)($c1)
; CHECK-NEXT:    sync
; CHECK-NEXT:  .LBB11_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllb $3, $c1
; CHECK-NEXT:    bne $3, $1, .LBB11_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; We have a different register for condition and value -> no need for the move
; CHECK-NEXT:    # in Loop: Header=BB11_1 Depth=1
; CHECK-NEXT:    cscb $2, $4, $c1
; CHECK-NEXT:    beqz $2, .LBB11_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB11_3: # %entry
; CHECK-NEXT:    sll $1, $1, 24
; CHECK-NEXT:    sra $1, $1, 24
; CHECK-NEXT:    xor $2, $3, $1
; CHECK-NEXT:    sltiu $2, $2, 1
; CHECK-NEXT:    sync
; CHECK-NEXT:    beq $3, $1, .LBB11_5
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.4: # %cmpxchg.store_expected
; CHECK-NEXT:    csb $3, $zero, 0($c3)
; CHECK-NEXT:  .LBB11_5: # %cmpxchg.continue
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = load i8, ptr addrspace(200) %e, align 1
  %1 = cmpxchg ptr addrspace(200) @b, i8 %0, i8 %n seq_cst seq_cst, align 1
  %2 = extractvalue { i8, i1 } %1, 1
  br i1 %2, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %entry
  %3 = extractvalue { i8, i1 } %1, 0
  store i8 %3, ptr addrspace(200) %e, align 1
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %entry
  %conv = zext i1 %2 to i32
  ret i32 %conv
}

; Function Attrs: nounwind
define i64 @fetchaddd(ptr addrspace(200) %f, i64 signext %x) #0 {
; CHECK-LABEL: fetchaddd:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    daddiu $1, $zero, 1
; CHECK-NEXT:  .LBB12_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    clld $2, $c3
; CHECK-NEXT:    daddu $3, $2, $1
; CHECK-NEXT:    cscd $3, $3, $c3
; CHECK-NEXT:    beqz $3, .LBB12_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) %f, i64 1 seq_cst, align 8
  ret i64 %0
}

; Function Attrs: nounwind
define i32 @fetchaddw(ptr addrspace(200) %f, i32 signext %x) #0 {
; CHECK-LABEL: fetchaddw:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $1, $zero, 1
; CHECK-NEXT:  .LBB13_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllw $2, $c3
; CHECK-NEXT:    addu $3, $2, $1
; CHECK-NEXT:    cscw $3, $3, $c3
; CHECK-NEXT:    beqz $3, .LBB13_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) %f, i32 1 seq_cst, align 4
  ret i32 %0
}

; Function Attrs: nounwind
define signext i16 @fetchaddh(ptr addrspace(200) %f, i16 signext %x) #0 {
; CHECK-LABEL: fetchaddh:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $1, $zero, 1
; CHECK-NEXT:  .LBB14_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllh $2, $c3
; CHECK-NEXT:    addu $3, $2, $1
; CHECK-NEXT:    csch $3, $3, $c3
; CHECK-NEXT:    beqz $3, .LBB14_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) %f, i16 1 seq_cst, align 2
  ret i16 %0
}

; Function Attrs: nounwind
define signext i8 @fetchaddb(ptr addrspace(200) %f, i8 signext %x) #0 {
; CHECK-LABEL: fetchaddb:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    addiu $1, $zero, 1
; CHECK-NEXT:  .LBB15_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllb $2, $c3
; CHECK-NEXT:    addu $3, $2, $1
; CHECK-NEXT:    cscb $3, $3, $c3
; CHECK-NEXT:    beqz $3, .LBB15_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
entry:
  %0 = atomicrmw add ptr addrspace(200) %f, i8 1 seq_cst, align 1
  ret i8 %0
}

; Function Attrs: nounwind
define i8 @atomic_fetch_swap8(i8 %x) #0 {
; CHECK-LABEL: atomic_fetch_swap8:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(b)($c1)
; CHECK-NEXT:    sll $1, $4, 0
; CHECK-NEXT:  .LBB16_1: # =>This Inner Loop Header: Depth=1
; Load into $2 (return value)
; CHECK-NEXT:    cllb $2, $c1
; We have a different register for condition and value -> no need for the move
; CHECK-NEXT:    cscb $3, $1, $c1
; CHECK-NEXT:    beqz $3, .LBB16_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
  %t1 = atomicrmw xchg ptr addrspace(200) @b, i8 %x acquire, align 1
  ret i8 %t1
}

; Function Attrs: nounwind
define i16 @atomic_fetch_swap16(i16 %x) #0 {
; CHECK-LABEL: atomic_fetch_swap16:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(h)($c1)
; CHECK-NEXT:    sll $1, $4, 0
; CHECK-NEXT:  .LBB17_1: # =>This Inner Loop Header: Depth=1
; Load into $2 (return value)
; CHECK-NEXT:    cllh $2, $c1
; We have a different register for condition and value -> no need for the move
; CHECK-NEXT:    csch $3, $1, $c1
; CHECK-NEXT:    beqz $3, .LBB17_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
  %t1 = atomicrmw xchg ptr addrspace(200) @h, i16 %x acquire, align 2
  ret i16 %t1
}

; Function Attrs: nounwind
define i32 @atomic_fetch_swap32(i32 %x) #0 {
; CHECK-LABEL: atomic_fetch_swap32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(w)($c1)
; CHECK-NEXT:    sll $1, $4, 0
; CHECK-NEXT:  .LBB18_1: # =>This Inner Loop Header: Depth=1
; Load into $2 (return value)
; CHECK-NEXT:    cllw $2, $c1
; We have a different register for condition and value -> no need for the move
; CHECK-NEXT:    cscw $3, $1, $c1
; CHECK-NEXT:    beqz $3, .LBB18_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
  %t1 = atomicrmw xchg ptr addrspace(200) @w, i32 %x acquire, align 4
  ret i32 %t1
}

; Function Attrs: nounwind
define i64 @atomic_fetch_swap64(i64 %x) #0 {
; CHECK-LABEL: atomic_fetch_swap64:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c1, $1
; CHECK-NEXT:    clcbi $c1, %captab20(d)($c1)
; 64-bit -> no need for the sign extend: sll $[[ARG:[0-9]+]], $4, 0
; CHECK-NEXT:  .LBB19_1: # =>This Inner Loop Header: Depth=1
; Load into $2 (return value)
; CHECK-NEXT:    clld $2, $c1
; We have a different register for condition and value -> no need for the move
; CHECK-NEXT:    cscd $1, $4, $c1
; CHECK-NEXT:    beqz $1, .LBB19_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2:
; CHECK-NEXT:    sync
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    nop
  %t1 = atomicrmw xchg ptr addrspace(200) @d, i64 %x acquire, align 8
  ret i64 %t1
}


attributes #0 = { nounwind }
!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (ssh://dc552@vica.cl.cam.ac.uk:/home/dc552/CHERISDK/llvm/tools/clang 3da05ea3ad6db2e2d768f7fc72bcf5e6fa35ee14) (ssh://dc552@vica.cl.cam.ac.uk:/home/dc552/CHERISDK/llvm 922cf8569084e404af3b94a89d8ad4786d6d8c74)"}
