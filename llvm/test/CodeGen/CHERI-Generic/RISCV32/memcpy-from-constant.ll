; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --scrub-attributes --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/memcpy-from-constant.ll
;; Copying from a zero constant can be converted to a memset (even with the tag preservation flags)
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f < %s -o - | FileCheck %s

@a = internal addrspace(200) constant ptr addrspace(200) null
@b = internal addrspace(200) constant ptr addrspace(200) null
@zero_constant = internal addrspace(200) constant [5 x ptr addrspace(200)] zeroinitializer
@constant_ptrs = internal addrspace(200) constant [2 x ptr addrspace(200)] [ptr addrspace(200) @a, ptr addrspace(200) @b]

declare void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) noalias nocapture writeonly, ptr addrspace(200) noalias nocapture readonly, i64, i1 immarg) addrspace(200) #0

define linkonce_odr void @copy_from_zero_constant(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_zero_constant:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:    sc cnull, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 @zero_constant, i64 8, i1 false)
  ret void
}

define linkonce_odr void @copy_from_zero_constant_with_offset(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_zero_constant_with_offset:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:    sc cnull, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  %src = getelementptr inbounds i8, ptr addrspace(200) @zero_constant, i64 8
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 %src, i64 8, i1 false)
  ret void
}

define linkonce_odr void @copy_from_large_zero_constant(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_large_zero_constant:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:    sw zero, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 @zero_constant, i64 4, i1 false)
  ret void
}

define linkonce_odr void @copy_from_ptr_constant(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_ptr_constant:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:  .LBB3_1: # %do.body
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    auipcc ca1, %got_pcrel_hi(constant_ptrs)
; CHECK-NEXT:    lc ca1, %pcrel_lo(.LBB3_1)(ca1)
; CHECK-NEXT:    lc ca1, 0(ca1)
; CHECK-NEXT:    sc ca1, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 @constant_ptrs, i64 8, i1 false)
  ret void
}

define linkonce_odr void @copy_from_ptr_constant_with_offset(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_ptr_constant_with_offset:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:  .LBB4_1: # %do.body
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    auipcc ca1, %got_pcrel_hi(constant_ptrs)
; CHECK-NEXT:    lc ca1, %pcrel_lo(.LBB4_1)(ca1)
; CHECK-NEXT:    lc ca1, 8(ca1)
; CHECK-NEXT:    sc ca1, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  %src = getelementptr inbounds i8, ptr addrspace(200) @constant_ptrs, i64 8
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 %src, i64 8, i1 false)
  ret void
}

;; Run the same tests again this time with must_preserve_tags to check that we don't call memcpy().

define linkonce_odr void @copy_from_zero_constant_preserve(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_zero_constant_preserve:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:    sc cnull, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 @zero_constant, i64 8, i1 false) #1
  ret void
}

define linkonce_odr void @copy_from_zero_constant_with_offset_preserve(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_zero_constant_with_offset_preserve:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:    sc cnull, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  %src = getelementptr inbounds i8, ptr addrspace(200) @zero_constant, i64 8
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 %src, i64 8, i1 false) #1
  ret void
}

define linkonce_odr void @copy_from_large_zero_constant_preserve(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_large_zero_constant_preserve:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:    sw zero, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 @zero_constant, i64 4, i1 false) #1
  ret void
}

define linkonce_odr void @copy_from_ptr_constant_preserve(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_ptr_constant_preserve:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:  .LBB8_1: # %do.body
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    auipcc ca1, %got_pcrel_hi(constant_ptrs)
; CHECK-NEXT:    lc ca1, %pcrel_lo(.LBB8_1)(ca1)
; CHECK-NEXT:    lc ca1, 0(ca1)
; CHECK-NEXT:    sc ca1, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 @constant_ptrs, i64 8, i1 false) #1
  ret void
}

define linkonce_odr void @copy_from_ptr_constant_with_offset_preserve(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_ptr_constant_with_offset_preserve:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:  .LBB9_1: # %do.body
; CHECK-NEXT:    # Label of block must be emitted
; CHECK-NEXT:    auipcc ca1, %got_pcrel_hi(constant_ptrs)
; CHECK-NEXT:    lc ca1, %pcrel_lo(.LBB9_1)(ca1)
; CHECK-NEXT:    lc ca1, 8(ca1)
; CHECK-NEXT:    sc ca1, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  %src = getelementptr inbounds i8, ptr addrspace(200) @constant_ptrs, i64 8
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 8 %dst, ptr addrspace(200) align 8 %src, i64 8, i1 false) #1
  ret void
}

;; Finally, check copying from a zero constant with insufficient known alignment.
;; We should be able to emit this inline since a zero constant source never has tags.

define linkonce_odr void @copy_from_underaligned_zero_constant(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_underaligned_zero_constant:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:    sw zero, 4(ca0)
; CHECK-NEXT:    sw zero, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 4 %dst, ptr addrspace(200) align 4 @zero_constant, i64 8, i1 false) #1
  ret void
}

define linkonce_odr void @copy_from_underaligned_zero_constant_preserve(ptr addrspace(200) %dst) addrspace(200) {
; CHECK-LABEL: copy_from_underaligned_zero_constant_preserve:
; CHECK:       # %bb.0: # %do.body
; CHECK-NEXT:    sw zero, 4(ca0)
; CHECK-NEXT:    sw zero, 0(ca0)
; CHECK-NEXT:    ret
do.body:
  call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 4 %dst, ptr addrspace(200) align 4 @zero_constant, i64 8, i1 false) #1
  ret void
}

attributes #0 = { argmemonly nocallback nofree nounwind willreturn }
attributes #1 = { must_preserve_cheri_tags "frontend-memtransfer-type"="'const UChar * __capability' (aka 'const char16_t * __capability')" }
