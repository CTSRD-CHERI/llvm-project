; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/cmpxchg-exact-branch-folder.ll
; CHERI-GENERIC-UTC: llc
; CHERI-GENERIC-UTC: mir
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f -mattr=+a < %s --stop-after=branch-folder | FileCheck %s --check-prefixes=MIR
; RUN: not --crash llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f -mattr=+a < %s
; REQUIRES: asserts

; The branch-folder MIR pass will merge the two blocks inside these functions but
; since the base pointer is distinct it will have two MachineMemOperands.
; The cmpxchg exact logic stored the exact flag in the MachineMemOperand and
; previously assumed there would only ever be one operand, so this test ensures
; we can handle the merged logic.

define dso_local signext i32 @merge_i32(i1 %cond1, ptr addrspace(200) %ptr, i32 %newval, i32 %cmpval) {
  ; MIR-LABEL: name: merge_i32
  ; MIR: bb.0.entry:
  ; MIR-NEXT:   liveins: $c11, $x10, $x12, $x13
  ; MIR-NEXT: {{  $}}
  ; MIR-NEXT:   renamable $x10 = ANDI killed renamable $x10, 1
  ; MIR-NEXT:   renamable $c10 = CLC_64 killed renamable $c11, 0 :: (load (s64) from %ir.ptr, align 16, addrspace 200)
  ; MIR-NEXT:   dead early-clobber renamable $x11, dead early-clobber renamable $x14 = PseudoCheriCmpXchg32 killed renamable $c10, killed renamable $x13, killed renamable $x12, 5 :: (load store release monotonic (s32) on %ir.ld2, addrspace 200), (load store release monotonic (s32) on %ir.ld1, addrspace 200)
  ; MIR-NEXT:   $x10 = COPY $x0
  ; MIR-NEXT:   PseudoCRET implicit $x10
entry:
  br i1 %cond1, label %if.then, label %if.else

if.then:
  %ld1 = load ptr addrspace(200), ptr addrspace(200) %ptr, align 16
  %atomic1 = cmpxchg ptr addrspace(200) %ld1, i32 %cmpval, i32 %newval release monotonic, align 4
  br label %end

if.else:
  %ld2 = load ptr addrspace(200), ptr addrspace(200) %ptr, align 16
  %atomic2 = cmpxchg ptr addrspace(200) %ld2, i32 %cmpval, i32 %newval release monotonic, align 4
  br label %end

end:
  ret i32 0
}

define dso_local signext i32 @merge_ptr_addr(i1 %cond1, ptr addrspace(200) %ptr, ptr addrspace(200) %newval, ptr addrspace(200) %cmpval) {
  ; MIR-LABEL: name: merge_ptr_addr
  ; MIR: bb.0.entry:
  ; MIR-NEXT:   liveins: $c11, $c12, $c13, $x10
  ; MIR-NEXT: {{  $}}
  ; MIR-NEXT:   renamable $x10 = ANDI killed renamable $x10, 1
  ; MIR-NEXT:   renamable $c10 = CLC_64 killed renamable $c11, 0 :: (load (s64) from %ir.ptr, align 16, addrspace 200)
  ; MIR-NEXT:   dead early-clobber renamable $c11, dead early-clobber renamable $x14 = PseudoCheriCmpXchgCap killed renamable $c10, killed renamable $c13, killed renamable $c12, 5 :: (load store release monotonic (s64) on %ir.ld2, addrspace 200), (load store release monotonic (s64) on %ir.ld1, addrspace 200)
  ; MIR-NEXT:   $x10 = COPY $x0
  ; MIR-NEXT:   PseudoCRET implicit $x10
entry:
  br i1 %cond1, label %if.then, label %if.else

if.then:
  %ld1 = load ptr addrspace(200), ptr addrspace(200) %ptr, align 16
  %atomic1 = cmpxchg ptr addrspace(200) %ld1, ptr addrspace(200) %cmpval, ptr addrspace(200) %newval release monotonic, align 16
  br label %end

if.else:
  %ld2 = load ptr addrspace(200), ptr addrspace(200) %ptr, align 16
  %atomic2 = cmpxchg ptr addrspace(200) %ld2, ptr addrspace(200) %cmpval, ptr addrspace(200) %newval release monotonic, align 16
  br label %end

end:
  ret i32 0
}

define dso_local signext i32 @merge_ptr_exact(i1 %cond1, ptr addrspace(200) %ptr, ptr addrspace(200) %newval, ptr addrspace(200) %cmpval) {
  ; MIR-LABEL: name: merge_ptr_exact
  ; MIR: bb.0.entry:
  ; MIR-NEXT:   liveins: $c11, $c12, $c13, $x10
  ; MIR-NEXT: {{  $}}
  ; MIR-NEXT:   renamable $x10 = ANDI killed renamable $x10, 1
  ; MIR-NEXT:   renamable $c10 = CLC_64 killed renamable $c11, 0 :: (load (s64) from %ir.ptr, align 16, addrspace 200)
  ; MIR-NEXT:   dead early-clobber renamable $c11, dead early-clobber renamable $x14 = PseudoCheriCmpXchgCap killed renamable $c10, killed renamable $c13, killed renamable $c12, 5 :: (load store release monotonic exact (s64) on %ir.ld2, addrspace 200), (load store release monotonic exact (s64) on %ir.ld1, addrspace 200)
  ; MIR-NEXT:   $x10 = COPY $x0
  ; MIR-NEXT:   PseudoCRET implicit $x10
entry:
  br i1 %cond1, label %if.then, label %if.else

if.then:
  %ld1 = load ptr addrspace(200), ptr addrspace(200) %ptr, align 16
  %atomic1 = cmpxchg exact ptr addrspace(200) %ld1, ptr addrspace(200) %cmpval, ptr addrspace(200) %newval release monotonic, align 16
  br label %end

if.else:
  %ld2 = load ptr addrspace(200), ptr addrspace(200) %ptr, align 16
  %atomic2 = cmpxchg exact ptr addrspace(200) %ld2, ptr addrspace(200) %cmpval, ptr addrspace(200) %newval release monotonic, align 16
  br label %end

end:
  ret i32 0
}

; FIXME: these two branches should not be merged!
define dso_local signext i32 @merge_ptr_mismatch_exact_flag(i1 %cond1, ptr addrspace(200) %ptr, ptr addrspace(200) %newval, ptr addrspace(200) %cmpval) {
  ; MIR-LABEL: name: merge_ptr_mismatch_exact_flag
  ; MIR: bb.0.entry:
  ; MIR-NEXT:   liveins: $c11, $c12, $c13, $x10
  ; MIR-NEXT: {{  $}}
  ; MIR-NEXT:   renamable $x10 = ANDI killed renamable $x10, 1
  ; MIR-NEXT:   renamable $c10 = CLC_64 killed renamable $c11, 0 :: (load (s64) from %ir.ptr, align 16, addrspace 200)
  ; MIR-NEXT:   dead early-clobber renamable $c11, dead early-clobber renamable $x14 = PseudoCheriCmpXchgCap killed renamable $c10, killed renamable $c13, killed renamable $c12, 5 :: (load store release monotonic (s64) on %ir.ld2, addrspace 200), (load store release monotonic exact (s64) on %ir.ld1, addrspace 200)
  ; MIR-NEXT:   $x10 = COPY $x0
  ; MIR-NEXT:   PseudoCRET implicit $x10
entry:
  br i1 %cond1, label %if.then, label %if.else

if.then:
  %ld1 = load ptr addrspace(200), ptr addrspace(200) %ptr, align 16
  %atomic1 = cmpxchg exact ptr addrspace(200) %ld1, ptr addrspace(200) %cmpval, ptr addrspace(200) %newval release monotonic, align 16
  br label %end

if.else:
  %ld2 = load ptr addrspace(200), ptr addrspace(200) %ptr, align 16
  %atomic2 = cmpxchg ptr addrspace(200) %ld2, ptr addrspace(200) %cmpval, ptr addrspace(200) %newval release monotonic, align 16
  br label %end

end:
  ret i32 0
}
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; MIR: {{.*}}
