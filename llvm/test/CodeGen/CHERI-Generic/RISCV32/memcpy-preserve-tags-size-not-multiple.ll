; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --scrub-attributes --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/memcpy-preserve-tags-size-not-multiple.ll
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f -o - -O0 -verify-machineinstrs %s | FileCheck %s -check-prefixes CHECK
; Check that we can inline memmove/memcpy despite having the must_preserve_cheri_tags property and the size not
; being a multiple of CAP_SIZE. Since the pointers are aligned we can start with capability copies and use
; word/byte copies for the trailing bytes.
declare void @llvm.memmove.p200i8.p200i8.i64(i8 addrspace(200)* nocapture, i8 addrspace(200)* nocapture readonly, i64, i1) addrspace(200)
declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* nocapture, i8 addrspace(200)* nocapture readonly, i64, i1) addrspace(200)

define void @test_string_memmove(i8 addrspace(200)* %dst, i8 addrspace(200)* %src) addrspace(200) nounwind {
  ; Note: has must_preserve_cheri_tags, but this memmove can still be inlined since it's aligned
; CHECK-LABEL: test_string_memmove:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cmove ca7, ca1
; CHECK-NEXT:    cmove ca1, ca0
; CHECK-NEXT:    lc ca0, 0(ca7)
; CHECK-NEXT:    lc ca2, 8(ca7)
; CHECK-NEXT:    lc ca3, 16(ca7)
; CHECK-NEXT:    lc ca4, 24(ca7)
; CHECK-NEXT:    lc ca5, 32(ca7)
; CHECK-NEXT:    lw a6, 40(ca7)
; CHECK-NEXT:    lb a7, 44(ca7)
; CHECK-NEXT:    sb a7, 44(ca1)
; CHECK-NEXT:    sw a6, 40(ca1)
; CHECK-NEXT:    sc ca5, 32(ca1)
; CHECK-NEXT:    sc ca4, 24(ca1)
; CHECK-NEXT:    sc ca3, 16(ca1)
; CHECK-NEXT:    sc ca2, 8(ca1)
; CHECK-NEXT:    sc ca0, 0(ca1)
; CHECK-NEXT:    ret
  call void @llvm.memmove.p200i8.p200i8.i64(i8 addrspace(200)* align 16 %dst, i8 addrspace(200)* align 16 %src, i64 45, i1 false) must_preserve_cheri_tags
  ret void
}

define void @test_string_memcpy(i8 addrspace(200)* %dst, i8 addrspace(200)* %src) addrspace(200) nounwind {
  ; Note: has must_preserve_cheri_tags, but this memcpy can still be inlined since it's aligned
; CHECK-LABEL: test_string_memcpy:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cincoffset csp, csp, -16
; CHECK-NEXT:    sc ca1, 8(csp) # 8-byte Folded Spill
; CHECK-NEXT:    cmove ca1, ca0
; CHECK-NEXT:    lc ca0, 8(csp) # 8-byte Folded Reload
; CHECK-NEXT:    lb a2, 44(ca0)
; CHECK-NEXT:    sb a2, 44(ca1)
; CHECK-NEXT:    lw a2, 40(ca0)
; CHECK-NEXT:    sw a2, 40(ca1)
; CHECK-NEXT:    lc ca2, 32(ca0)
; CHECK-NEXT:    sc ca2, 32(ca1)
; CHECK-NEXT:    lc ca2, 24(ca0)
; CHECK-NEXT:    sc ca2, 24(ca1)
; CHECK-NEXT:    lc ca2, 16(ca0)
; CHECK-NEXT:    sc ca2, 16(ca1)
; CHECK-NEXT:    lc ca2, 8(ca0)
; CHECK-NEXT:    sc ca2, 8(ca1)
; CHECK-NEXT:    lc ca0, 0(ca0)
; CHECK-NEXT:    sc ca0, 0(ca1)
; CHECK-NEXT:    cincoffset csp, csp, 16
; CHECK-NEXT:    ret
  call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 16 %dst, i8 addrspace(200)* align 16 %src, i64 45, i1 false) must_preserve_cheri_tags
  ret void
}
