; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/cap-from-ptr.ll
;; Check that we can correctly generate code for llvm.cheri.cap.from.pointer()
;; This previously asserted on RISC-V due to a broken ISel pattern.
;; We pipe this input through instcombine first to ensure SelectionDAG sees canonical IR.
; RUN: opt -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f -passes=instcombine -S < %s | FileCheck %s --check-prefix=CHECK-IR
; RUN: opt -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f -passes=instcombine -S < %s | not --crash llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f 2>&1 | FileCheck %s --check-prefix BAD-COPY
; RUN: opt -mtriple=riscv32 --relocation-model=pic -target-abi ilp32f -mattr=+xcheri,+f -passes=instcombine -S < %s | not --crash llc -mtriple=riscv32 --relocation-model=pic -target-abi ilp32f -mattr=+xcheri,+f 2>&1 | FileCheck %s --check-prefix BAD-COPY
; BAD-COPY: Impossible reg-to-reg copy

define internal i8 addrspace(200)* @test(i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %cap, i32 %offset) nounwind {
; CHECK-IR-LABEL: define {{[^@]+}}@test
; CHECK-IR-SAME: (i8 addrspace(200)* addrspace(200)* [[PTR:%.*]], i8 addrspace(200)* [[CAP:%.*]], i32 [[OFFSET:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[NEW:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* [[CAP]], i32 [[OFFSET]])
; CHECK-IR-NEXT:    store i8 addrspace(200)* [[NEW]], i8 addrspace(200)* addrspace(200)* [[PTR]], align 16
; CHECK-IR-NEXT:    ret i8 addrspace(200)* [[NEW]]
;
entry:
  %new = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* %cap, i32 %offset)
  store i8 addrspace(200)* %new, i8 addrspace(200)* addrspace(200)* %ptr, align 16
  ret i8 addrspace(200)* %new
}

;; (int_cheri_cap_from_ptr x, 0) -> null
define internal i8 addrspace(200)* @cap_from_ptr_zero(i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %cap) nounwind {
; CHECK-IR-LABEL: define {{[^@]+}}@cap_from_ptr_zero
; CHECK-IR-SAME: (i8 addrspace(200)* addrspace(200)* [[PTR:%.*]], i8 addrspace(200)* [[CAP:%.*]]) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[NEW:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* [[CAP]], i32 0)
; CHECK-IR-NEXT:    store i8 addrspace(200)* [[NEW]], i8 addrspace(200)* addrspace(200)* [[PTR]], align 16
; CHECK-IR-NEXT:    ret i8 addrspace(200)* [[NEW]]
;
entry:
  %new = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* %cap, i32 0)
  store i8 addrspace(200)* %new, i8 addrspace(200)* addrspace(200)* %ptr, align 16
  ret i8 addrspace(200)* %new
}

;; Check that (int_cheri_cap_from_ptr ddc, x) can use the DDC register directly
define internal i8 addrspace(200)* @cap_from_ptr_ddc(i8 addrspace(200)* addrspace(200)* %ptr, i32 %offset) nounwind {
; CHECK-IR-LABEL: define {{[^@]+}}@cap_from_ptr_ddc
; CHECK-IR-SAME: (i8 addrspace(200)* addrspace(200)* [[PTR:%.*]], i32 [[OFFSET:%.*]]) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[DDC:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
; CHECK-IR-NEXT:    [[NEW:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* [[DDC]], i32 [[OFFSET]])
; CHECK-IR-NEXT:    store i8 addrspace(200)* [[NEW]], i8 addrspace(200)* addrspace(200)* [[PTR]], align 16
; CHECK-IR-NEXT:    ret i8 addrspace(200)* [[NEW]]
;
entry:
  %ddc = call i8 addrspace(200)* @llvm.cheri.ddc.get()
  %new = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* %ddc, i32 %offset)
  store i8 addrspace(200)* %new, i8 addrspace(200)* addrspace(200)* %ptr, align 16
  ret i8 addrspace(200)* %new
}

;; Check that (int_cheri_cap_from_ptr x, 0) -> null has priority over direct DDC usage
define internal i8 addrspace(200)* @cap_from_ptr_ddc_zero(i8 addrspace(200)* addrspace(200)* %ptr) nounwind {
; CHECK-IR-LABEL: define {{[^@]+}}@cap_from_ptr_ddc_zero
; CHECK-IR-SAME: (i8 addrspace(200)* addrspace(200)* [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[DDC:%.*]] = call i8 addrspace(200)* @llvm.cheri.ddc.get()
; CHECK-IR-NEXT:    [[NEW:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* [[DDC]], i32 0)
; CHECK-IR-NEXT:    store i8 addrspace(200)* [[NEW]], i8 addrspace(200)* addrspace(200)* [[PTR]], align 16
; CHECK-IR-NEXT:    ret i8 addrspace(200)* [[NEW]]
;
entry:
  %ddc = call i8 addrspace(200)* @llvm.cheri.ddc.get()
  %new = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* %ddc, i32 0)
  store i8 addrspace(200)* %new, i8 addrspace(200)* addrspace(200)* %ptr, align 16
  ret i8 addrspace(200)* %new
}

;; Check that (int_cheri_cap_from_ptr null, x) does not use register zero (since that is DDC)
define internal i8 addrspace(200)* @cap_from_ptr_null(i8 addrspace(200)* addrspace(200)* %ptr, i32 %offset) nounwind {
; CHECK-IR-LABEL: define {{[^@]+}}@cap_from_ptr_null
; CHECK-IR-SAME: (i8 addrspace(200)* addrspace(200)* [[PTR:%.*]], i32 [[OFFSET:%.*]]) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[NEW:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* null, i32 [[OFFSET]])
; CHECK-IR-NEXT:    store i8 addrspace(200)* [[NEW]], i8 addrspace(200)* addrspace(200)* [[PTR]], align 16
; CHECK-IR-NEXT:    ret i8 addrspace(200)* [[NEW]]
;
entry:
  %new = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)* null, i32 %offset)
  store i8 addrspace(200)* %new, i8 addrspace(200)* addrspace(200)* %ptr, align 16
  ret i8 addrspace(200)* %new
}

declare i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i32(i8 addrspace(200)*, i32)
declare i8 addrspace(200)* @llvm.cheri.ddc.get()
