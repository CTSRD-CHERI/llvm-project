; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/bounded-allocas-lifetimes.ll
; CHERI-GENERIC-UTC: mir
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f %s -o - --stop-after=finalize-isel | FileCheck %s

; Check that lifetime markers don't get lost due to CheriBoundAllocas, as we'd
; risk StackSlotColoring reusing the slot.

declare void @use(i8 addrspace(200)*)

define void @static_alloca() {
  ; CHECK-LABEL: name: static_alloca
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   [[CIncOffsetImm:%[0-9]+]]:gpcr = CIncOffsetImm %stack.0, 0
  ; CHECK-NEXT:   [[CSetBoundsImm:%[0-9]+]]:gpcr = CSetBoundsImm killed [[CIncOffsetImm]], 4
  ; CHECK-NEXT:   LIFETIME_START %stack.0
  ; CHECK-NEXT:   ADJCALLSTACKDOWNCAP 0, 0, implicit-def dead $c2, implicit $c2
  ; CHECK-NEXT:   $c10 = COPY [[CSetBoundsImm]]
  ; CHECK-NEXT:   PseudoCCALL target-flags(riscv-ccall) @use, csr_il32pc64f_l64pc128f, implicit-def dead $c1, implicit $c10, implicit-def $c2
  ; CHECK-NEXT:   ADJCALLSTACKUPCAP 0, 0, implicit-def dead $c2, implicit $c2
  ; CHECK-NEXT:   LIFETIME_END %stack.0
  ; CHECK-NEXT:   PseudoCRET
  %1 = alloca i32, align 4, addrspace(200)
  %2 = bitcast i32 addrspace(200)* %1 to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* %2)
  call void @use(i8 addrspace(200)* %2)
  call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* %2)
  ret void
}

; LIFETIME_START/LIFETIME_END only apply to static allocas, so we can't verify
; that the analysis works correctly, but the IR is here for completeness.
define void @dynamic_alloca(i64 zeroext %n) {
  ; CHECK-LABEL: name: dynamic_alloca
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $x10
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr = COPY $x10
  ; CHECK-NEXT:   ADJCALLSTACKDOWNCAP 0, 0, implicit-def dead $c2, implicit $c2
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpcr = COPY $c2
  ; CHECK-NEXT:   [[PseudoCGetAddr:%[0-9]+]]:gpr = PseudoCGetAddr [[COPY1]]
  ; CHECK-NEXT:   [[SLLI:%[0-9]+]]:gpr = SLLI [[COPY]], 2
  ; CHECK-NEXT:   [[ADDI:%[0-9]+]]:gpr = nuw ADDI [[SLLI]], 15
  ; CHECK-NEXT:   [[ANDI:%[0-9]+]]:gpr = ANDI killed [[ADDI]], -16
  ; CHECK-NEXT:   [[CRRL:%[0-9]+]]:gpr = CRRL [[ANDI]]
  ; CHECK-NEXT:   [[SUB:%[0-9]+]]:gpr = SUB killed [[PseudoCGetAddr]], [[CRRL]]
  ; CHECK-NEXT:   [[CRAM:%[0-9]+]]:gpr = CRAM [[ANDI]]
  ; CHECK-NEXT:   [[AND:%[0-9]+]]:gpr = AND killed [[SUB]], killed [[CRAM]]
  ; CHECK-NEXT:   [[CSetAddr:%[0-9]+]]:gpcr = CSetAddr [[COPY1]], killed [[AND]]
  ; CHECK-NEXT:   [[CSetBounds:%[0-9]+]]:gpcr = CSetBounds [[CSetAddr]], [[CRRL]]
  ; CHECK-NEXT:   $c2 = COPY [[CSetAddr]]
  ; CHECK-NEXT:   ADJCALLSTACKUPCAP 0, 0, implicit-def dead $c2, implicit $c2
  ; CHECK-NEXT:   [[CSetBounds1:%[0-9]+]]:gpcr = CSetBounds killed [[CSetBounds]], [[SLLI]]
  ; CHECK-NEXT:   ADJCALLSTACKDOWNCAP 0, 0, implicit-def dead $c2, implicit $c2
  ; CHECK-NEXT:   $c10 = COPY [[CSetBounds1]]
  ; CHECK-NEXT:   PseudoCCALL target-flags(riscv-ccall) @use, csr_il32pc64f_l64pc128f, implicit-def dead $c1, implicit $c10, implicit-def $c2
  ; CHECK-NEXT:   ADJCALLSTACKUPCAP 0, 0, implicit-def dead $c2, implicit $c2
  ; CHECK-NEXT:   PseudoCRET
  %1 = alloca i32, i64 %n, align 4, addrspace(200)
  %2 = bitcast i32 addrspace(200)* %1 to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 -1, i8 addrspace(200)* %2)
  call void @use(i8 addrspace(200)* %2)
  call void @llvm.lifetime.end.p200i8(i64 -1, i8 addrspace(200)* %2)
  ret void
}

declare void @llvm.lifetime.start.p200i8(i64, i8 addrspace(200)*)
declare void @llvm.lifetime.end.p200i8(i64, i8 addrspace(200)*)
