; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --force-update --function-signature --scrub-attributes
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/setoffset-multiple-uses.ll
; RUN: opt -S -instcombine -o - %s | FileCheck %s
; RUN: opt -S -instcombine -o - %s | %riscv32_cheri_purecap_llc -O1 - -o - | %cheri_FileCheck %s --check-prefix ASM
; FIXME: RISCV still inefficient!

target datalayout = "e-m:e-pf200:64:64:64:32-p:32:32-i64:64-n32-S128-A200-P200-G200"
; Reduced test case for a crash in the new optimization to fold multiple setoffset calls (orignally found when compiling libunwind)

declare i32 @check_fold(i32) addrspace(200)
declare void @check_fold_i8ptr(i8 addrspace(200)*) addrspace(200)
declare i32 @llvm.cheri.cap.offset.get.i32(i8 addrspace(200)*) addrspace(200)
declare i8 addrspace(200)* @llvm.cheri.cap.offset.set.i32(i8 addrspace(200)*, i32) addrspace(200)

define void @infer_values_from_null_set_offset() addrspace(200) nounwind {
; ASM-LABEL: infer_values_from_null_set_offset:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset csp, csp, -16
; ASM-NEXT:    csc cra, 8(csp)
; ASM-NEXT:  .LBB0_1: # Label of block must be emitted
; ASM-NEXT:    auipcc ca1, %captab_pcrel_hi(check_fold)
; ASM-NEXT:    clc ca1, %pcrel_lo(.LBB0_1)(ca1)
; ASM-NEXT:    lui a0, 30
; ASM-NEXT:    addi a0, a0, 576
; ASM-NEXT:    cjalr ca1
; ASM-NEXT:    clc cra, 8(csp)
; ASM-NEXT:    cincoffset csp, csp, 16
; ASM-NEXT:    cret
; CHECK-LABEL: define {{[^@]+}}@infer_values_from_null_set_offset() addrspace(200)
; CHECK-NEXT:    [[OFFSET_CHECK:%.*]] = call i32 @check_fold(i32 123456)
; CHECK-NEXT:    ret void
;
  %with_offset = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i32(i8 addrspace(200)* null, i32 123456)
  %offset = call i32 @llvm.cheri.cap.offset.get.i32(i8 addrspace(200)* nonnull %with_offset)
  %offset_check = call i32 @check_fold(i32 %offset)
  ret void
}

define void @multiple_uses_big_constant() addrspace(200) nounwind {
; ASM-LABEL: multiple_uses_big_constant:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset csp, csp, -32
; ASM-NEXT:    csc cra, 24(csp)
; ASM-NEXT:    csc cs0, 16(csp)
; ASM-NEXT:    csc cs1, 8(csp)
; ASM-NEXT:    lui a0, 30
; ASM-NEXT:    addi a0, a0, 576
; ASM-NEXT:    cincoffset cs0, cnull, a0
; ASM-NEXT:  .LBB1_1: # Label of block must be emitted
; ASM-NEXT:    auipcc cs1, %captab_pcrel_hi(check_fold_i8ptr)
; ASM-NEXT:    clc cs1, %pcrel_lo(.LBB1_1)(cs1)
; ASM-NEXT:    cmove ca0, cs0
; ASM-NEXT:    cjalr cs1
; ASM-NEXT:    cmove ca0, cs0
; ASM-NEXT:    cjalr cs1
; ASM-NEXT:    cmove ca0, cs0
; ASM-NEXT:    cjalr cs1
; ASM-NEXT:    clc cs1, 8(csp)
; ASM-NEXT:    clc cs0, 16(csp)
; ASM-NEXT:    clc cra, 24(csp)
; ASM-NEXT:    cincoffset csp, csp, 32
; ASM-NEXT:    cret
; CHECK-LABEL: define {{[^@]+}}@multiple_uses_big_constant() addrspace(200)
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i32 123456))
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i32 123456))
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i32 123456))
; CHECK-NEXT:    ret void
;
  %with_offset = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i32(i8 addrspace(200)* null, i32 123456)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  ret void
}

; Here we should use an immediate cincoffset:
define void @multiple_uses_small_constant() addrspace(200) nounwind {
; ASM-LABEL: multiple_uses_small_constant:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset csp, csp, -32
; ASM-NEXT:    csc cra, 24(csp)
; ASM-NEXT:    csc cs0, 16(csp)
; ASM-NEXT:    csc cs1, 8(csp)
; ASM-NEXT:  .LBB2_1: # Label of block must be emitted
; ASM-NEXT:    auipcc cs1, %captab_pcrel_hi(check_fold_i8ptr)
; ASM-NEXT:    clc cs1, %pcrel_lo(.LBB2_1)(cs1)
; ASM-NEXT:    cincoffset cs0, cnull, 123
; ASM-NEXT:    cmove ca0, cs0
; ASM-NEXT:    cjalr cs1
; ASM-NEXT:    cmove ca0, cs0
; ASM-NEXT:    cjalr cs1
; ASM-NEXT:    cmove ca0, cs0
; ASM-NEXT:    cjalr cs1
; ASM-NEXT:    clc cs1, 8(csp)
; ASM-NEXT:    clc cs0, 16(csp)
; ASM-NEXT:    clc cra, 24(csp)
; ASM-NEXT:    cincoffset csp, csp, 32
; ASM-NEXT:    cret
; CHECK-LABEL: define {{[^@]+}}@multiple_uses_small_constant() addrspace(200)
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i32 123))
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i32 123))
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i32 123))
; CHECK-NEXT:    ret void
;
  %with_offset = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i32(i8 addrspace(200)* null, i32 123)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  ret void
}
