; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --scrub-attributes --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/ptradd-immediate.ll
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+xcheri,+cap-mode,+f < %s | FileCheck %s --check-prefix=PURECAP
;; Hybrid baseline to compare against
; RUN: sed 's/addrspace(200)//g' %s | llc -mtriple=riscv32 --relocation-model=pic -target-abi ilp32f -mattr=+xcheri,+f | FileCheck %s --check-prefix=HYBRID

;; If both offsets are known to be non-negative it is safe to commute them and
;; use an immediate load.
define i32 @nneg_nneg(ptr addrspace(200) %p, i16 %x) {
; PURECAP-LABEL: nneg_nneg:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    slli a1, a1, 16
; PURECAP-NEXT:    srli a1, a1, 16
; PURECAP-NEXT:    slli a1, a1, 2
; PURECAP-NEXT:    cincoffset ca0, ca0, a1
; PURECAP-NEXT:    lw a0, 4(ca0)
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: nneg_nneg:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    slli a1, a1, 16
; HYBRID-NEXT:    srli a1, a1, 16
; HYBRID-NEXT:    slli a1, a1, 2
; HYBRID-NEXT:    add a0, a0, a1
; HYBRID-NEXT:    lw a0, 4(a0)
; HYBRID-NEXT:    ret
  %x.ext = zext i16 %x to i64
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 1, i64 %x.ext
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If both offsets are known to be negative it is safe to commute them and use
;; an immediate load.
define i32 @neg_neg(ptr addrspace(200) %p, i16 %x) {
; PURECAP-LABEL: neg_neg:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    ori a1, a1, 1
; PURECAP-NEXT:    slli a1, a1, 16
; PURECAP-NEXT:    srli a1, a1, 16
; PURECAP-NEXT:    neg a1, a1
; PURECAP-NEXT:    slli a1, a1, 2
; PURECAP-NEXT:    cincoffset ca0, ca0, a1
; PURECAP-NEXT:    lw a0, -4(ca0)
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: neg_neg:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    ori a1, a1, 1
; HYBRID-NEXT:    slli a1, a1, 16
; HYBRID-NEXT:    srli a1, a1, 16
; HYBRID-NEXT:    slli a1, a1, 2
; HYBRID-NEXT:    sub a0, a0, a1
; HYBRID-NEXT:    lw a0, -4(a0)
; HYBRID-NEXT:    ret
  %x.ext = zext i16 %x to i64
  %x.pos = or i64 %x.ext, 1
  %x.neg = sub i64 0, %x.pos
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 -1, i64 %x.neg
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If one offset is known to be non-negative and the other negative it is not in
;; general safe to commute them and use an immediate load.
define i32 @nneg_neg(ptr addrspace(200) %p, i16 %x) {
; PURECAP-LABEL: nneg_neg:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    ori a1, a1, 1
; PURECAP-NEXT:    slli a1, a1, 16
; PURECAP-NEXT:    srli a1, a1, 16
; PURECAP-NEXT:    slli a1, a1, 2
; PURECAP-NEXT:    li a2, 4
; PURECAP-NEXT:    sub a2, a2, a1
; PURECAP-NEXT:    cincoffset ca0, ca0, a2
; PURECAP-NEXT:    lw a0, 0(ca0)
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: nneg_neg:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    ori a1, a1, 1
; HYBRID-NEXT:    slli a1, a1, 16
; HYBRID-NEXT:    srli a1, a1, 16
; HYBRID-NEXT:    slli a1, a1, 2
; HYBRID-NEXT:    sub a0, a0, a1
; HYBRID-NEXT:    lw a0, 4(a0)
; HYBRID-NEXT:    ret
  %x.ext = zext i16 %x to i64
  %x.pos = or i64 %x.ext, 1
  %x.neg = sub i64 0, %x.pos
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 1, i64 %x.neg
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If one offset is known to be non-negative and the other negative it is not in
;; general safe to commute them and use an immediate load.
define i32 @neg_nneg(ptr addrspace(200) %p, i16 %x) {
; PURECAP-LABEL: neg_nneg:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    slli a1, a1, 16
; PURECAP-NEXT:    srli a1, a1, 16
; PURECAP-NEXT:    slli a1, a1, 2
; PURECAP-NEXT:    addi a1, a1, -4
; PURECAP-NEXT:    cincoffset ca0, ca0, a1
; PURECAP-NEXT:    lw a0, 0(ca0)
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: neg_nneg:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    slli a1, a1, 16
; HYBRID-NEXT:    srli a1, a1, 16
; HYBRID-NEXT:    slli a1, a1, 2
; HYBRID-NEXT:    add a0, a0, a1
; HYBRID-NEXT:    lw a0, -4(a0)
; HYBRID-NEXT:    ret
  %x.ext = zext i16 %x to i64
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 -1, i64 %x.ext
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If we do not know the sign of one offset it is not in general safe to
;; commute them and use an immediate load.
define i32 @nneg_unknown(ptr addrspace(200) %p, i64 %x) {
; PURECAP-LABEL: nneg_unknown:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    slli a1, a1, 2
; PURECAP-NEXT:    addi a1, a1, 4
; PURECAP-NEXT:    cincoffset ca0, ca0, a1
; PURECAP-NEXT:    lw a0, 0(ca0)
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: nneg_unknown:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    slli a1, a1, 2
; HYBRID-NEXT:    add a0, a0, a1
; HYBRID-NEXT:    lw a0, 4(a0)
; HYBRID-NEXT:    ret
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 1, i64 %x
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If we do not know the sign of one offset it is not in general safe to
;; commute them and use an immediate load.
define i32 @neg_unknown(ptr addrspace(200) %p, i64 %x) {
; PURECAP-LABEL: neg_unknown:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    slli a1, a1, 2
; PURECAP-NEXT:    addi a1, a1, -4
; PURECAP-NEXT:    cincoffset ca0, ca0, a1
; PURECAP-NEXT:    lw a0, 0(ca0)
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: neg_unknown:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    slli a1, a1, 2
; HYBRID-NEXT:    add a0, a0, a1
; HYBRID-NEXT:    lw a0, -4(a0)
; HYBRID-NEXT:    ret
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 -1, i64 %x
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}
