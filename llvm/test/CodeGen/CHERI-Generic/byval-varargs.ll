; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --extra_scrub
; Check that we can handle varargs functions with byval arguments
; First check that non-CHERI targets add a memcpy
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/p200i8/p0i8/g' %s | llc -mtriple riscv64-unknown-freebsd -o - -relocation-model=pic | FileCheck %s --check-prefixes RV64
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/p200i8/p0i8/g' %s | llc -mtriple mips64-unknown-freebsd -o - -relocation-model=pic  | FileCheck %s --check-prefixes MIPS
; Next check purecap targets:
; RUN: %riscv64_cheri_purecap_llc -o - %s | FileCheck %s --check-prefixes PURECAP-RV64
; RUN: %cheri_purecap_llc -o - %s | FileCheck %s --check-prefixes PURECAP-MIPS


; Note: This test case was generated from the following C
; int varargs(int, ...);
; struct Foo { char x[1024]; };
; int byref(struct Foo*);
; int test() {
;   struct Foo f;
;   __builtin_memset(&f, 0, sizeof(f));
;   byref(&f);
;   return varargs(sizeof(f), f);
; }
;
; The clang frontend uses byval arguments for MIPS and local allocas for RISC-V
; Check that we can handle both kinds of IR in either backend


%struct.Foo = type { [1024 x i8] }

; Function Attrs: nounwind
define signext i32 @test_alloca() local_unnamed_addr addrspace(200) #0 {
; RV64-LABEL: test_alloca:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    addi sp, sp, -2032
; RV64-NEXT:    sd ra, 2024(sp)
; RV64-NEXT:    addi sp, sp, -32
; RV64-NEXT:    addi a0, sp, 1032
; RV64-NEXT:    addi a2, zero, 1024
; RV64-NEXT:    mv a1, zero
; RV64-NEXT:    call memset@plt
; RV64-NEXT:    addi a0, sp, 1032
; RV64-NEXT:    call byref@plt
; RV64-NEXT:    addi a0, sp, 8
; RV64-NEXT:    addi a1, sp, 1032
; RV64-NEXT:    addi a2, zero, 1024
; RV64-NEXT:    call memcpy@plt
; RV64-NEXT:    addi a0, zero, 1024
; RV64-NEXT:    addi a1, sp, 8
; RV64-NEXT:    call varargs@plt
; RV64-NEXT:    addi sp, sp, 32
; RV64-NEXT:    ld ra, 2024(sp)
; RV64-NEXT:    addi sp, sp, 2032
; RV64-NEXT:    ret
;
; MIPS-LABEL: test_alloca:
; MIPS:       # %bb.0: # %entry
; MIPS-NEXT:    daddiu $sp, $sp, -2080
; MIPS-NEXT:    sd $ra, 2072($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $gp, 2064($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $17, 2056($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $16, 2048($sp) # 8-byte Folded Spill
; MIPS-NEXT:    lui $1, %hi(%neg(%gp_rel(test_alloca)))
; MIPS-NEXT:    daddu $1, $1, $25
; MIPS-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(test_alloca)))
; MIPS-NEXT:    daddiu $16, $sp, 1024
; MIPS-NEXT:    ld $25, %call16(memset)($gp)
; MIPS-NEXT:    move $4, $16
; MIPS-NEXT:    daddiu $5, $zero, 0
; MIPS-NEXT:    .reloc .Ltmp0, R_MIPS_JALR, memset
; MIPS-NEXT:  .Ltmp0:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $6, $zero, 1024
; MIPS-NEXT:    ld $25, %call16(byref)($gp)
; MIPS-NEXT:    .reloc .Ltmp1, R_MIPS_JALR, byref
; MIPS-NEXT:  .Ltmp1:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    move $4, $16
; MIPS-NEXT:    daddiu $17, $sp, 0
; MIPS-NEXT:    ld $25, %call16(memcpy)($gp)
; MIPS-NEXT:    move $4, $17
; MIPS-NEXT:    move $5, $16
; MIPS-NEXT:    .reloc .Ltmp2, R_MIPS_JALR, memcpy
; MIPS-NEXT:  .Ltmp2:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $6, $zero, 1024
; MIPS-NEXT:    ld $25, %call16(varargs)($gp)
; MIPS-NEXT:    daddiu $4, $zero, 1024
; MIPS-NEXT:    .reloc .Ltmp3, R_MIPS_JALR, varargs
; MIPS-NEXT:  .Ltmp3:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    move $5, $17
; MIPS-NEXT:    sll $2, $2, 0
; MIPS-NEXT:    ld $16, 2048($sp) # 8-byte Folded Reload
; MIPS-NEXT:    ld $17, 2056($sp) # 8-byte Folded Reload
; MIPS-NEXT:    ld $gp, 2064($sp) # 8-byte Folded Reload
; MIPS-NEXT:    ld $ra, 2072($sp) # 8-byte Folded Reload
; MIPS-NEXT:    jr $ra
; MIPS-NEXT:    daddiu $sp, $sp, 2080
;
; PURECAP-RV64-LABEL: test_alloca:
; PURECAP-RV64:       # %bb.0: # %entry
; PURECAP-RV64-NEXT:    cincoffset csp, csp, -2032
; PURECAP-RV64-NEXT:    csc cra, 2016(csp)
; PURECAP-RV64-NEXT:    csc cs0, 2000(csp)
; PURECAP-RV64-NEXT:    csc cs1, 1984(csp)
; PURECAP-RV64-NEXT:    cincoffset csp, csp, -96
; PURECAP-RV64-NEXT:    cincoffset ca0, csp, 1056
; PURECAP-RV64-NEXT:    csetbounds cs0, ca0, 1024
; PURECAP-RV64-NEXT:    addi a2, zero, 1024
; PURECAP-RV64-NEXT:    cmove ca0, cs0
; PURECAP-RV64-NEXT:    mv a1, zero
; PURECAP-RV64-NEXT:    ccall memset
; PURECAP-RV64-NEXT:    cmove ca0, cs0
; PURECAP-RV64-NEXT:    ccall byref
; PURECAP-RV64-NEXT:    cincoffset ca0, csp, 32
; PURECAP-RV64-NEXT:    csetbounds cs1, ca0, 1024
; PURECAP-RV64-NEXT:    addi a2, zero, 1024
; PURECAP-RV64-NEXT:    cmove ca0, cs1
; PURECAP-RV64-NEXT:    cmove ca1, cs0
; PURECAP-RV64-NEXT:    ccall memcpy
; PURECAP-RV64-NEXT:    addi a0, zero, 1024
; PURECAP-RV64-NEXT:    csc cs1, 0(csp)
; PURECAP-RV64-NEXT:    ccall varargs
; PURECAP-RV64-NEXT:    cincoffset csp, csp, 96
; PURECAP-RV64-NEXT:    clc cs1, 1984(csp)
; PURECAP-RV64-NEXT:    clc cs0, 2000(csp)
; PURECAP-RV64-NEXT:    clc cra, 2016(csp)
; PURECAP-RV64-NEXT:    cincoffset csp, csp, 2032
; PURECAP-RV64-NEXT:    cret
;
; PURECAP-MIPS-LABEL: test_alloca:
; PURECAP-MIPS:       # %bb.0: # %entry
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, -2128
; PURECAP-MIPS-NEXT:    cincoffset $c11, $c11, $1
; PURECAP-MIPS-NEXT:    csc $c19, $zero, 2112($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    csc $c18, $zero, 2096($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    csc $c17, $zero, 2080($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-MIPS-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-MIPS-NEXT:    cgetpccincoffset $c18, $1
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(memset)($c18)
; Note: we rematerialize the bounded var here to avoid spilling to the stack:
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, 1056
; PURECAP-MIPS-NEXT:    cincoffset $c3, $c11, $1
; PURECAP-MIPS-NEXT:    csetbounds $c3, $c3, 1024
; PURECAP-MIPS-NEXT:    daddiu $4, $zero, 0
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    daddiu $5, $zero, 1024
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(byref)($c18)
; Note: we rematerialize the bounded var here to avoid spilling to the stack:
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, 1056
; PURECAP-MIPS-NEXT:    cincoffset $c3, $c11, $1
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    csetbounds $c3, $c3, 1024
; PURECAP-MIPS-NEXT:    cincoffset $c19, $c11, 32
; PURECAP-MIPS-NEXT:    csetbounds $c19, $c19, 1024
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(memcpy)($c18)
; PURECAP-MIPS-NEXT:    cincoffset $c3, $c11, 32
; PURECAP-MIPS-NEXT:    csetbounds $c3, $c3, 1024
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, 1056
; PURECAP-MIPS-NEXT:    cincoffset $c4, $c11, $1
; PURECAP-MIPS-NEXT:    csetbounds $c4, $c4, 1024
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    daddiu $4, $zero, 1024
; Save bounded byval copy to the stack and indirectly pass a bounded cap in $c13:
; Note: could probably rematerialize here instead of spilling the bounded cap in $c19
; PURECAP-MIPS-NEXT:    csc $c19, $zero, 0($c11)
; PURECAP-MIPS-NEXT:    csetbounds $c1, $c11, 16
; PURECAP-MIPS-NEXT:    ori $1, $zero, 65495
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(varargs)($c18)
; PURECAP-MIPS-NEXT:    candperm $c13, $c1, $1
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    daddiu $4, $zero, 1024
; PURECAP-MIPS-NEXT:    sll $2, $2, 0
; PURECAP-MIPS-NEXT:    clc $c17, $zero, 2080($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    clc $c18, $zero, 2096($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    clc $c19, $zero, 2112($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, 2128
; PURECAP-MIPS-NEXT:    cjr $c17
; PURECAP-MIPS-NEXT:    cincoffset $c11, $c11, $1

entry:
  %f = alloca %struct.Foo, align 1, addrspace(200)
  %byval-temp = alloca %struct.Foo, align 1, addrspace(200)
  %0 = getelementptr inbounds %struct.Foo, %struct.Foo addrspace(200)* %f, i64 0, i32 0, i64 0
  call void @llvm.lifetime.start.p200i8(i64 1024, i8 addrspace(200)* nonnull %0) #4
  call void @llvm.memset.p200i8.i64(i8 addrspace(200)* nonnull align 1 dereferenceable(1024) %0, i8 0, i64 1024, i1 false)
  %call = call signext i32 @byref(%struct.Foo addrspace(200)* nonnull %f) #4
  %1 = getelementptr inbounds %struct.Foo, %struct.Foo addrspace(200)* %byval-temp, i64 0, i32 0, i64 0
  call void @llvm.lifetime.start.p200i8(i64 1024, i8 addrspace(200)* nonnull %1) #4
  call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* nonnull align 1 dereferenceable(1024) %1, i8 addrspace(200)* nonnull align 1 dereferenceable(1024) %0, i64 1024, i1 false)
  %call1 = call signext i32 (i32, ...) @varargs(i32 signext 1024, %struct.Foo addrspace(200)* nonnull %byval-temp) #4
  call void @llvm.lifetime.end.p200i8(i64 1024, i8 addrspace(200)* nonnull %1) #4
  call void @llvm.lifetime.end.p200i8(i64 1024, i8 addrspace(200)* nonnull %0) #4
  ret i32 %call1
}

; Function Attrs: nounwind
define signext i32 @test_byval() local_unnamed_addr addrspace(200) #0 {
; The RV64 Stack frame size should be > 2048 (split into two instructions)
; RV64-LABEL: test_byval:
; RV64:       # %bb.0: # %entry
; RV64-NEXT:    addi sp, sp, -2032
; RV64-NEXT:    sd ra, 2024(sp)
; RV64-NEXT:    addi sp, sp, -32
; RV64-NEXT:    addi a0, sp, 1032
; RV64-NEXT:    addi a2, zero, 1024
; RV64-NEXT:    mv a1, zero
; RV64-NEXT:    call memset@plt
; RV64-NEXT:    addi a0, sp, 1032
; RV64-NEXT:    call byref@plt
; RV64-NEXT:    addi a0, sp, 8
; RV64-NEXT:    addi a1, sp, 1032
; RV64-NEXT:    addi a2, zero, 1024
; Call memcpy for local alloca: dst=sp+8, src=sp+1032, size=1024
; RV64-NEXT:    call memcpy@plt
; RV64-NEXT:    addi a0, zero, 1024
; RV64-NEXT:    addi a1, sp, 8
; RV64-NEXT:    call varargs@plt
; RV64-NEXT:    addi sp, sp, 32
; RV64-NEXT:    ld ra, 2024(sp)
; RV64-NEXT:    addi sp, sp, 2032
; RV64-NEXT:    ret
;
; MIPS-LABEL: test_byval:
; Note: MIPS n64 passes up to the first 64 bytes of byval arguments in registers:
; Stack frame size should be just under 2048:
; MIPS:       # %bb.0: # %entry
; MIPS-NEXT:    daddiu $sp, $sp, -2032
; MIPS-NEXT:    sd $ra, 2024($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $gp, 2016($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $16, 2008($sp) # 8-byte Folded Spill
; MIPS-NEXT:    lui $1, %hi(%neg(%gp_rel(test_byval)))
; MIPS-NEXT:    daddu $1, $1, $25
; MIPS-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(test_byval)))
; MIPS-NEXT:    daddiu $16, $sp, 984
; MIPS-NEXT:    ld $25, %call16(memset)($gp)
; MIPS-NEXT:    move $4, $16
; MIPS-NEXT:    daddiu $5, $zero, 0
; MIPS-NEXT:    .reloc .Ltmp4, R_MIPS_JALR, memset
; MIPS-NEXT:  .Ltmp4:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $6, $zero, 1024
; MIPS-NEXT:    ld $25, %call16(byref)($gp)
; MIPS-NEXT:    .reloc .Ltmp5, R_MIPS_JALR, byref
; MIPS-NEXT:  .Ltmp5:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    move $4, $16
; MIPS-NEXT:    daddiu $5, $16, 56
; memcpy for local alloca: dst=BYVAL_COPY[56..1024]=$sp, src=LOCAL_VAR+56, size=1024-56=968
; MIPS-NEXT:    ld $25, %call16(memcpy)($gp)
; MIPS-NEXT:    move $4, $sp
; MIPS-NEXT:    .reloc .Ltmp6, R_MIPS_JALR, memcpy
; MIPS-NEXT:  .Ltmp6:
; MIPS-NEXT:    jalr $25
; varargs() should use the byval copy:
; Note: rest of arguments on stack
; MIPS-NEXT:    daddiu $6, $zero, 968
; MIPS-NEXT:    ld $11, 1032($sp)
; MIPS-NEXT:    ld $10, 1024($sp)
; MIPS-NEXT:    ld $9, 1016($sp)
; MIPS-NEXT:    ld $8, 1008($sp)
; MIPS-NEXT:    ld $7, 1000($sp)
; MIPS-NEXT:    ld $6, 992($sp)
; MIPS-NEXT:    ld $5, 984($sp)
; MIPS-NEXT:    ld $25, %call16(varargs)($gp)
; MIPS-NEXT:    .reloc .Ltmp7, R_MIPS_JALR, varargs
; MIPS-NEXT:  .Ltmp7:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $4, $zero, 1024
; MIPS-NEXT:    sll $2, $2, 0
; MIPS-NEXT:    ld $16, 2008($sp) # 8-byte Folded Reload
; MIPS-NEXT:    ld $gp, 2016($sp) # 8-byte Folded Reload
; MIPS-NEXT:    ld $ra, 2024($sp) # 8-byte Folded Reload
; MIPS-NEXT:    jr $ra
; MIPS-NEXT:    daddiu $sp, $sp, 2032
;
; PURECAP-RV64-LABEL: test_byval:
; Stack frame size should be > 2048 (split into two instructions)
; PURECAP-RV64:       # %bb.0: # %entry
; PURECAP-RV64-NEXT:    cincoffset csp, csp, -2032
; PURECAP-RV64-NEXT:    csc cra, 2016(csp)
; PURECAP-RV64-NEXT:    csc cs0, 2000(csp)
; PURECAP-RV64-NEXT:    csc cs1, 1984(csp)
; PURECAP-RV64-NEXT:    cincoffset csp, csp, -96
; PURECAP-RV64-NEXT:    cincoffset ca0, csp, 1056
; PURECAP-RV64-NEXT:    csetbounds cs0, ca0, 1024
; PURECAP-RV64-NEXT:    addi a2, zero, 1024
; PURECAP-RV64-NEXT:    cmove ca0, cs0
; PURECAP-RV64-NEXT:    mv a1, zero
; PURECAP-RV64-NEXT:    ccall memset
; PURECAP-RV64-NEXT:    cmove ca0, cs0
; PURECAP-RV64-NEXT:    ccall byref
; PURECAP-RV64-NEXT:    cincoffset ca0, csp, 32
; PURECAP-RV64-NEXT:    addi a2, zero, 1024
; PURECAP-RV64-NEXT:    cincoffset cs1, csp, 32
; PURECAP-RV64-NEXT:    cmove ca1, cs0
; Note: no bounds for implicit byval arg memcpy()
; TODO: should we add the csetbounds here? Not really necessary if we trust memcpy().
; PURECAP-RV64-NEXT:    ccall memcpy
; PURECAP-RV64-NEXT:    addi a0, zero, 1024
; PURECAP-RV64-NEXT:    csc cs1, 0(csp)
; PURECAP-RV64-NEXT:    ccall varargs
; PURECAP-RV64-NEXT:    cincoffset csp, csp, 96
; PURECAP-RV64-NEXT:    clc cs1, 1984(csp)
; PURECAP-RV64-NEXT:    clc cs0, 2000(csp)
; PURECAP-RV64-NEXT:    clc cra, 2016(csp)
; PURECAP-RV64-NEXT:    cincoffset csp, csp, 2032
; PURECAP-RV64-NEXT:    cret
;
; PURECAP-MIPS-LABEL: test_byval:
; Stack frame size should be > 2048:
; PURECAP-MIPS:       # %bb.0: # %entry
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, -2112
; PURECAP-MIPS-NEXT:    cincoffset $c11, $c11, $1
; PURECAP-MIPS-NEXT:    csc $c19, $zero, 2096($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    csc $c18, $zero, 2080($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    csc $c17, $zero, 2064($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-MIPS-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-MIPS-NEXT:    cgetpccincoffset $c19, $1
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(memset)($c19)
; Note: we rematerialize the bounded var here to avoid spilling to the stack:
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, 1040
; PURECAP-MIPS-NEXT:    cincoffset $c3, $c11, $1
; PURECAP-MIPS-NEXT:    csetbounds $c3, $c3, 1024
; PURECAP-MIPS-NEXT:    daddiu $4, $zero, 0
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    daddiu $5, $zero, 1024
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(byref)($c19)
; Note: we rematerialize the bounded var here to avoid spilling to the stack:
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, 1040
; PURECAP-MIPS-NEXT:    cincoffset $c3, $c11, $1
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    csetbounds $c3, $c3, 1024
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(memcpy)($c19)
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, 1040
; PURECAP-MIPS-NEXT:    cincoffset $c4, $c11, $1
; PURECAP-MIPS-NEXT:    csetbounds $c4, $c4, 1024
; PURECAP-MIPS-NEXT:    daddiu $4, $zero, 1024
; PURECAP-MIPS-NEXT:    cmove $c18, $c11
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    cmove $c3, $c18
; Pass a bounded cap (1024 bytes) in $c13:
; PURECAP-MIPS-NEXT:    csetbounds $c1, $c18, 1024
; PURECAP-MIPS-NEXT:    ori $1, $zero, 65495
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(varargs)($c19)
; PURECAP-MIPS-NEXT:    candperm $c13, $c1, $1
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    daddiu $4, $zero, 1024
; PURECAP-MIPS-NEXT:    sll $2, $2, 0
; PURECAP-MIPS-NEXT:    clc $c17, $zero, 2064($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    clc $c18, $zero, 2080($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    clc $c19, $zero, 2096($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, 2112
; PURECAP-MIPS-NEXT:    cjr $c17
; PURECAP-MIPS-NEXT:    cincoffset $c11, $c11, $1

entry:
  %f = alloca %struct.Foo, align 8, addrspace(200)
  %0 = getelementptr inbounds %struct.Foo, %struct.Foo addrspace(200)* %f, i64 0, i32 0, i64 0
  call void @llvm.lifetime.start.p200i8(i64 1024, i8 addrspace(200)* nonnull %0) #4
  call void @llvm.memset.p200i8.i64(i8 addrspace(200)* nonnull align 8 dereferenceable(1024) %0, i8 0, i64 1024, i1 false)
  %call = call signext i32 @byref(%struct.Foo addrspace(200)* nonnull %f) #4
  %call1 = call signext i32 (i32, ...) @varargs(i32 signext 1024, %struct.Foo addrspace(200)* nonnull byval(%struct.Foo) align 8 %f) #4
  call void @llvm.lifetime.end.p200i8(i64 1024, i8 addrspace(200)* nonnull %0) #4
  ret i32 %call1
}

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.start.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200) #1

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p200i8.i64(i8 addrspace(200)* nocapture writeonly, i8, i64, i1 immarg) addrspace(200) #2

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noalias nocapture writeonly, i8 addrspace(200)* noalias nocapture readonly, i64, i1 immarg) addrspace(200) #1

declare signext i32 @byref(%struct.Foo addrspace(200)*) local_unnamed_addr addrspace(200) #3

declare signext i32 @varargs(i32 signext, ...) local_unnamed_addr addrspace(200) #3

; Function Attrs: argmemonly nounwind willreturn
declare void @llvm.lifetime.end.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200) #1

attributes #0 = { nounwind }
attributes #1 = { argmemonly nounwind willreturn }
attributes #2 = { argmemonly nounwind willreturn writeonly }
attributes #3 = { nounwind }
attributes #4 = { nounwind }
