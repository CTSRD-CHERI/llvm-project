; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --extra_scrub
; REQUIRES: mips-registered-target, riscv-registered-target
; After merging to the LLVM11 branch point certain by-value arguments were no longer being copied.
; Changing the IR to use addrspace(0) and compiling for non-CHERI adds memcpy() calls, so we should do the same for purecap.
; This (incorrect) behaviour was added in a297402637b73b9d783a229e9b41c57ea7b92e2e, but we apparently never hit
; because the frontend would almost always emit a local alloca already.

; First check that non-CHERI targets add a memcpy
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/p200i8/p0i8/g' %s | llc -mtriple riscv64-unknown-freebsd -o - -relocation-model=static | FileCheck %s --check-prefixes CHECK,RV64,RV64-STATIC --allow-unused-prefixes
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/p200i8/p0i8/g' %s | llc -mtriple riscv64-unknown-freebsd -o - -relocation-model=pic | FileCheck %s --check-prefixes CHECK,RV64,RV64-PIC --allow-unused-prefixes
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/p200i8/p0i8/g' %s | llc -mtriple mips64-unknown-freebsd -o - -relocation-model=pic | FileCheck %s --check-prefixes CHECK,MIPS,MIPS-PIC --allow-unused-prefixes
; Next check purecap targets:
; RUN: %riscv64_cheri_purecap_llc -o - %s | FileCheck %s --check-prefixes CHECK,PURECAP-RV64 --allow-unused-prefixes
; RUN: %cheri_purecap_llc -o - %s | FileCheck %s --check-prefixes CHECK,PURECAP-MIPS --allow-unused-prefixes

; IR originally generated from %cheri_purecap_cc1 -mrelocation-model pic -pic-level 1 -pic-is-pie -O -S %s -o - -emit-llvm
; Interestingly, the purecap RISCV IR contains a temporary alloca and MIPS also does without the pic flags (CodeGenFunction::EmitCall()).
; struct foo {
;   char data[1024];
; };
;
; extern void assert_eq(long l1, long l2);
; extern void *memset(void *, int, unsigned long);
; struct foo global_foo;
; __attribute__((noinline)) void foo_byval(struct foo f) {
;   memset(f.data, 42, sizeof(f.data));
; }
;
; void clang_purecap_byval_args(void) {
;   /* Check that structs passed by value are actually copied */
;   memset(global_foo.data, 0, sizeof(global_foo.data));
;   assert_eq(global_foo.data[0], 0);
;   foo_byval(global_foo);
;   assert_eq(global_foo.data[0], 0);
; }

%struct.foo = type { [1024 x i8] }

@global_foo = dso_local local_unnamed_addr addrspace(200) global %struct.foo zeroinitializer, align 8

declare dso_local void @foo_byval(%struct.foo addrspace(200)* nocapture byval(%struct.foo) align 8 %f) local_unnamed_addr addrspace(200) noinline nounwind writeonly
; define dso_local void @foo_byval(%struct.foo addrspace(200)* nocapture byval(%struct.foo) align 8 %f) local_unnamed_addr addrspace(200) noinline nounwind writeonly {
; entry:
;   %arraydecay = getelementptr inbounds %struct.foo, %struct.foo addrspace(200)* %f, i64 0, i32 0, i64 0
;   call void @llvm.memset.p200i8.i64(i8 addrspace(200)* nonnull align 8 dereferenceable(1024) %arraydecay, i8 42, i64 1024, i1 false)
;   ret void
; }

; Function Attrs: argmemonly nounwind willreturn writeonly
declare void @llvm.memset.p200i8.i64(i8 addrspace(200)* nocapture writeonly, i8, i64, i1 immarg) addrspace(200) argmemonly nounwind willreturn writeonly

; Function Attrs: nounwind uwtable
define dso_local void @clang_purecap_byval_args() local_unnamed_addr addrspace(200) nounwind {
; RV64-STATIC-LABEL: clang_purecap_byval_args:
; RV64-STATIC:       # %bb.0: # %entry
; RV64-STATIC-NEXT:    addi sp, sp, -1056
; RV64-STATIC-NEXT:    sd ra, 1048(sp)
; RV64-STATIC-NEXT:    sd s0, 1040(sp)
; RV64-STATIC-NEXT:    sd s1, 1032(sp)
; RV64-STATIC-NEXT:    lui s1, %hi(global_foo)
; RV64-STATIC-NEXT:    addi s0, s1, %lo(global_foo)
; RV64-STATIC-NEXT:    addi a2, zero, 1024
; RV64-STATIC-NEXT:    mv a0, s0
; RV64-STATIC-NEXT:    mv a1, zero
; RV64-STATIC-NEXT:    call memset
; RV64-STATIC-NEXT:    lb a0, %lo(global_foo)(s1)
; RV64-STATIC-NEXT:    mv a1, zero
; RV64-STATIC-NEXT:    call assert_eq
; RV64-STATIC-NEXT:    addi a0, sp, 8
; RV64-STATIC-NEXT:    addi a2, zero, 1024
; RV64-STATIC-NEXT:    mv a1, s0
; RV64-STATIC-NEXT:    call memcpy
; RV64-STATIC-NEXT:    addi a0, sp, 8
; RV64-STATIC-NEXT:    call foo_byval
; RV64-STATIC-NEXT:    lb a0, %lo(global_foo)(s1)
; RV64-STATIC-NEXT:    mv a1, zero
; RV64-STATIC-NEXT:    call assert_eq
; RV64-STATIC-NEXT:    ld s1, 1032(sp)
; RV64-STATIC-NEXT:    ld s0, 1040(sp)
; RV64-STATIC-NEXT:    ld ra, 1048(sp)
; RV64-STATIC-NEXT:    addi sp, sp, 1056
; RV64-STATIC-NEXT:    ret
;
; RV64-PIC-LABEL: clang_purecap_byval_args:
; RV64-PIC:       # %bb.0: # %entry
; RV64-PIC-NEXT:    addi sp, sp, -1056
; RV64-PIC-NEXT:    sd ra, 1048(sp)
; RV64-PIC-NEXT:    sd s0, 1040(sp)
; RV64-PIC-NEXT:  .LBB0_1: # %entry
; RV64-PIC-NEXT:    # Label of block must be emitted
; RV64-PIC-NEXT:    auipc s0, %pcrel_hi(global_foo)
; RV64-PIC-NEXT:    addi s0, s0, %pcrel_lo(.LBB0_1)
; RV64-PIC-NEXT:    addi a2, zero, 1024
; RV64-PIC-NEXT:    mv a0, s0
; RV64-PIC-NEXT:    mv a1, zero
; RV64-PIC-NEXT:    call memset@plt
; RV64-PIC-NEXT:    lb a0, 0(s0)
; RV64-PIC-NEXT:    mv a1, zero
; RV64-PIC-NEXT:    call assert_eq@plt
; RV64-PIC-NEXT:    addi a0, sp, 16
; RV64-PIC-NEXT:    addi a2, zero, 1024
; RV64-PIC-NEXT:    mv a1, s0
; RV64-PIC-NEXT:    call memcpy@plt
; RV64-PIC-NEXT:    addi a0, sp, 16
; RV64-PIC-NEXT:    call foo_byval
; RV64-PIC-NEXT:    lb a0, 0(s0)
; RV64-PIC-NEXT:    mv a1, zero
; RV64-PIC-NEXT:    call assert_eq@plt
; RV64-PIC-NEXT:    ld s0, 1040(sp)
; RV64-PIC-NEXT:    ld ra, 1048(sp)
; RV64-PIC-NEXT:    addi sp, sp, 1056
; RV64-PIC-NEXT:    ret
;
; Note: MIPS passes the first 64 byval bytes in registers
; MIPS-LABEL: clang_purecap_byval_args:
; MIPS:       # %bb.0: # %entry
; MIPS-NEXT:    daddiu $sp, $sp, -992
; MIPS-NEXT:    sd $ra, 984($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $gp, 976($sp) # 8-byte Folded Spill
; MIPS-NEXT:    sd $16, 968($sp) # 8-byte Folded Spill
; MIPS-NEXT:    lui $1, %hi(%neg(%gp_rel(clang_purecap_byval_args)))
; MIPS-NEXT:    daddu $1, $1, $25
; MIPS-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(clang_purecap_byval_args)))
; MIPS-NEXT:    ld $16, %got_disp(global_foo)($gp)
; MIPS-NEXT:    ld $25, %call16(memset)($gp)
; MIPS-NEXT:    move $4, $16
; MIPS-NEXT:    daddiu $5, $zero, 0
; MIPS-NEXT:    .reloc .Ltmp0, R_MIPS_JALR, memset
; MIPS-NEXT:  .Ltmp0:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $6, $zero, 1024
; MIPS-NEXT:    lb $4, 0($16)
; MIPS-NEXT:    ld $25, %call16(assert_eq)($gp)
; MIPS-NEXT:    .reloc .Ltmp1, R_MIPS_JALR, assert_eq
; MIPS-NEXT:  .Ltmp1:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $5, $zero, 0
; MIPS-NEXT:    daddiu $5, $16, 64
; MIPS-NEXT:    ld $25, %call16(memcpy)($gp)
; MIPS-NEXT:    move $4, $sp
; MIPS-NEXT:    .reloc .Ltmp2, R_MIPS_JALR, memcpy
; MIPS-NEXT:  .Ltmp2:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $6, $zero, 960
; MIPS-NEXT:    ld $11, 56($16)
; MIPS-NEXT:    ld $10, 48($16)
; MIPS-NEXT:    ld $9, 40($16)
; MIPS-NEXT:    ld $8, 32($16)
; MIPS-NEXT:    ld $7, 24($16)
; MIPS-NEXT:    ld $6, 16($16)
; MIPS-NEXT:    ld $5, 8($16)
; MIPS-NEXT:    ld $4, 0($16)
; MIPS-NEXT:    ld $25, %call16(foo_byval)($gp)
; MIPS-NEXT:    .reloc .Ltmp3, R_MIPS_JALR, foo_byval
; MIPS-NEXT:  .Ltmp3:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    nop
; MIPS-NEXT:    lb $4, 0($16)
; MIPS-NEXT:    ld $25, %call16(assert_eq)($gp)
; MIPS-NEXT:    .reloc .Ltmp4, R_MIPS_JALR, assert_eq
; MIPS-NEXT:  .Ltmp4:
; MIPS-NEXT:    jalr $25
; MIPS-NEXT:    daddiu $5, $zero, 0
; MIPS-NEXT:    ld $16, 968($sp) # 8-byte Folded Reload
; MIPS-NEXT:    ld $gp, 976($sp) # 8-byte Folded Reload
; MIPS-NEXT:    ld $ra, 984($sp) # 8-byte Folded Reload
; MIPS-NEXT:    jr $ra
; MIPS-NEXT:    daddiu $sp, $sp, 992
;
; PURECAP-RV64-LABEL: clang_purecap_byval_args:
; PURECAP-RV64:       # %bb.0: # %entry
; PURECAP-RV64-NEXT:    cincoffset csp, csp, -1072
; PURECAP-RV64-NEXT:    csc cra, 1056(csp)
; PURECAP-RV64-NEXT:    csc cs0, 1040(csp)
; PURECAP-RV64-NEXT:  .LBB0_1: # %entry
; PURECAP-RV64-NEXT:    # Label of block must be emitted
; PURECAP-RV64-NEXT:    auipcc cs0, %captab_pcrel_hi(global_foo)
; PURECAP-RV64-NEXT:    clc cs0, %pcrel_lo(.LBB0_1)(cs0)
; PURECAP-RV64-NEXT:    addi a2, zero, 1024
; PURECAP-RV64-NEXT:    cmove ca0, cs0
; PURECAP-RV64-NEXT:    mv a1, zero
; PURECAP-RV64-NEXT:    ccall memset
; PURECAP-RV64-NEXT:    clb a0, 0(cs0)
; PURECAP-RV64-NEXT:    mv a1, zero
; PURECAP-RV64-NEXT:    ccall assert_eq
; PURECAP-RV64-NEXT:    cincoffset ca0, csp, 16
; PURECAP-RV64-NEXT:    addi a2, zero, 1024
; PURECAP-RV64-NEXT:    cmove ca1, cs0
; PURECAP-RV64-NEXT:    ccall memcpy
; PURECAP-RV64-NEXT:    cincoffset ca0, csp, 16
; PURECAP-RV64-NEXT:    ccall foo_byval
; PURECAP-RV64-NEXT:    clb a0, 0(cs0)
; PURECAP-RV64-NEXT:    mv a1, zero
; PURECAP-RV64-NEXT:    ccall assert_eq
; PURECAP-RV64-NEXT:    clc cs0, 1040(csp)
; PURECAP-RV64-NEXT:    clc cra, 1056(csp)
; PURECAP-RV64-NEXT:    cincoffset csp, csp, 1072
; PURECAP-RV64-NEXT:    cret
;
; PURECAP-MIPS-LABEL: clang_purecap_byval_args:
; PURECAP-MIPS:       # %bb.0: # %entry
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, -1104
; PURECAP-MIPS-NEXT:    cincoffset $c11, $c11, $1
; PURECAP-MIPS-NEXT:    csc $c20, $zero, 1088($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    csc $c19, $zero, 1072($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    csc $c18, $zero, 1056($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    csc $c17, $zero, 1040($c11) # 16-byte Folded Spill
; PURECAP-MIPS-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-MIPS-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-MIPS-NEXT:    cgetpccincoffset $c20, $1
; PURECAP-MIPS-NEXT:    clcbi $c18, %captab20(global_foo)($c20)
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(memset)($c20)
; PURECAP-MIPS-NEXT:    daddiu $4, $zero, 0
; PURECAP-MIPS-NEXT:    daddiu $5, $zero, 1024
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    cmove $c3, $c18
; PURECAP-MIPS-NEXT:    clb $4, $zero, 0($c18)
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(assert_eq)($c20)
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    daddiu $5, $zero, 0
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(memcpy)($c20)
; PURECAP-MIPS-NEXT:    daddiu $4, $zero, 1024
; PURECAP-MIPS-NEXT:    cmove $c19, $c11
; PURECAP-MIPS-NEXT:    cmove $c3, $c19
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    cmove $c4, $c18
; PURECAP-MIPS-NEXT:    csetbounds $c1, $c19, 1024
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(foo_byval)($c20)
; PURECAP-MIPS-NEXT:    ori $1, $zero, 65495
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    candperm $c13, $c1, $1
; PURECAP-MIPS-NEXT:    clb $4, $zero, 0($c18)
; PURECAP-MIPS-NEXT:    clcbi $c12, %capcall20(assert_eq)($c20)
; PURECAP-MIPS-NEXT:    cjalr $c12, $c17
; PURECAP-MIPS-NEXT:    daddiu $5, $zero, 0
; PURECAP-MIPS-NEXT:    clc $c17, $zero, 1040($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    clc $c18, $zero, 1056($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    clc $c19, $zero, 1072($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    clc $c20, $zero, 1088($c11) # 16-byte Folded Reload
; PURECAP-MIPS-NEXT:    daddiu $1, $zero, 1104
; PURECAP-MIPS-NEXT:    cjr $c17
; PURECAP-MIPS-NEXT:    cincoffset $c11, $c11, $1
entry:
  call void @llvm.memset.p200i8.i64(i8 addrspace(200)* nonnull align 8 dereferenceable(1024) getelementptr inbounds (%struct.foo, %struct.foo addrspace(200)* @global_foo, i64 0, i32 0, i64 0), i8 0, i64 1024, i1 false)
  %0 = load i8, i8 addrspace(200)* getelementptr inbounds (%struct.foo, %struct.foo addrspace(200)* @global_foo, i64 0, i32 0, i64 0), align 8
  %conv = sext i8 %0 to i64
  call void @assert_eq(i64 signext %conv, i64 signext 0) nounwind
  call void @foo_byval(%struct.foo addrspace(200)* nonnull byval(%struct.foo) align 8 @global_foo)
  %1 = load i8, i8 addrspace(200)* getelementptr inbounds (%struct.foo, %struct.foo addrspace(200)* @global_foo, i64 0, i32 0, i64 0), align 8
  %conv1 = sext i8 %1 to i64
  call void @assert_eq(i64 signext %conv1, i64 signext 0) nounwind
  ret void
}

declare void @assert_eq(i64 signext, i64 signext) local_unnamed_addr addrspace(200) nounwind

