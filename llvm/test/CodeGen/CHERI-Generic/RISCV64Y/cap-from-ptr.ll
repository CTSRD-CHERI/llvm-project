; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --scrub-attributes --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/cap-from-ptr.ll
;; Check that we can correctly generate code for llvm.cheri.cap.from.pointer()
;; This previously asserted on RISC-V due to a broken ISel pattern.
;; We pipe this input through instcombine first to ensure SelectionDAG sees canonical IR.
; RUN: opt -mtriple=riscv64 --relocation-model=pic -target-abi l64pc128d -mattr=+y,+cap-mode,+f,+d -passes=instcombine -S < %s | FileCheck %s --check-prefix=CHECK-IR
; RUN: opt -mtriple=riscv64 --relocation-model=pic -target-abi l64pc128d -mattr=+y,+cap-mode,+f,+d -passes=instcombine -S < %s | llc -mtriple=riscv64 --relocation-model=pic -target-abi l64pc128d -mattr=+y,+cap-mode,+f,+d | FileCheck %s --check-prefix=PURECAP
; RUN: opt -mtriple=riscv64 --relocation-model=pic -target-abi lp64d -mattr=+y,+zyhybrid,+f,+d -passes=instcombine -S < %s | llc -mtriple=riscv64 --relocation-model=pic -target-abi lp64d -mattr=+y,+zyhybrid,+f,+d | FileCheck %s --check-prefix=HYBRID

define internal ptr addrspace(200) @test(ptr addrspace(200) %ptr, ptr addrspace(200) %cap, i64 %offset) nounwind {
; PURECAP-LABEL: test:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    bnez a2, .LBB0_2
; PURECAP-NEXT:  # %bb.1: # %entry
; PURECAP-NEXT:    ymv ca1, cnull
; PURECAP-NEXT:    j .LBB0_3
; PURECAP-NEXT:  .LBB0_2:
; PURECAP-NEXT:    yaddrw ca1, ca1, a2
; PURECAP-NEXT:  .LBB0_3: # %entry
; PURECAP-NEXT:    sy ca1, 0(ca0)
; PURECAP-NEXT:    ymv ca0, ca1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: test:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    bnez a2, .LBB0_2
; HYBRID-NEXT:  # %bb.1: # %entry
; HYBRID-NEXT:    ymv ca1, cnull
; HYBRID-NEXT:    j .LBB0_3
; HYBRID-NEXT:  .LBB0_2:
; HYBRID-NEXT:    yaddrw ca1, ca1, a2
; HYBRID-NEXT:  .LBB0_3: # %entry
; HYBRID-NEXT:    .option capmode
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    sy ca0, 0(ca1)
; HYBRID-NEXT:    .option nocapmode
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ymv ca0, ca1
; HYBRID-NEXT:    ret
; CHECK-IR-LABEL: define internal ptr addrspace(200) @test
; CHECK-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], ptr addrspace(200) [[CAP:%.*]], i64 [[OFFSET:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[NEW:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) [[CAP]], i64 [[OFFSET]])
; CHECK-IR-NEXT:    store ptr addrspace(200) [[NEW]], ptr addrspace(200) [[PTR]], align 16
; CHECK-IR-NEXT:    ret ptr addrspace(200) [[NEW]]
;
entry:
  %new = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) %cap, i64 %offset)
  store ptr addrspace(200) %new, ptr addrspace(200) %ptr, align 16
  ret ptr addrspace(200) %new
}

;; (int_cheri_cap_from_ptr x, 0) -> null
define internal ptr addrspace(200) @cap_from_ptr_zero(ptr addrspace(200) %ptr, ptr addrspace(200) %cap) nounwind {
; PURECAP-LABEL: cap_from_ptr_zero:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sy cnull, 0(ca0)
; PURECAP-NEXT:    ymv ca0, cnull
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: cap_from_ptr_zero:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    .option capmode
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    sy ca0, 0(cnull)
; HYBRID-NEXT:    .option nocapmode
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ymv ca0, cnull
; HYBRID-NEXT:    ret
; CHECK-IR-LABEL: define internal ptr addrspace(200) @cap_from_ptr_zero
; CHECK-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], ptr addrspace(200) [[CAP:%.*]]) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    store ptr addrspace(200) null, ptr addrspace(200) [[PTR]], align 16
; CHECK-IR-NEXT:    ret ptr addrspace(200) null
;
entry:
  %new = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) %cap, i64 0)
  store ptr addrspace(200) %new, ptr addrspace(200) %ptr, align 16
  ret ptr addrspace(200) %new
}

;; Check that (int_cheri_cap_from_ptr ddc, x) can use the DDC register directly
define internal ptr addrspace(200) @cap_from_ptr_ddc(ptr addrspace(200) %ptr, i64 %offset) nounwind {
; PURECAP-LABEL: cap_from_ptr_ddc:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    bnez a1, .LBB2_2
; PURECAP-NEXT:  # %bb.1: # %entry
; PURECAP-NEXT:    ymv ca1, cnull
; PURECAP-NEXT:    j .LBB2_3
; PURECAP-NEXT:  .LBB2_2:
; PURECAP-NEXT:    yaddrw ca1, cnull, a1
; PURECAP-NEXT:  .LBB2_3: # %entry
; PURECAP-NEXT:    sy ca1, 0(ca0)
; PURECAP-NEXT:    ymv ca0, ca1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: cap_from_ptr_ddc:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    csrrc ca2, ddc, zero
; HYBRID-NEXT:    bnez a1, .LBB2_2
; HYBRID-NEXT:  # %bb.1: # %entry
; HYBRID-NEXT:    ymv ca1, cnull
; HYBRID-NEXT:    j .LBB2_3
; HYBRID-NEXT:  .LBB2_2:
; HYBRID-NEXT:    yaddrw ca1, ca2, a1
; HYBRID-NEXT:  .LBB2_3: # %entry
; HYBRID-NEXT:    .option capmode
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    sy ca0, 0(ca1)
; HYBRID-NEXT:    .option nocapmode
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ymv ca0, ca1
; HYBRID-NEXT:    ret
; CHECK-IR-LABEL: define internal ptr addrspace(200) @cap_from_ptr_ddc
; CHECK-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[OFFSET:%.*]]) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[DDC:%.*]] = call ptr addrspace(200) @llvm.cheri.ddc.get()
; CHECK-IR-NEXT:    [[NEW:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) [[DDC]], i64 [[OFFSET]])
; CHECK-IR-NEXT:    store ptr addrspace(200) [[NEW]], ptr addrspace(200) [[PTR]], align 16
; CHECK-IR-NEXT:    ret ptr addrspace(200) [[NEW]]
;
entry:
  %ddc = call ptr addrspace(200) @llvm.cheri.ddc.get()
  %new = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) %ddc, i64 %offset)
  store ptr addrspace(200) %new, ptr addrspace(200) %ptr, align 16
  ret ptr addrspace(200) %new
}

;; Check that (int_cheri_cap_from_ptr x, 0) -> null has priority over direct DDC usage
define internal ptr addrspace(200) @cap_from_ptr_ddc_zero(ptr addrspace(200) %ptr) nounwind {
; PURECAP-LABEL: cap_from_ptr_ddc_zero:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    sy cnull, 0(ca0)
; PURECAP-NEXT:    ymv ca0, cnull
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: cap_from_ptr_ddc_zero:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    .option capmode
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    sy ca0, 0(cnull)
; HYBRID-NEXT:    .option nocapmode
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ymv ca0, cnull
; HYBRID-NEXT:    ret
; CHECK-IR-LABEL: define internal ptr addrspace(200) @cap_from_ptr_ddc_zero
; CHECK-IR-SAME: (ptr addrspace(200) [[PTR:%.*]]) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    store ptr addrspace(200) null, ptr addrspace(200) [[PTR]], align 16
; CHECK-IR-NEXT:    ret ptr addrspace(200) null
;
entry:
  %ddc = call ptr addrspace(200) @llvm.cheri.ddc.get()
  %new = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) %ddc, i64 0)
  store ptr addrspace(200) %new, ptr addrspace(200) %ptr, align 16
  ret ptr addrspace(200) %new
}

;; Check that (int_cheri_cap_from_ptr null, x) does not use register zero (since that is DDC)
define internal ptr addrspace(200) @cap_from_ptr_null(ptr addrspace(200) %ptr, i64 %offset) nounwind {
; PURECAP-LABEL: cap_from_ptr_null:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    bnez a1, .LBB4_2
; PURECAP-NEXT:  # %bb.1: # %entry
; PURECAP-NEXT:    ymv ca1, cnull
; PURECAP-NEXT:    j .LBB4_3
; PURECAP-NEXT:  .LBB4_2:
; PURECAP-NEXT:    yaddrw ca1, cnull, a1
; PURECAP-NEXT:  .LBB4_3: # %entry
; PURECAP-NEXT:    sy ca1, 0(ca0)
; PURECAP-NEXT:    ymv ca0, ca1
; PURECAP-NEXT:    ret
;
; HYBRID-LABEL: cap_from_ptr_null:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    bnez a1, .LBB4_2
; HYBRID-NEXT:  # %bb.1: # %entry
; HYBRID-NEXT:    ymv ca1, cnull
; HYBRID-NEXT:    j .LBB4_3
; HYBRID-NEXT:  .LBB4_2:
; HYBRID-NEXT:    yaddrw ca1, cnull, a1
; HYBRID-NEXT:  .LBB4_3: # %entry
; HYBRID-NEXT:    .option capmode
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    sy ca0, 0(ca1)
; HYBRID-NEXT:    .option nocapmode
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ymv ca0, ca1
; HYBRID-NEXT:    ret
; CHECK-IR-LABEL: define internal ptr addrspace(200) @cap_from_ptr_null
; CHECK-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i64 [[OFFSET:%.*]]) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[NEW:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) null, i64 [[OFFSET]])
; CHECK-IR-NEXT:    store ptr addrspace(200) [[NEW]], ptr addrspace(200) [[PTR]], align 16
; CHECK-IR-NEXT:    ret ptr addrspace(200) [[NEW]]
;
entry:
  %new = call ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200) null, i64 %offset)
  store ptr addrspace(200) %new, ptr addrspace(200) %ptr, align 16
  ret ptr addrspace(200) %new
}

declare ptr addrspace(200) @llvm.cheri.cap.from.pointer.i64(ptr addrspace(200), i64)
declare ptr addrspace(200) @llvm.cheri.ddc.get()
