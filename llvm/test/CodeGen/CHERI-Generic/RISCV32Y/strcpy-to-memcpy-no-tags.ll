; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/strcpy-to-memcpy-no-tags.ll
; Check that we can inline the loads/stores generated when simplifiying
; string libcalls to memcpy() (since it should be marked as non-tag-preserving).
; CHERI-GENERIC-UTC: llc
; Note: unlike other tests we do want to test attributes in this one.
; CHERI-GENERIC-UTC: opt --function-signature
; RUN: opt < %s -passes=instcombine -S | FileCheck %s --check-prefix=CHECK-IR
; RUN: opt < %s -passes=instcombine -S | llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+y,+cap-mode,+f - -o - | FileCheck %s --check-prefix=CHECK-ASM
target datalayout = "e-m:e-pf200:64:64:64:32-p:32:32-i64:64-n32-S128-A200-P200-G200"

@str = private unnamed_addr addrspace(200) constant [17 x i8] c"exactly 16 chars\00", align 4

declare ptr addrspace(200) @strcpy(ptr addrspace(200), ptr addrspace(200)) addrspace(200)
declare ptr addrspace(200) @stpcpy(ptr addrspace(200), ptr addrspace(200)) addrspace(200)
declare ptr addrspace(200) @strcat(ptr addrspace(200), ptr addrspace(200)) addrspace(200)
declare ptr addrspace(200) @strncpy(ptr addrspace(200), ptr addrspace(200), i64) addrspace(200)
declare ptr addrspace(200) @stpncpy(ptr addrspace(200), ptr addrspace(200), i64) addrspace(200)

define void @test_strcpy_to_memcpy(ptr addrspace(200) align 4 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_strcpy_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    sb zero, 16(ca0)
; CHECK-ASM-NEXT:    lui a1, 472870
; CHECK-ASM-NEXT:    addi a1, a1, 360
; CHECK-ASM-NEXT:    sw a1, 12(ca0)
; CHECK-ASM-NEXT:    lui a1, 406019
; CHECK-ASM-NEXT:    addi a1, a1, 1585
; CHECK-ASM-NEXT:    sw a1, 8(ca0)
; CHECK-ASM-NEXT:    lui a1, 133015
; CHECK-ASM-NEXT:    addi a1, a1, -908
; CHECK-ASM-NEXT:    sw a1, 4(ca0)
; CHECK-ASM-NEXT:    lui a1, 407064
; CHECK-ASM-NEXT:    addi a1, a1, -1947
; CHECK-ASM-NEXT:    sw a1, 0(ca0)
; CHECK-ASM-NEXT:    ret
; CHECK-IR-LABEL: define void @test_strcpy_to_memcpy
; CHECK-IR-SAME: (ptr addrspace(200) align 4 [[DST:%.*]]) addrspace(200) #[[ATTR1:[0-9]+]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    call void @llvm.memcpy.p200.p200.i32(ptr addrspace(200) noundef nonnull align 4 dereferenceable(17) [[DST]], ptr addrspace(200) noundef nonnull align 4 dereferenceable(17) @str, i32 17, i1 false) #[[ATTR4:[0-9]+]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call ptr addrspace(200) @strcpy(ptr addrspace(200) %dst, ptr addrspace(200) @str)
  ret void
}

define void @test_stpcpy_to_memcpy(ptr addrspace(200) align 4 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_stpcpy_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    sb zero, 16(ca0)
; CHECK-ASM-NEXT:    lui a1, 472870
; CHECK-ASM-NEXT:    addi a1, a1, 360
; CHECK-ASM-NEXT:    sw a1, 12(ca0)
; CHECK-ASM-NEXT:    lui a1, 406019
; CHECK-ASM-NEXT:    addi a1, a1, 1585
; CHECK-ASM-NEXT:    sw a1, 8(ca0)
; CHECK-ASM-NEXT:    lui a1, 133015
; CHECK-ASM-NEXT:    addi a1, a1, -908
; CHECK-ASM-NEXT:    sw a1, 4(ca0)
; CHECK-ASM-NEXT:    lui a1, 407064
; CHECK-ASM-NEXT:    addi a1, a1, -1947
; CHECK-ASM-NEXT:    sw a1, 0(ca0)
; CHECK-ASM-NEXT:    ret
; CHECK-IR-LABEL: define void @test_stpcpy_to_memcpy
; CHECK-IR-SAME: (ptr addrspace(200) align 4 [[DST:%.*]]) addrspace(200) #[[ATTR1]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    call void @llvm.memcpy.p200.p200.i32(ptr addrspace(200) noundef nonnull align 4 dereferenceable(17) [[DST]], ptr addrspace(200) noundef nonnull align 4 dereferenceable(17) @str, i32 17, i1 false) #[[ATTR5:[0-9]+]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call ptr addrspace(200) @stpcpy(ptr addrspace(200) %dst, ptr addrspace(200) @str)
  ret void
}

define void @test_strcat_to_memcpy(ptr addrspace(200) align 4 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_strcat_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    addiy csp, csp, -16
; CHECK-ASM-NEXT:    sy cra, 8(csp) # 8-byte Folded Spill
; CHECK-ASM-NEXT:    sy cs0, 0(csp) # 8-byte Folded Spill
; CHECK-ASM-NEXT:    ymv cs0, ca0
; CHECK-ASM-NEXT:    call strlen
; CHECK-ASM-NEXT:    addy ca0, cs0, a0
; CHECK-ASM-NEXT:  .LBB2_1: # %entry
; CHECK-ASM-NEXT:    # Label of block must be emitted
; CHECK-ASM-NEXT:    auipcc ca1, %got_pcrel_hi(.Lstr)
; CHECK-ASM-NEXT:    ly ca1, %pcrel_lo(.LBB2_1)(ca1)
; CHECK-ASM-NEXT:    li a2, 17
; CHECK-ASM-NEXT:    call memcpy
; CHECK-ASM-NEXT:    ly cra, 8(csp) # 8-byte Folded Reload
; CHECK-ASM-NEXT:    ly cs0, 0(csp) # 8-byte Folded Reload
; CHECK-ASM-NEXT:    addiy csp, csp, 16
; CHECK-ASM-NEXT:    ret
; CHECK-IR-LABEL: define void @test_strcat_to_memcpy
; CHECK-IR-SAME: (ptr addrspace(200) align 4 [[DST:%.*]]) addrspace(200) #[[ATTR1]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[STRLEN:%.*]] = call i32 @strlen(ptr addrspace(200) noundef nonnull dereferenceable(1) [[DST]])
; CHECK-IR-NEXT:    [[ENDPTR:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[DST]], i32 [[STRLEN]]
; CHECK-IR-NEXT:    call void @llvm.memcpy.p200.p200.i32(ptr addrspace(200) noundef nonnull align 1 dereferenceable(17) [[ENDPTR]], ptr addrspace(200) noundef nonnull align 4 dereferenceable(17) @str, i32 17, i1 false) #[[ATTR5]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call ptr addrspace(200) @strcat(ptr addrspace(200) %dst, ptr addrspace(200) @str)
  ret void
}


define void @test_strncpy_to_memcpy(ptr addrspace(200) align 4 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_strncpy_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    addiy csp, csp, -16
; CHECK-ASM-NEXT:    sy cra, 8(csp) # 8-byte Folded Spill
; CHECK-ASM-NEXT:  .LBB3_1: # %entry
; CHECK-ASM-NEXT:    # Label of block must be emitted
; CHECK-ASM-NEXT:    auipcc ca1, %got_pcrel_hi(.Lstr)
; CHECK-ASM-NEXT:    ly ca1, %pcrel_lo(.LBB3_1)(ca1)
; CHECK-ASM-NEXT:    li a2, 17
; CHECK-ASM-NEXT:    li a3, 0
; CHECK-ASM-NEXT:    call strncpy
; CHECK-ASM-NEXT:    ly cra, 8(csp) # 8-byte Folded Reload
; CHECK-ASM-NEXT:    addiy csp, csp, 16
; CHECK-ASM-NEXT:    ret
; CHECK-IR-LABEL: define void @test_strncpy_to_memcpy
; CHECK-IR-SAME: (ptr addrspace(200) align 4 [[DST:%.*]]) addrspace(200) #[[ATTR1]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[CALL:%.*]] = call ptr addrspace(200) @strncpy(ptr addrspace(200) [[DST]], ptr addrspace(200) nonnull @str, i64 17) #[[ATTR1]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call ptr addrspace(200) @strncpy(ptr addrspace(200) %dst, ptr addrspace(200) @str, i64 17)
  ret void
}

; Note: stpncpy is not handled by SimplifyLibcalls yet, so this should not be changed.
define void @test_stpncpy_to_memcpy(ptr addrspace(200) align 4 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_stpncpy_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    addiy csp, csp, -16
; CHECK-ASM-NEXT:    sy cra, 8(csp) # 8-byte Folded Spill
; CHECK-ASM-NEXT:  .LBB4_1: # %entry
; CHECK-ASM-NEXT:    # Label of block must be emitted
; CHECK-ASM-NEXT:    auipcc ca1, %got_pcrel_hi(.Lstr)
; CHECK-ASM-NEXT:    ly ca1, %pcrel_lo(.LBB4_1)(ca1)
; CHECK-ASM-NEXT:    li a2, 17
; CHECK-ASM-NEXT:    li a3, 0
; CHECK-ASM-NEXT:    call stpncpy
; CHECK-ASM-NEXT:    ly cra, 8(csp) # 8-byte Folded Reload
; CHECK-ASM-NEXT:    addiy csp, csp, 16
; CHECK-ASM-NEXT:    ret
; CHECK-IR-LABEL: define void @test_stpncpy_to_memcpy
; CHECK-IR-SAME: (ptr addrspace(200) align 4 [[DST:%.*]]) addrspace(200) #[[ATTR1]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[CALL:%.*]] = call ptr addrspace(200) @stpncpy(ptr addrspace(200) [[DST]], ptr addrspace(200) nonnull @str, i64 17) #[[ATTR1]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call ptr addrspace(200) @stpncpy(ptr addrspace(200) %dst, ptr addrspace(200) @str, i64 17)
  ret void
}

; UTC_ARGS: --disable
; CHECK-IR: attributes #[[ATTR1]] = { nounwind }
; The no_preserve_cheri_tags should be attribute 4/5 in all cases
; CHECK-IR: attributes #[[ATTR4]] = { no_preserve_cheri_tags nounwind }
; CHECK-IR: attributes #[[ATTR5]] = { no_preserve_cheri_tags }
