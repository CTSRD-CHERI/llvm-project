; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --scrub-attributes --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/ptrtoint.ll
;; Check that we can correctly generate code for ptrtoint and perform simple folds
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi il32pc64f -mattr=+y,+cap-mode,+f < %s | FileCheck %s
; RUN: llc -mtriple=riscv32 --relocation-model=pic -target-abi ilp32f -mattr=+y,+zyhybrid,+f < %s | FileCheck %s --check-prefix=HYBRID

define internal i32 @ptrtoint(i8 addrspace(200)* %cap) addrspace(200) nounwind {
; CHECK-LABEL: ptrtoint:
; CHECK:       # %bb.0:
; CHECK-NEXT:    mv a0, a0
; CHECK-NEXT:    ret
;
; HYBRID-LABEL: ptrtoint:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    ytagr a1, ca0
; HYBRID-NEXT:    neg a1, a1
; HYBRID-NEXT:    and a0, a0, a1
; HYBRID-NEXT:    ret
  %ret = ptrtoint i8 addrspace(200)* %cap to i32
  ret i32 %ret
}

define internal i32 @ptrtoint_plus_const(i8 addrspace(200)* %cap) addrspace(200) nounwind {
; CHECK-LABEL: ptrtoint_plus_const:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi a0, a0, 2
; CHECK-NEXT:    ret
;
; HYBRID-LABEL: ptrtoint_plus_const:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    ytagr a1, ca0
; HYBRID-NEXT:    neg a1, a1
; HYBRID-NEXT:    and a0, a0, a1
; HYBRID-NEXT:    addi a0, a0, 2
; HYBRID-NEXT:    ret
  %zero = ptrtoint i8 addrspace(200)* %cap to i32
  %ret = add i32 %zero, 2
  ret i32 %ret
}

define internal i32 @ptrtoint_plus_var(i8 addrspace(200)* %cap, i32 %add) addrspace(200) nounwind {
; CHECK-LABEL: ptrtoint_plus_var:
; CHECK:       # %bb.0:
; CHECK-NEXT:    add a0, a0, a1
; CHECK-NEXT:    ret
;
; HYBRID-LABEL: ptrtoint_plus_var:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    ytagr a2, ca0
; HYBRID-NEXT:    neg a2, a2
; HYBRID-NEXT:    and a0, a0, a2
; HYBRID-NEXT:    add a0, a0, a1
; HYBRID-NEXT:    ret
  %zero = ptrtoint i8 addrspace(200)* %cap to i32
  %ret = add i32 %zero, %add
  ret i32 %ret
}

define internal i32 @ptrtoint_null() addrspace(200) nounwind {
; CHECK-LABEL: ptrtoint_null:
; CHECK:       # %bb.0:
; CHECK-NEXT:    li a0, 0
; CHECK-NEXT:    ret
;
; HYBRID-LABEL: ptrtoint_null:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    ytagr a0, cnull
; HYBRID-NEXT:    neg a0, a0
; HYBRID-NEXT:    and a0, zero, a0
; HYBRID-NEXT:    ret
  %ret = ptrtoint i8 addrspace(200)* null to i32
  ret i32 %ret
}

define internal i32 @ptrtoint_null_plus_const() addrspace(200) nounwind {
; CHECK-LABEL: ptrtoint_null_plus_const:
; CHECK:       # %bb.0:
; CHECK-NEXT:    li a0, 2
; CHECK-NEXT:    ret
;
; HYBRID-LABEL: ptrtoint_null_plus_const:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    ytagr a0, cnull
; HYBRID-NEXT:    neg a0, a0
; HYBRID-NEXT:    and a0, zero, a0
; HYBRID-NEXT:    addi a0, a0, 2
; HYBRID-NEXT:    ret
  %zero = ptrtoint i8 addrspace(200)* null to i32
  %ret = add i32 %zero, 2
  ret i32 %ret
}

define internal i32 @ptrtoint_null_plus_var(i32 %add) addrspace(200) nounwind {
; CHECK-LABEL: ptrtoint_null_plus_var:
; CHECK:       # %bb.0:
; CHECK-NEXT:    add a0, zero, a0
; CHECK-NEXT:    ret
;
; HYBRID-LABEL: ptrtoint_null_plus_var:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    ytagr a1, cnull
; HYBRID-NEXT:    neg a1, a1
; HYBRID-NEXT:    and a1, zero, a1
; HYBRID-NEXT:    add a0, a1, a0
; HYBRID-NEXT:    ret
  %zero = ptrtoint i8 addrspace(200)* null to i32
  %ret = add i32 %zero, %add
  ret i32 %ret
}
