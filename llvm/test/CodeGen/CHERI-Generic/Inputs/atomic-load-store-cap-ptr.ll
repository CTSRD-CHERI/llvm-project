; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; Check that we can generate sensible code for atomic operations using capability pointers
; https://github.com/CTSRD-CHERI/llvm-project/issues/470
@IF-RISCV@; RUN: llc @PURECAP_HARDFLOAT_ARGS@ -mattr=+a < %s | FileCheck %s --check-prefixes=PURECAP,PURECAP-ATOMICS --allow-unused-prefixes
@IF-RISCV@; RUN: llc @PURECAP_HARDFLOAT_ARGS@ -mattr=-a < %s | FileCheck %s --check-prefixes=PURECAP,PURECAP-LIBCALLS --allow-unused-prefixes
@IFNOT-RISCV@; RUN: llc @PURECAP_HARDFLOAT_ARGS@ %s -o - | FileCheck %s --check-prefix=PURECAP
@IF-RISCV@; RUN: llc @HYBRID_HARDFLOAT_ARGS@ -mattr=+a < %s | FileCheck %s --check-prefixes=HYBRID,HYBRID-ATOMICS --allow-unused-prefixes
@IF-RISCV@; RUN: llc @HYBRID_HARDFLOAT_ARGS@ -mattr=-a < %s | FileCheck %s --check-prefixes=HYBRID,HYBRID-LIBCALLS --allow-unused-prefixes
@IFNOT-RISCV@; RUN: llc @HYBRID_HARDFLOAT_ARGS@ %s -o - | FileCheck %s --check-prefix=HYBRID


define i8 @load_8(ptr addrspace(200) %ptr) nounwind {
  %val = load atomic i8, ptr addrspace(200) %ptr seq_cst, align 1
  ret i8 %val
}

define i16 @load_16(ptr addrspace(200) %ptr) nounwind {
  %val = load atomic i16, ptr addrspace(200) %ptr seq_cst, align 2
  ret i16 %val
}

define i32 @load_32(ptr addrspace(200) %ptr) nounwind {
  %val = load atomic i32, ptr addrspace(200) %ptr seq_cst, align 4
  ret i32 %val
}

define iCAPRANGE @load_range(ptr addrspace(200) %ptr) nounwind {
  %val = load atomic iCAPRANGE, ptr addrspace(200) %ptr seq_cst, align @CAP_RANGE_BYTES@
  ret iCAPRANGE %val
}

define ptr addrspace(200) @load_cap(ptr addrspace(200) %ptr) nounwind {
  %val = load atomic ptr addrspace(200), ptr addrspace(200) %ptr seq_cst, align @CAP_BYTES@
  ret ptr addrspace(200) %val
}

define i8 @store_8(ptr addrspace(200) %ptr, i8 %val) nounwind {
  store atomic i8 %val, ptr addrspace(200) %ptr seq_cst, align 1
  ret i8 %val
}

define i16 @store_16(ptr addrspace(200) %ptr, i16 %val) nounwind {
  store atomic i16 %val, ptr addrspace(200) %ptr seq_cst, align 2
  ret i16 %val
}

define i32 @store_32(ptr addrspace(200) %ptr, i32 %val) nounwind {
  store atomic i32 %val, ptr addrspace(200) %ptr seq_cst, align 4
  ret i32 %val
}

define iCAPRANGE @store_range(ptr addrspace(200) %ptr, iCAPRANGE %val) nounwind {
  store atomic iCAPRANGE %val, ptr addrspace(200) %ptr seq_cst, align @CAP_RANGE_BYTES@
  ret iCAPRANGE %val
}

define ptr addrspace(200) @store_cap(ptr addrspace(200) %ptr, ptr addrspace(200) %val) nounwind {
  store atomic ptr addrspace(200) %val, ptr addrspace(200) %ptr seq_cst, align @CAP_BYTES@
  ret ptr addrspace(200) %val
}
