; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/atomic-cap-size-int.ll
;; Check that we can atomically update i128 (i64 for 32-bit systems)
;; For systems without double-width atomics (RISC-V, MIPS) we can use capability atomics
;; This is needed so we can report true for __atomic_always_lock_free(sizeof(uintptr_t), 0)
; RUN: opt -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -atomic-expand -S < %s | FileCheck %s --check-prefix=PURECAP-IR
; RUN: opt -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi n64 -atomic-expand -S < %s | FileCheck %s --check-prefix=HYBRID-IR
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap %s -o - | FileCheck %s --check-prefix=PURECAP
; RUN: sed 's/addrspace(200)/addrspace(0)/g' %s | llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi n64 | FileCheck %s --check-prefix=HYBRID
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi n64 %s -o - | FileCheck %s --check-prefix=HYBRID-CAP-PTR

define i128 @store(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: store:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -32
; PURECAP-NEXT:    csd $17, $zero, 24($c11) # 8-byte Folded Spill
; PURECAP-NEXT:    csd $16, $zero, 16($c11) # 8-byte Folded Spill
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    move $16, $5
; PURECAP-NEXT:    move $17, $4
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_lock_test_and_set_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    move $2, $17
; PURECAP-NEXT:    move $3, $16
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cld $16, $zero, 16($c11) # 8-byte Folded Reload
; PURECAP-NEXT:    cld $17, $zero, 24($c11) # 8-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 32
;
; HYBRID-LABEL: store:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -32
; HYBRID-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $17, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $16, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    move $16, $6
; HYBRID-NEXT:    move $17, $5
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(store)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(store)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_lock_test_and_set_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp0, R_MIPS_JALR, __sync_lock_test_and_set_16
; HYBRID-NEXT:  .Ltmp0:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    move $2, $17
; HYBRID-NEXT:    move $3, $16
; HYBRID-NEXT:    ld $16, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $17, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 32
;
; HYBRID-CAP-PTR-LABEL: store:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -32
; HYBRID-CAP-PTR-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $17, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $16, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    move $16, $5
; HYBRID-CAP-PTR-NEXT:    move $17, $4
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(store)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(store)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_lock_test_and_set_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp0, R_MIPS_JALR, __sync_lock_test_and_set_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp0:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    move $2, $17
; HYBRID-CAP-PTR-NEXT:    move $3, $16
; HYBRID-CAP-PTR-NEXT:    ld $16, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $17, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 32
; PURECAP-IR-LABEL: define {{[^@]+}}@store
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0:[0-9]+]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    store atomic i128 [[VAL]], ptr addrspace(200) [[PTR]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[VAL]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@store
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0:[0-9]+]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    store atomic i128 [[VAL]], ptr addrspace(200) [[PTR]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[VAL]]
;
  store atomic i128 %val, ptr addrspace(200) %ptr seq_cst, align 16
  ret i128 %val
}

define i128 @load(ptr addrspace(200) %ptr) nounwind {
; PURECAP-LABEL: load:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_val_compare_and_swap_16)($c1)
; PURECAP-NEXT:    daddiu $4, $zero, 0
; PURECAP-NEXT:    daddiu $5, $zero, 0
; PURECAP-NEXT:    daddiu $6, $zero, 0
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    daddiu $7, $zero, 0
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: load:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(load)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(load)))
; HYBRID-NEXT:    ld $25, %call16(__sync_val_compare_and_swap_16)($gp)
; HYBRID-NEXT:    daddiu $5, $zero, 0
; HYBRID-NEXT:    daddiu $6, $zero, 0
; HYBRID-NEXT:    daddiu $7, $zero, 0
; HYBRID-NEXT:    .reloc .Ltmp1, R_MIPS_JALR, __sync_val_compare_and_swap_16
; HYBRID-NEXT:  .Ltmp1:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    daddiu $8, $zero, 0
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: load:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(load)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(load)))
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_val_compare_and_swap_16)($gp)
; HYBRID-CAP-PTR-NEXT:    daddiu $4, $zero, 0
; HYBRID-CAP-PTR-NEXT:    daddiu $5, $zero, 0
; HYBRID-CAP-PTR-NEXT:    daddiu $6, $zero, 0
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp1, R_MIPS_JALR, __sync_val_compare_and_swap_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp1:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    daddiu $7, $zero, 0
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@load
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[VAL:%.*]] = load atomic i128, ptr addrspace(200) [[PTR]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[VAL]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@load
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[VAL:%.*]] = load atomic i128, ptr addrspace(200) [[PTR]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[VAL]]
;
  %val = load atomic i128, ptr addrspace(200) %ptr seq_cst, align 16
  ret i128 %val
}

define i128 @atomic_xchg(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_xchg:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_lock_test_and_set_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_xchg:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_xchg)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_xchg)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_lock_test_and_set_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp2, R_MIPS_JALR, __sync_lock_test_and_set_16
; HYBRID-NEXT:  .Ltmp2:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_xchg:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_xchg)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_xchg)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_lock_test_and_set_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp2, R_MIPS_JALR, __sync_lock_test_and_set_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp2:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_xchg
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw xchg ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_xchg
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw xchg ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw xchg ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_add(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_add:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_add_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_add:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_add)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_add)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_add_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp3, R_MIPS_JALR, __sync_fetch_and_add_16
; HYBRID-NEXT:  .Ltmp3:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_add:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_add)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_add)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_add_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp3, R_MIPS_JALR, __sync_fetch_and_add_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp3:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_add
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw add ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_add
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw add ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw add ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_sub(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_sub:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_sub_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_sub:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_sub)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_sub)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_sub_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp4, R_MIPS_JALR, __sync_fetch_and_sub_16
; HYBRID-NEXT:  .Ltmp4:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_sub:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_sub)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_sub)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_sub_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp4, R_MIPS_JALR, __sync_fetch_and_sub_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp4:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_sub
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw sub ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_sub
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw sub ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw sub ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_and(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_and:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_and_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_and:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_and)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_and)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_and_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp5, R_MIPS_JALR, __sync_fetch_and_and_16
; HYBRID-NEXT:  .Ltmp5:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_and:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_and)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_and)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_and_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp5, R_MIPS_JALR, __sync_fetch_and_and_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp5:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_and
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw and ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_and
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw and ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw and ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_nand(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_nand:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_nand_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_nand:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_nand)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_nand)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_nand_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp6, R_MIPS_JALR, __sync_fetch_and_nand_16
; HYBRID-NEXT:  .Ltmp6:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_nand:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_nand)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_nand)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_nand_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp6, R_MIPS_JALR, __sync_fetch_and_nand_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp6:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_nand
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw nand ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_nand
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw nand ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw nand ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_or(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_or:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_or_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_or:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_or)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_or)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_or_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp7, R_MIPS_JALR, __sync_fetch_and_or_16
; HYBRID-NEXT:  .Ltmp7:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_or:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_or)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_or)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_or_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp7, R_MIPS_JALR, __sync_fetch_and_or_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp7:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_or
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw or ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_or
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw or ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw or ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_xor(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_xor:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_xor_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_xor:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_xor)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_xor)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_xor_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp8, R_MIPS_JALR, __sync_fetch_and_xor_16
; HYBRID-NEXT:  .Ltmp8:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_xor:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_xor)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_xor)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_xor_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp8, R_MIPS_JALR, __sync_fetch_and_xor_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp8:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_xor
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw xor ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_xor
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw xor ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw xor ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_max(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_max:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_max_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_max:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_max)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_max)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_max_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp9, R_MIPS_JALR, __sync_fetch_and_max_16
; HYBRID-NEXT:  .Ltmp9:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_max:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_max)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_max)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_max_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp9, R_MIPS_JALR, __sync_fetch_and_max_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp9:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_max
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw max ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_max
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw max ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw max ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_min(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_min:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_min_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_min:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_min)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_min)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_min_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp10, R_MIPS_JALR, __sync_fetch_and_min_16
; HYBRID-NEXT:  .Ltmp10:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_min:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_min)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_min)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_min_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp10, R_MIPS_JALR, __sync_fetch_and_min_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp10:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_min
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw min ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_min
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw min ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw min ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_umax(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_umax:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_umax_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_umax:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_umax)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_umax)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_umax_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp11, R_MIPS_JALR, __sync_fetch_and_umax_16
; HYBRID-NEXT:  .Ltmp11:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_umax:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_umax)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_umax)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_umax_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp11, R_MIPS_JALR, __sync_fetch_and_umax_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp11:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_umax
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw umax ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_umax
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw umax ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw umax ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_umin(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-LABEL: atomic_umin:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -16
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_fetch_and_umin_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 16
;
; HYBRID-LABEL: atomic_umin:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -16
; HYBRID-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_umin)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_umin)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_fetch_and_umin_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp12, R_MIPS_JALR, __sync_fetch_and_umin_16
; HYBRID-NEXT:  .Ltmp12:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 16
;
; HYBRID-CAP-PTR-LABEL: atomic_umin:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -16
; HYBRID-CAP-PTR-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(atomic_umin)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(atomic_umin)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_fetch_and_umin_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp12, R_MIPS_JALR, __sync_fetch_and_umin_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp12:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $gp, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 16
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_umin
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP:%.*]] = atomicrmw umin ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret i128 [[TMP]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_umin
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP:%.*]] = atomicrmw umin ptr addrspace(200) [[PTR]], i128 [[VAL]] monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret i128 [[TMP]]
;
  %tmp = atomicrmw umin ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define { i128, i1 } @cmpxchg_weak(ptr addrspace(200) %ptr, i128 %exp, i128 %new) nounwind {
; PURECAP-LABEL: cmpxchg_weak:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -32
; PURECAP-NEXT:    csd $17, $zero, 24($c11) # 8-byte Folded Spill
; PURECAP-NEXT:    csd $16, $zero, 16($c11) # 8-byte Folded Spill
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    move $16, $5
; PURECAP-NEXT:    move $17, $4
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_val_compare_and_swap_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    xor $1, $2, $17
; PURECAP-NEXT:    xor $4, $3, $16
; PURECAP-NEXT:    or $1, $4, $1
; PURECAP-NEXT:    sltiu $4, $1, 1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cld $16, $zero, 16($c11) # 8-byte Folded Reload
; PURECAP-NEXT:    cld $17, $zero, 24($c11) # 8-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 32
;
; HYBRID-LABEL: cmpxchg_weak:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -32
; HYBRID-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $17, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $16, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    move $16, $6
; HYBRID-NEXT:    move $17, $5
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(cmpxchg_weak)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(cmpxchg_weak)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_val_compare_and_swap_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp13, R_MIPS_JALR, __sync_val_compare_and_swap_16
; HYBRID-NEXT:  .Ltmp13:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    xor $1, $2, $17
; HYBRID-NEXT:    xor $4, $3, $16
; HYBRID-NEXT:    or $1, $4, $1
; HYBRID-NEXT:    sltiu $4, $1, 1
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $16, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $17, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 32
;
; HYBRID-CAP-PTR-LABEL: cmpxchg_weak:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -32
; HYBRID-CAP-PTR-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $17, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $16, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    move $16, $5
; HYBRID-CAP-PTR-NEXT:    move $17, $4
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(cmpxchg_weak)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(cmpxchg_weak)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_val_compare_and_swap_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp13, R_MIPS_JALR, __sync_val_compare_and_swap_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp13:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    xor $1, $2, $17
; HYBRID-CAP-PTR-NEXT:    xor $4, $3, $16
; HYBRID-CAP-PTR-NEXT:    or $1, $4, $1
; HYBRID-CAP-PTR-NEXT:    sltiu $4, $1, 1
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $16, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $17, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 32
; PURECAP-IR-LABEL: define {{[^@]+}}@cmpxchg_weak
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[EXP:%.*]], i128 [[NEW:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence acq_rel
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = cmpxchg weak ptr addrspace(200) [[PTR]], i128 [[EXP]], i128 [[NEW]] monotonic monotonic, align 16
; PURECAP-IR-NEXT:    fence acq_rel
; PURECAP-IR-NEXT:    ret { i128, i1 } [[TMP1]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@cmpxchg_weak
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[EXP:%.*]], i128 [[NEW:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence acq_rel
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = cmpxchg weak ptr addrspace(200) [[PTR]], i128 [[EXP]], i128 [[NEW]] monotonic monotonic, align 16
; HYBRID-IR-NEXT:    fence acq_rel
; HYBRID-IR-NEXT:    ret { i128, i1 } [[TMP1]]
;
  %1 = cmpxchg weak ptr addrspace(200) %ptr, i128 %exp, i128 %new acq_rel acquire
  ret { i128, i1 } %1
}

define { i128, i1 } @cmpxchg_strong(ptr addrspace(200) %ptr, i128 %exp, i128 %new) nounwind {
; PURECAP-LABEL: cmpxchg_strong:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset $c11, $c11, -32
; PURECAP-NEXT:    csd $17, $zero, 24($c11) # 8-byte Folded Spill
; PURECAP-NEXT:    csd $16, $zero, 16($c11) # 8-byte Folded Spill
; PURECAP-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; PURECAP-NEXT:    move $16, $5
; PURECAP-NEXT:    move $17, $4
; PURECAP-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; PURECAP-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; PURECAP-NEXT:    cgetpccincoffset $c1, $1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clcbi $c12, %capcall20(__sync_val_compare_and_swap_16)($c1)
; PURECAP-NEXT:    cjalr $c12, $c17
; PURECAP-NEXT:    nop
; PURECAP-NEXT:    xor $1, $2, $17
; PURECAP-NEXT:    xor $4, $3, $16
; PURECAP-NEXT:    or $1, $4, $1
; PURECAP-NEXT:    sltiu $4, $1, 1
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; PURECAP-NEXT:    cld $16, $zero, 16($c11) # 8-byte Folded Reload
; PURECAP-NEXT:    cld $17, $zero, 24($c11) # 8-byte Folded Reload
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cincoffset $c11, $c11, 32
;
; HYBRID-LABEL: cmpxchg_strong:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    daddiu $sp, $sp, -32
; HYBRID-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $17, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $16, 0($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    move $16, $6
; HYBRID-NEXT:    move $17, $5
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(cmpxchg_strong)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(cmpxchg_strong)))
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $25, %call16(__sync_val_compare_and_swap_16)($gp)
; HYBRID-NEXT:    .reloc .Ltmp14, R_MIPS_JALR, __sync_val_compare_and_swap_16
; HYBRID-NEXT:  .Ltmp14:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    xor $1, $2, $17
; HYBRID-NEXT:    xor $4, $3, $16
; HYBRID-NEXT:    or $1, $4, $1
; HYBRID-NEXT:    sltiu $4, $1, 1
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    ld $16, 0($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $17, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 32
;
; HYBRID-CAP-PTR-LABEL: cmpxchg_strong:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, -32
; HYBRID-CAP-PTR-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $17, 8($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd $16, 0($sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    move $16, $5
; HYBRID-CAP-PTR-NEXT:    move $17, $4
; HYBRID-CAP-PTR-NEXT:    lui $1, %hi(%neg(%gp_rel(cmpxchg_strong)))
; HYBRID-CAP-PTR-NEXT:    daddu $1, $1, $25
; HYBRID-CAP-PTR-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(cmpxchg_strong)))
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $25, %call16(__sync_val_compare_and_swap_16)($gp)
; HYBRID-CAP-PTR-NEXT:    .reloc .Ltmp14, R_MIPS_JALR, __sync_val_compare_and_swap_16
; HYBRID-CAP-PTR-NEXT:  .Ltmp14:
; HYBRID-CAP-PTR-NEXT:    jalr $25
; HYBRID-CAP-PTR-NEXT:    nop
; HYBRID-CAP-PTR-NEXT:    xor $1, $2, $17
; HYBRID-CAP-PTR-NEXT:    xor $4, $3, $16
; HYBRID-CAP-PTR-NEXT:    or $1, $4, $1
; HYBRID-CAP-PTR-NEXT:    sltiu $4, $1, 1
; HYBRID-CAP-PTR-NEXT:    sync
; HYBRID-CAP-PTR-NEXT:    ld $16, 0($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $17, 8($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    jr $ra
; HYBRID-CAP-PTR-NEXT:    daddiu $sp, $sp, 32
; PURECAP-IR-LABEL: define {{[^@]+}}@cmpxchg_strong
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[EXP:%.*]], i128 [[NEW:%.*]]) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = cmpxchg ptr addrspace(200) [[PTR]], i128 [[EXP]], i128 [[NEW]] monotonic monotonic, align 16
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    ret { i128, i1 } [[TMP1]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@cmpxchg_strong
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[EXP:%.*]], i128 [[NEW:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = cmpxchg ptr addrspace(200) [[PTR]], i128 [[EXP]], i128 [[NEW]] monotonic monotonic, align 16
; HYBRID-IR-NEXT:    fence seq_cst
; HYBRID-IR-NEXT:    ret { i128, i1 } [[TMP1]]
;
  %1 = cmpxchg ptr addrspace(200) %ptr, i128 %exp, i128 %new seq_cst seq_cst
  ret { i128, i1 } %1
}
