; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/stack-bounds-opaque-spill-too-early.ll
;; After merging to LLVM 15 the stack bounds pass the switch to opqaue pointers caused
;; miscompilations in the stack bounding pass (the unbounded value was used instead of
;; the bounded one due to the removal of the bitcast instructions).
; REQUIRES: asserts
; RUN: opt -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -cheri-bound-allocas -o - -S %s -debug-only=cheri-bound-allocas 2>%t.dbg| FileCheck %s
; RUN: FileCheck %s -input-file=%t.dbg -check-prefix DBG
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap %s -o - | FileCheck %s -check-prefix ASM
target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"

; DBG-LABEL: Checking function lazy_bind_args
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %0 = load ptr addrspace(200), ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=16, alloca size=16, current GEP offset=0 for ptr addrspace(200)
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %0 = load ptr addrspace(200), ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:  -Adding stack bounds since it is passed to call:   %call = call ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef nonnull %cap)
; DBG-NEXT: cheri-bound-allocas: Found alloca use that needs bounds:   %call = call ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef nonnull %cap)
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=16, alloca size=16, current GEP offset=0 for ptr addrspace(200)
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:   -Stack slot used as value and not pointer -> must set bounds
; DBG-NEXT: cheri-bound-allocas: Found alloca use that needs bounds: store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200(i64 16, ptr addrspace(200) nonnull %cap)
; DBG-NEXT: cheri-bound-allocas: lazy_bind_args: 2 of 5 users need bounds for   %cap = alloca ptr addrspace(200), align 16, addrspace(200)
; DBG-NEXT: lazy_bind_args: setting bounds on stack alloca to 16  %cap = alloca ptr addrspace(200), align 16, addrspace(200)

declare void @llvm.lifetime.start.p200(i64 immarg, ptr addrspace(200) nocapture) addrspace(200)

declare ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef) addrspace(200)

declare void @cheribsdtest_check_cap_eq(ptr addrspace(200) noundef, ptr addrspace(200) noundef) addrspace(200)

define dso_local void @lazy_bind_args() addrspace(200) nounwind {
; ASM-LABEL: lazy_bind_args:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    cincoffset $c11, $c11, -48
; ASM-NEXT:    csc $c18, $zero, 32($c11) # 16-byte Folded Spill
; ASM-NEXT:    csc $c17, $zero, 16($c11) # 16-byte Folded Spill
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c18, $1
; ASM-NEXT:    csetbounds $c1, $c11, 16
; ASM-NEXT:    csc $c1, $zero, 0($c11)
; ASM-NEXT:    clcbi $c12, %capcall20(cheribsdtest_dynamic_identity_cap)($c18)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    csetbounds $c3, $c11, 16
; ASM-NEXT:    clc $c1, $zero, 0($c11)
; ASM-NEXT:    cmove $c4, $c3
; ASM-NEXT:    clcbi $c12, %capcall20(cheribsdtest_check_cap_eq)($c18)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cmove $c3, $c1
; ASM-NEXT:    clc $c17, $zero, 16($c11) # 16-byte Folded Reload
; ASM-NEXT:    clc $c18, $zero, 32($c11) # 16-byte Folded Reload
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 48
; CHECK-LABEL: define {{[^@]+}}@lazy_bind_args
; CHECK-SAME: () addrspace(200) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CAP:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
; CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 16, ptr addrspace(200) nonnull [[CAP]])
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[CAP]], i64 16)
; CHECK-NEXT:    store ptr addrspace(200) [[TMP0]], ptr addrspace(200) [[CAP]], align 16
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[CAP]], i64 16)
; CHECK-NEXT:    [[CALL:%.*]] = call ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef nonnull [[TMP1]])
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[CAP]], align 16
; CHECK-NEXT:    call void @cheribsdtest_check_cap_eq(ptr addrspace(200) noundef [[TMP2]], ptr addrspace(200) noundef [[CALL]])
; CHECK-NEXT:    ret void
;
entry:
  %cap = alloca ptr addrspace(200), align 16, addrspace(200)
  call void @llvm.lifetime.start.p200(i64 16, ptr addrspace(200) nonnull %cap)
  store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
  %call = call ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef nonnull %cap)
  %0 = load ptr addrspace(200), ptr addrspace(200) %cap, align 16
  call void @cheribsdtest_check_cap_eq(ptr addrspace(200) noundef %0, ptr addrspace(200) noundef %call)
  ret void
}
