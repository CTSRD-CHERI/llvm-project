; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/setoffset-multiple-uses.ll
; RUN: opt -S -passes=instcombine -o - %s | FileCheck %s
; RUN: opt -S -passes=instcombine -o - %s | llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -O1 - -o - | %cheri_FileCheck %s --check-prefix ASM

target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"
; Reduced test case for a crash in the new optimization to fold multiple setoffset calls (orignally found when compiling libunwind)

declare i64 @check_fold(i64) addrspace(200)
declare void @check_fold_i8ptr(i8 addrspace(200)*) addrspace(200)
declare i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)*) addrspace(200)
declare i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)*, i64) addrspace(200)

define void @infer_values_from_null_set_offset() addrspace(200) nounwind {
; ASM-LABEL: infer_values_from_null_set_offset:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -16
; ASM-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    clcbi $c12, %capcall20(check_fold)($c1)
; ASM-NEXT:    lui $1, 1
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    ori $4, $1, 57920
; ASM-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 16
; CHECK-LABEL: define {{[^@]+}}@infer_values_from_null_set_offset
; CHECK-SAME: () addrspace(200) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    [[OFFSET_CHECK:%.*]] = call i64 @check_fold(i64 123456)
; CHECK-NEXT:    ret void
;
  %with_offset = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* null, i64 123456)
  %offset = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* nonnull %with_offset)
  %offset_check = call i64 @check_fold(i64 %offset)
  ret void
}

define void @multiple_uses_big_constant() addrspace(200) nounwind {
; ASM-LABEL: multiple_uses_big_constant:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -48
; ASM-NEXT:    csc $c19, $zero, 32($c11) # 16-byte Folded Spill
; ASM-NEXT:    csc $c18, $zero, 16($c11) # 16-byte Folded Spill
; ASM-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c19, $1
; ASM-NEXT:    lui $1, 1
; ASM-NEXT:    clcbi $c12, %capcall20(check_fold_i8ptr)($c19)
; ASM-NEXT:    ori $1, $1, 57920
; ASM-NEXT:    cincoffset $c18, $cnull, $1
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cmove $c3, $c18
; ASM-NEXT:    clcbi $c12, %capcall20(check_fold_i8ptr)($c19)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cmove $c3, $c18
; ASM-NEXT:    clcbi $c12, %capcall20(check_fold_i8ptr)($c19)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cmove $c3, $c18
; ASM-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; ASM-NEXT:    clc $c18, $zero, 16($c11) # 16-byte Folded Reload
; ASM-NEXT:    clc $c19, $zero, 32($c11) # 16-byte Folded Reload
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 48
; CHECK-LABEL: define {{[^@]+}}@multiple_uses_big_constant
; CHECK-SAME: () addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 123456))
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 123456))
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 123456))
; CHECK-NEXT:    ret void
;
  %with_offset = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* null, i64 123456)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  ret void
}

; Here we should use an immediate cincoffset:
define void @multiple_uses_small_constant() addrspace(200) nounwind {
; ASM-LABEL: multiple_uses_small_constant:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -32
; ASM-NEXT:    csc $c18, $zero, 16($c11) # 16-byte Folded Spill
; ASM-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c18, $1
; ASM-NEXT:    clcbi $c12, %capcall20(check_fold_i8ptr)($c18)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cincoffset $c3, $cnull, 123
; ASM-NEXT:    clcbi $c12, %capcall20(check_fold_i8ptr)($c18)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cincoffset $c3, $cnull, 123
; ASM-NEXT:    clcbi $c12, %capcall20(check_fold_i8ptr)($c18)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cincoffset $c3, $cnull, 123
; ASM-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; ASM-NEXT:    clc $c18, $zero, 16($c11) # 16-byte Folded Reload
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 32
; CHECK-LABEL: define {{[^@]+}}@multiple_uses_small_constant
; CHECK-SAME: () addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 123))
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 123))
; CHECK-NEXT:    call void @check_fold_i8ptr(i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 123))
; CHECK-NEXT:    ret void
;
  %with_offset = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* null, i64 123)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  call void @check_fold_i8ptr(i8 addrspace(200)* %with_offset)
  ret void
}
