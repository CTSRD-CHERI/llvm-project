; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/atomic-load-store-cap-ptr.ll
; Check that we can generate sensible code for atomic operations using capability pointers
; https://github.com/CTSRD-CHERI/llvm-project/issues/470
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap %s -o - | FileCheck %s --check-prefix=PURECAP
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi n64 %s -o - | FileCheck %s --check-prefix=HYBRID


define i8 @load_8(ptr addrspace(200) %ptr) nounwind {
; PURECAP-LABEL: load_8:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    clb $2, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: load_8:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    clb $2, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %val = load atomic i8, ptr addrspace(200) %ptr seq_cst, align 1
  ret i8 %val
}

define i16 @load_16(ptr addrspace(200) %ptr) nounwind {
; PURECAP-LABEL: load_16:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    clh $2, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: load_16:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    clh $2, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %val = load atomic i16, ptr addrspace(200) %ptr seq_cst, align 2
  ret i16 %val
}

define i32 @load_32(ptr addrspace(200) %ptr) nounwind {
; PURECAP-LABEL: load_32:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    clw $2, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: load_32:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    clw $2, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %val = load atomic i32, ptr addrspace(200) %ptr seq_cst, align 4
  ret i32 %val
}

define i64 @load_range(ptr addrspace(200) %ptr) nounwind {
; PURECAP-LABEL: load_range:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cld $2, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: load_range:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cld $2, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %val = load atomic i64, ptr addrspace(200) %ptr seq_cst, align 8
  ret i64 %val
}

define ptr addrspace(200) @load_cap(ptr addrspace(200) %ptr) nounwind {
; PURECAP-LABEL: load_cap:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    clc $c3, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: load_cap:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    clc $c3, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %val = load atomic ptr addrspace(200), ptr addrspace(200) %ptr seq_cst, align 16
  ret ptr addrspace(200) %val
}

define i8 @store_8(ptr addrspace(200) %ptr, i8 %val) nounwind {
; PURECAP-LABEL: store_8:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    sll $2, $4, 0
; PURECAP-NEXT:    csb $2, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: store_8:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    sll $2, $4, 0
; HYBRID-NEXT:    csb $2, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  store atomic i8 %val, ptr addrspace(200) %ptr seq_cst, align 1
  ret i8 %val
}

define i16 @store_16(ptr addrspace(200) %ptr, i16 %val) nounwind {
; PURECAP-LABEL: store_16:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    sll $2, $4, 0
; PURECAP-NEXT:    csh $2, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: store_16:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    sll $2, $4, 0
; HYBRID-NEXT:    csh $2, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  store atomic i16 %val, ptr addrspace(200) %ptr seq_cst, align 2
  ret i16 %val
}

define i32 @store_32(ptr addrspace(200) %ptr, i32 %val) nounwind {
; PURECAP-LABEL: store_32:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    sll $2, $4, 0
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    csw $2, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: store_32:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    sll $2, $4, 0
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    csw $2, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  store atomic i32 %val, ptr addrspace(200) %ptr seq_cst, align 4
  ret i32 %val
}

define i64 @store_range(ptr addrspace(200) %ptr, i64 %val) nounwind {
; PURECAP-LABEL: store_range:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    csd $4, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    move $2, $4
;
; HYBRID-LABEL: store_range:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    csd $4, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    move $2, $4
  store atomic i64 %val, ptr addrspace(200) %ptr seq_cst, align 8
  ret i64 %val
}

define ptr addrspace(200) @store_cap(ptr addrspace(200) %ptr, ptr addrspace(200) %val) nounwind {
; PURECAP-LABEL: store_cap:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    csc $c4, $zero, 0($c3)
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    cmove $c3, $c4
;
; HYBRID-LABEL: store_cap:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    csc $c4, $zero, 0($c3)
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    cmove $c3, $c4
  store atomic ptr addrspace(200) %val, ptr addrspace(200) %ptr seq_cst, align 16
  ret ptr addrspace(200) %val
}
