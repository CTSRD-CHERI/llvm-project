; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --scrub-attributes --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/gvn-capability-store-to-load-fwd.ll
; Check that  GVN does not attempt to read capability fields that it can't get the bits for
; This is https://github.com/CTSRD-CHERI/llvm-project/issues/385
; GVN was previously doing the following invalid transformation (Note the shift by 64 of the ptrtoint result)
;   %ai = alloca %suspicious_type, align 16, addrspace(200)
;   %tmp33 = bitcast %2 addrspace(200)* %ai to i8 addrspace(200)* addrspace(200)*
;   %tmp34 = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %tmp33, align 16
;   %0 = ptrtoint i8 addrspace(200)* %tmp34 to i64 ; INCORRECT transformation (does not transfer all bits)
;   %1 = lshr i64 %0, 64   ; Shift right by 64 to get field #2
;   %2 = trunc i64 %1 to i32 ; truncate to drop the high bits
; It assumed it could get bits 32-63 by doing a ptrtoint, but on CHERI-MIPS ptrtoint returns bits 65-127

; RUN: opt -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -S -aa-pipeline=basic-aa -passes=gvn -o - %s | FileCheck %s
; RUN: opt -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -S -aa-pipeline=basic-aa -passes=gvn -o - %s | llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -O0 -o - | FileCheck %s --check-prefix=ASM

; Check in the baseline (broken test now) to show the diff in the fixed commit

target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"

%struct.addrinfo = type { i32, i32, i32, i32, i32, ptr addrspace(200), ptr addrspace(200), ptr addrspace(200) }


define i32 @first_i32_store_to_load_fwd(ptr addrspace(200) %arg) local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: first_i32_store_to_load_fwd:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -80
; ASM-NEXT:    csc $c3, $zero, 0($c11)
; ASM-NEXT:    clw $2, $zero, 0($c11)
; ASM-NEXT:    cincoffset $c11, $c11, 80
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    nop
; CHECK-LABEL: define i32 @first_i32_store_to_load_fwd
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[STACKVAL:%.*]] = alloca [[STRUCT_ADDRINFO:%.*]], align 16, addrspace(200)
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[STACKVAL]], align 16
; CHECK-NEXT:    [[RESULT:%.*]] = load i32, ptr addrspace(200) [[STACKVAL]], align 4
; CHECK-NEXT:    ret i32 [[RESULT]]
;
  %stackval = alloca %struct.addrinfo, align 16, addrspace(200)
  %field = getelementptr inbounds %struct.addrinfo, ptr addrspace(200) %stackval, i64 0, i32 0
  %as_cap = bitcast ptr addrspace(200) %stackval to ptr addrspace(200)
  store ptr addrspace(200) %arg, ptr addrspace(200) %as_cap, align 16
  %result = load i32, ptr addrspace(200) %field, align 4
  ret i32 %result
}

define i32 @second_i32_store_to_load_fwd(ptr addrspace(200) %arg) local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: second_i32_store_to_load_fwd:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -80
; ASM-NEXT:    csc $c3, $zero, 0($c11)
; ASM-NEXT:    clw $2, $zero, 4($c11)
; ASM-NEXT:    cincoffset $c11, $c11, 80
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    nop
; CHECK-LABEL: define i32 @second_i32_store_to_load_fwd
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[STACKVAL:%.*]] = alloca [[STRUCT_ADDRINFO:%.*]], align 16, addrspace(200)
; CHECK-NEXT:    [[FIELD:%.*]] = getelementptr inbounds [[STRUCT_ADDRINFO]], ptr addrspace(200) [[STACKVAL]], i64 0, i32 1
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[STACKVAL]], align 16
; CHECK-NEXT:    [[RESULT:%.*]] = load i32, ptr addrspace(200) [[FIELD]], align 4
; CHECK-NEXT:    ret i32 [[RESULT]]
;
  %stackval = alloca %struct.addrinfo, align 16, addrspace(200)
  %field = getelementptr inbounds %struct.addrinfo, ptr addrspace(200) %stackval, i64 0, i32 1
  %as_cap = bitcast ptr addrspace(200) %stackval to ptr addrspace(200)
  store ptr addrspace(200) %arg, ptr addrspace(200) %as_cap, align 16
  %result = load i32, ptr addrspace(200) %field, align 4
  ret i32 %result
}

define i32 @third_i32_store_to_load_fwd(ptr addrspace(200) %arg) local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: third_i32_store_to_load_fwd:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -80
; ASM-NEXT:    csc $c3, $zero, 0($c11)
; ASM-NEXT:    clw $2, $zero, 8($c11)
; ASM-NEXT:    cincoffset $c11, $c11, 80
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    nop
; CHECK-LABEL: define i32 @third_i32_store_to_load_fwd
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[STACKVAL:%.*]] = alloca [[STRUCT_ADDRINFO:%.*]], align 16, addrspace(200)
; CHECK-NEXT:    [[FIELD:%.*]] = getelementptr inbounds [[STRUCT_ADDRINFO]], ptr addrspace(200) [[STACKVAL]], i64 0, i32 2
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[STACKVAL]], align 16
; CHECK-NEXT:    [[RESULT:%.*]] = load i32, ptr addrspace(200) [[FIELD]], align 4
; CHECK-NEXT:    ret i32 [[RESULT]]
;
  %stackval = alloca %struct.addrinfo, align 16, addrspace(200)
  %field = getelementptr inbounds %struct.addrinfo, ptr addrspace(200) %stackval, i64 0, i32 2
  %as_cap = bitcast ptr addrspace(200) %stackval to ptr addrspace(200)
  store ptr addrspace(200) %arg, ptr addrspace(200) %as_cap, align 16
  %result = load i32, ptr addrspace(200) %field, align 4
  ret i32 %result
}

define i32 @fourth_i32_store_to_load_fwd(ptr addrspace(200) %arg) local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: fourth_i32_store_to_load_fwd:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -80
; ASM-NEXT:    csc $c3, $zero, 0($c11)
; ASM-NEXT:    clw $2, $zero, 12($c11)
; ASM-NEXT:    cincoffset $c11, $c11, 80
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    nop
; CHECK-LABEL: define i32 @fourth_i32_store_to_load_fwd
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[STACKVAL:%.*]] = alloca [[STRUCT_ADDRINFO:%.*]], align 16, addrspace(200)
; CHECK-NEXT:    [[FIELD:%.*]] = getelementptr inbounds [[STRUCT_ADDRINFO]], ptr addrspace(200) [[STACKVAL]], i64 0, i32 3
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[STACKVAL]], align 16
; CHECK-NEXT:    [[RESULT:%.*]] = load i32, ptr addrspace(200) [[FIELD]], align 4
; CHECK-NEXT:    ret i32 [[RESULT]]
;
  %stackval = alloca %struct.addrinfo, align 16, addrspace(200)
  %field = getelementptr inbounds %struct.addrinfo, ptr addrspace(200) %stackval, i64 0, i32 3
  %as_cap = bitcast ptr addrspace(200) %stackval to ptr addrspace(200)
  store ptr addrspace(200) %arg, ptr addrspace(200) %as_cap, align 16
  %result = load i32, ptr addrspace(200) %field, align 4
  ret i32 %result
}
