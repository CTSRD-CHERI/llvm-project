; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/bounded-allocas-lifetimes.ll
; NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
; CHERI-GENERIC-UTC: mir
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap %s -o - --stop-after=finalize-isel | FileCheck %s

; Check that lifetime markers don't get lost due to CheriBoundAllocas, as we'd
; risk StackSlotColoring reusing the slot.

declare void @use(i8 addrspace(200)*)

define void @static_alloca() {
  ; CHECK-LABEL: name: static_alloca
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   [[PseudoPccRelativeAddressPostRA:%[0-9]+]]:cherigpr = PseudoPccRelativeAddressPostRA &_CHERI_CAPABILITY_TABLE_, implicit-def dead early-clobber %1
  ; CHECK-NEXT:   [[CheriBoundedStackPseudoImm:%[0-9]+]]:cherigpr = CheriBoundedStackPseudoImm %stack.0, 0, 4
  ; CHECK-NEXT:   LIFETIME_START %stack.0
  ; CHECK-NEXT:   ADJCALLSTACKCAPDOWN 0, 0, implicit-def dead $c11, implicit $c11
  ; CHECK-NEXT:   [[LOADCAP_BigImm:%[0-9]+]]:cherigpr = LOADCAP_BigImm target-flags(mips-captable20-call) @use, [[PseudoPccRelativeAddressPostRA]] :: (load (s128) from call-entry @use)
  ; CHECK-NEXT:   $c3 = COPY [[CheriBoundedStackPseudoImm]]
  ; CHECK-NEXT:   CapJumpLinkPseudo killed [[LOADCAP_BigImm]], csr_cheri_purecap, implicit-def dead $c17, implicit-def dead $c26, implicit $c3, implicit-def $c11
  ; CHECK-NEXT:   ADJCALLSTACKCAPUP 0, 0, implicit-def dead $c11, implicit $c11
  ; CHECK-NEXT:   LIFETIME_END %stack.0
  ; CHECK-NEXT:   CapRetPseudo
  %1 = alloca i32, align 4, addrspace(200)
  %2 = bitcast i32 addrspace(200)* %1 to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 4, i8 addrspace(200)* %2)
  call void @use(i8 addrspace(200)* %2)
  call void @llvm.lifetime.end.p200i8(i64 4, i8 addrspace(200)* %2)
  ret void
}

; LIFETIME_START/LIFETIME_END only apply to static allocas, so we can't verify
; that the analysis works correctly, but the IR is here for completeness.
define void @dynamic_alloca(i64 zeroext %n) {
  ; CHECK-LABEL: name: dynamic_alloca
  ; CHECK: bb.0 (%ir-block.0):
  ; CHECK-NEXT:   liveins: $a0_64
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr64 = COPY $a0_64
  ; CHECK-NEXT:   [[PseudoPccRelativeAddressPostRA:%[0-9]+]]:cherigpr = PseudoPccRelativeAddressPostRA &_CHERI_CAPABILITY_TABLE_, implicit-def dead early-clobber %2
  ; CHECK-NEXT:   [[DSLL:%[0-9]+]]:gpr64 = DSLL [[COPY]], 2
  ; CHECK-NEXT:   [[DADDiu:%[0-9]+]]:gpr64 = nuw DADDiu [[DSLL]], 15
  ; CHECK-NEXT:   [[DADDiu1:%[0-9]+]]:gpr64 = DADDiu $zero_64, -16
  ; CHECK-NEXT:   [[AND64_:%[0-9]+]]:gpr64 = AND64 killed [[DADDiu]], killed [[DADDiu1]]
  ; CHECK-NEXT:   [[CRRL:%[0-9]+]]:gpr64 = CRRL [[AND64_]]
  ; CHECK-NEXT:   ADJCALLSTACKCAPDOWN 0, 0, implicit-def dead $c11, implicit $c11
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:cherigpr = COPY $c11
  ; CHECK-NEXT:   [[CGetAddr:%[0-9]+]]:gpr64 = CGetAddr [[COPY1]]
  ; CHECK-NEXT:   [[DSUBu:%[0-9]+]]:gpr64 = DSUBu killed [[CGetAddr]], [[CRRL]]
  ; CHECK-NEXT:   [[CRAM:%[0-9]+]]:gpr64 = CRAM [[AND64_]]
  ; CHECK-NEXT:   [[AND64_1:%[0-9]+]]:gpr64 = AND64 killed [[DSUBu]], killed [[CRAM]]
  ; CHECK-NEXT:   [[CSetAddr:%[0-9]+]]:cherigpr = CSetAddr [[COPY1]], killed [[AND64_1]]
  ; CHECK-NEXT:   [[CSetBounds:%[0-9]+]]:cherigpr = CSetBounds [[CSetAddr]], [[CRRL]]
  ; CHECK-NEXT:   $c11 = COPY [[CSetAddr]]
  ; CHECK-NEXT:   ADJCALLSTACKCAPUP 0, 0, implicit-def dead $c11, implicit $c11
  ; CHECK-NEXT:   [[CSetBounds1:%[0-9]+]]:cherigpr = CSetBounds killed [[CSetBounds]], [[DSLL]]
  ; CHECK-NEXT:   ADJCALLSTACKCAPDOWN 0, 0, implicit-def dead $c11, implicit $c11
  ; CHECK-NEXT:   [[LOADCAP_BigImm:%[0-9]+]]:cherigpr = LOADCAP_BigImm target-flags(mips-captable20-call) @use, [[PseudoPccRelativeAddressPostRA]] :: (load (s128) from call-entry @use)
  ; CHECK-NEXT:   $c3 = COPY [[CSetBounds1]]
  ; CHECK-NEXT:   CapJumpLinkPseudo killed [[LOADCAP_BigImm]], csr_cheri_purecap, implicit-def dead $c17, implicit-def dead $c26, implicit $c3, implicit-def $c11
  ; CHECK-NEXT:   ADJCALLSTACKCAPUP 0, 0, implicit-def dead $c11, implicit $c11
  ; CHECK-NEXT:   CapRetPseudo
  %1 = alloca i32, i64 %n, align 4, addrspace(200)
  %2 = bitcast i32 addrspace(200)* %1 to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 -1, i8 addrspace(200)* %2)
  call void @use(i8 addrspace(200)* %2)
  call void @llvm.lifetime.end.p200i8(i64 -1, i8 addrspace(200)* %2)
  ret void
}

declare void @llvm.lifetime.start.p200i8(i64, i8 addrspace(200)*)
declare void @llvm.lifetime.end.p200i8(i64, i8 addrspace(200)*)
