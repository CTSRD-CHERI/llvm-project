; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --scrub-attributes --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/ptradd-immediate.ll
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap < %s | FileCheck %s --check-prefix=PURECAP
;; Hybrid baseline to compare against
; RUN: sed 's/addrspace(200)//g' %s | llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi n64 | FileCheck %s --check-prefix=HYBRID

;; If both offsets are known to be non-negative it is safe to commute them and
;; use an immediate load.
define i32 @nneg_nneg(ptr addrspace(200) %p, i16 %x) {
; PURECAP-LABEL: nneg_nneg:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    andi $1, $4, 65535
; PURECAP-NEXT:    dsll $1, $1, 2
; PURECAP-NEXT:    clw $2, $1, 4($c3)
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: nneg_nneg:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    andi $1, $5, 65535
; HYBRID-NEXT:    dsll $1, $1, 2
; HYBRID-NEXT:    daddu $1, $4, $1
; HYBRID-NEXT:    lw $2, 4($1)
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %x.ext = zext i16 %x to i64
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 1, i64 %x.ext
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If both offsets are known to be negative it is safe to commute them and use
;; an immediate load.
define i32 @neg_neg(ptr addrspace(200) %p, i16 %x) {
; PURECAP-LABEL: neg_neg:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    ori $1, $4, 1
; PURECAP-NEXT:    andi $1, $1, 65535
; PURECAP-NEXT:    dnegu $1, $1
; PURECAP-NEXT:    dsll $1, $1, 2
; PURECAP-NEXT:    clw $2, $1, -4($c3)
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: neg_neg:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    andi $1, $5, 65534
; HYBRID-NEXT:    dsll $1, $1, 2
; HYBRID-NEXT:    ori $1, $1, 4
; HYBRID-NEXT:    dsubu $1, $4, $1
; HYBRID-NEXT:    lw $2, -4($1)
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %x.ext = zext i16 %x to i64
  %x.pos = or i64 %x.ext, 1
  %x.neg = sub i64 0, %x.pos
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 -1, i64 %x.neg
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If one offset is known to be non-negative and the other negative it is not in
;; general safe to commute them and use an immediate load.
define i32 @nneg_neg(ptr addrspace(200) %p, i16 %x) {
; PURECAP-LABEL: nneg_neg:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    andi $1, $4, 65534
; PURECAP-NEXT:    dsll $1, $1, 2
; PURECAP-NEXT:    ori $1, $1, 4
; PURECAP-NEXT:    daddiu $2, $zero, 4
; PURECAP-NEXT:    dsubu $1, $2, $1
; PURECAP-NEXT:    clw $2, $1, 0($c3)
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: nneg_neg:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    andi $1, $5, 65534
; HYBRID-NEXT:    dsll $1, $1, 2
; HYBRID-NEXT:    ori $1, $1, 4
; HYBRID-NEXT:    dsubu $1, $4, $1
; HYBRID-NEXT:    lw $2, 4($1)
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %x.ext = zext i16 %x to i64
  %x.pos = or i64 %x.ext, 1
  %x.neg = sub i64 0, %x.pos
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 1, i64 %x.neg
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If one offset is known to be non-negative and the other negative it is not in
;; general safe to commute them and use an immediate load.
define i32 @neg_nneg(ptr addrspace(200) %p, i16 %x) {
; PURECAP-LABEL: neg_nneg:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    andi $1, $4, 65535
; PURECAP-NEXT:    dsll $1, $1, 2
; PURECAP-NEXT:    clw $2, $1, -4($c3)
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: neg_nneg:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    andi $1, $5, 65535
; HYBRID-NEXT:    dsll $1, $1, 2
; HYBRID-NEXT:    daddu $1, $4, $1
; HYBRID-NEXT:    lw $2, -4($1)
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %x.ext = zext i16 %x to i64
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 -1, i64 %x.ext
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If we do not know the sign of one offset it is not in general safe to
;; commute them and use an immediate load.
define i32 @nneg_unknown(ptr addrspace(200) %p, i64 %x) {
; PURECAP-LABEL: nneg_unknown:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    dsll $1, $4, 2
; PURECAP-NEXT:    clw $2, $1, 4($c3)
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: nneg_unknown:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    dsll $1, $5, 2
; HYBRID-NEXT:    daddu $1, $4, $1
; HYBRID-NEXT:    lw $2, 4($1)
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 1, i64 %x
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}

;; If we do not know the sign of one offset it is not in general safe to
;; commute them and use an immediate load.
define i32 @neg_unknown(ptr addrspace(200) %p, i64 %x) {
; PURECAP-LABEL: neg_unknown:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    dsll $1, $4, 2
; PURECAP-NEXT:    clw $2, $1, -4($c3)
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: neg_unknown:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    dsll $1, $5, 2
; HYBRID-NEXT:    daddu $1, $4, $1
; HYBRID-NEXT:    lw $2, -4($1)
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
  %q = getelementptr [1 x i32], ptr addrspace(200) %p, i64 -1, i64 %x
  %ret = load i32, ptr addrspace(200) %q
  ret i32 %ret
}
