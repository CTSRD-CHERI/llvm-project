; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/atomic-rmw-cap-ptr.ll
; Check that we can generate sensible code for atomic operations using capability pointers
; https://github.com/CTSRD-CHERI/llvm-project/issues/470
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap %s -o - | FileCheck %s --check-prefix=PURECAP
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi n64 %s -o - | FileCheck %s --check-prefix=HYBRID

define i64 @atomic_cap_ptr_xchg(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_xchg:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB0_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    cscd $1, $4, $c3
; PURECAP-NEXT:    beqz $1, .LBB0_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_xchg:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB0_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    cscd $1, $4, $c3
; HYBRID-NEXT:    beqz $1, .LBB0_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw xchg i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_add(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_add:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB1_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    daddu $1, $2, $4
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB1_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_add:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB1_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    daddu $1, $2, $4
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB1_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw add i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_sub(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_sub:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB2_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    dsubu $1, $2, $4
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB2_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_sub:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB2_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    dsubu $1, $2, $4
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB2_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw sub i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_and(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_and:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB3_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    and $1, $2, $4
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB3_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_and:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB3_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    and $1, $2, $4
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB3_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw and i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_nand(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_nand:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB4_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    and $1, $2, $4
; PURECAP-NEXT:    nor $1, $zero, $1
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB4_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_nand:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB4_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    and $1, $2, $4
; HYBRID-NEXT:    nor $1, $zero, $1
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB4_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw nand i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_or(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_or:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB5_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    or $1, $2, $4
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB5_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_or:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB5_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    or $1, $2, $4
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB5_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw or i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_xor(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_xor:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB6_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    xor $1, $2, $4
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB6_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_xor:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB6_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    xor $1, $2, $4
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB6_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw xor i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_max(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_max:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB7_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    slt $3, $2, $4
; PURECAP-NEXT:    move $1, $2
; PURECAP-NEXT:    movn $1, $4, $3
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB7_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_max:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB7_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    slt $3, $2, $4
; HYBRID-NEXT:    move $1, $2
; HYBRID-NEXT:    movn $1, $4, $3
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB7_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw max i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_min(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_min:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB8_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    slt $3, $2, $4
; PURECAP-NEXT:    move $1, $2
; PURECAP-NEXT:    movz $1, $4, $3
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB8_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_min:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB8_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    slt $3, $2, $4
; HYBRID-NEXT:    move $1, $2
; HYBRID-NEXT:    movz $1, $4, $3
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB8_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw min i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_umax(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_umax:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB9_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    sltu $3, $2, $4
; PURECAP-NEXT:    move $1, $2
; PURECAP-NEXT:    movn $1, $4, $3
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB9_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_umax:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB9_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    sltu $3, $2, $4
; HYBRID-NEXT:    move $1, $2
; HYBRID-NEXT:    movn $1, $4, $3
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB9_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw umax i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define i64 @atomic_cap_ptr_umin(i64 addrspace(200)* %ptr, i64 %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_umin:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:  .LBB10_1: # %bb
; PURECAP-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-NEXT:    clld $2, $c3
; PURECAP-NEXT:    sltu $3, $2, $4
; PURECAP-NEXT:    move $1, $2
; PURECAP-NEXT:    movz $1, $4, $3
; PURECAP-NEXT:    cscd $1, $1, $c3
; PURECAP-NEXT:    beqz $1, .LBB10_1
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.2: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_umin:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:  .LBB10_1: # %bb
; HYBRID-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-NEXT:    clld $2, $c3
; HYBRID-NEXT:    sltu $3, $2, $4
; HYBRID-NEXT:    move $1, $2
; HYBRID-NEXT:    movz $1, $4, $3
; HYBRID-NEXT:    cscd $1, $1, $c3
; HYBRID-NEXT:    beqz $1, .LBB10_1
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.2: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw umin i64 addrspace(200)* %ptr, i64 %val seq_cst
  ret i64 %tmp
}

define float @atomic_cap_ptr_fadd(float addrspace(200)* %ptr, float %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_fadd:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clw $2, $zero, 0($c3)
; PURECAP-NEXT:    mtc1 $2, $f0
; PURECAP-NEXT:  .LBB11_1: # %atomicrmw.start
; PURECAP-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-NEXT:    # Child Loop BB11_2 Depth 2
; PURECAP-NEXT:    add.s $f0, $f0, $f12
; PURECAP-NEXT:    mfc1 $1, $f0
; PURECAP-NEXT:    move $3, $2
; PURECAP-NEXT:  .LBB11_2: # %atomicrmw.start
; PURECAP-NEXT:    # Parent Loop BB11_1 Depth=1
; PURECAP-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-NEXT:    cllw $2, $c3
; PURECAP-NEXT:    bne $2, $3, .LBB11_4
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-NEXT:    # in Loop: Header=BB11_2 Depth=2
; PURECAP-NEXT:    cscw $4, $1, $c3
; PURECAP-NEXT:    beqz $4, .LBB11_2
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  .LBB11_4: # %atomicrmw.start
; PURECAP-NEXT:    # in Loop: Header=BB11_1 Depth=1
; PURECAP-NEXT:    bne $2, $3, .LBB11_1
; PURECAP-NEXT:    mtc1 $2, $f0
; PURECAP-NEXT:  # %bb.5: # %atomicrmw.end
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_fadd:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    clw $2, $zero, 0($c3)
; HYBRID-NEXT:    mtc1 $2, $f0
; HYBRID-NEXT:  .LBB11_1: # %atomicrmw.start
; HYBRID-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-NEXT:    # Child Loop BB11_2 Depth 2
; HYBRID-NEXT:    add.s $f0, $f0, $f12
; HYBRID-NEXT:    mfc1 $1, $f0
; HYBRID-NEXT:    move $3, $2
; HYBRID-NEXT:  .LBB11_2: # %atomicrmw.start
; HYBRID-NEXT:    # Parent Loop BB11_1 Depth=1
; HYBRID-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-NEXT:    cllw $2, $c3
; HYBRID-NEXT:    bne $2, $3, .LBB11_4
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-NEXT:    # in Loop: Header=BB11_2 Depth=2
; HYBRID-NEXT:    cscw $4, $1, $c3
; HYBRID-NEXT:    beqz $4, .LBB11_2
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  .LBB11_4: # %atomicrmw.start
; HYBRID-NEXT:    # in Loop: Header=BB11_1 Depth=1
; HYBRID-NEXT:    bne $2, $3, .LBB11_1
; HYBRID-NEXT:    mtc1 $2, $f0
; HYBRID-NEXT:  # %bb.5: # %atomicrmw.end
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw fadd float addrspace(200)* %ptr, float %val seq_cst
  ret float %tmp
}

define float @atomic_cap_ptr_fsub(float addrspace(200)* %ptr, float %val) nounwind {
; PURECAP-LABEL: atomic_cap_ptr_fsub:
; PURECAP:       # %bb.0: # %bb
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    clw $2, $zero, 0($c3)
; PURECAP-NEXT:    mtc1 $2, $f0
; PURECAP-NEXT:  .LBB12_1: # %atomicrmw.start
; PURECAP-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-NEXT:    # Child Loop BB12_2 Depth 2
; PURECAP-NEXT:    sub.s $f0, $f0, $f12
; PURECAP-NEXT:    mfc1 $1, $f0
; PURECAP-NEXT:    move $3, $2
; PURECAP-NEXT:  .LBB12_2: # %atomicrmw.start
; PURECAP-NEXT:    # Parent Loop BB12_1 Depth=1
; PURECAP-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-NEXT:    cllw $2, $c3
; PURECAP-NEXT:    bne $2, $3, .LBB12_4
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-NEXT:    # in Loop: Header=BB12_2 Depth=2
; PURECAP-NEXT:    cscw $4, $1, $c3
; PURECAP-NEXT:    beqz $4, .LBB12_2
; PURECAP-NEXT:    nop
; PURECAP-NEXT:  .LBB12_4: # %atomicrmw.start
; PURECAP-NEXT:    # in Loop: Header=BB12_1 Depth=1
; PURECAP-NEXT:    bne $2, $3, .LBB12_1
; PURECAP-NEXT:    mtc1 $2, $f0
; PURECAP-NEXT:  # %bb.5: # %atomicrmw.end
; PURECAP-NEXT:    sync
; PURECAP-NEXT:    cjr $c17
; PURECAP-NEXT:    nop
;
; HYBRID-LABEL: atomic_cap_ptr_fsub:
; HYBRID:       # %bb.0: # %bb
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    clw $2, $zero, 0($c3)
; HYBRID-NEXT:    mtc1 $2, $f0
; HYBRID-NEXT:  .LBB12_1: # %atomicrmw.start
; HYBRID-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-NEXT:    # Child Loop BB12_2 Depth 2
; HYBRID-NEXT:    sub.s $f0, $f0, $f12
; HYBRID-NEXT:    mfc1 $1, $f0
; HYBRID-NEXT:    move $3, $2
; HYBRID-NEXT:  .LBB12_2: # %atomicrmw.start
; HYBRID-NEXT:    # Parent Loop BB12_1 Depth=1
; HYBRID-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-NEXT:    cllw $2, $c3
; HYBRID-NEXT:    bne $2, $3, .LBB12_4
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-NEXT:    # in Loop: Header=BB12_2 Depth=2
; HYBRID-NEXT:    cscw $4, $1, $c3
; HYBRID-NEXT:    beqz $4, .LBB12_2
; HYBRID-NEXT:    nop
; HYBRID-NEXT:  .LBB12_4: # %atomicrmw.start
; HYBRID-NEXT:    # in Loop: Header=BB12_1 Depth=1
; HYBRID-NEXT:    bne $2, $3, .LBB12_1
; HYBRID-NEXT:    mtc1 $2, $f0
; HYBRID-NEXT:  # %bb.5: # %atomicrmw.end
; HYBRID-NEXT:    sync
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    nop
bb:
  %tmp = atomicrmw fsub float addrspace(200)* %ptr, float %val seq_cst
  ret float %tmp
}
