; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/strcpy-to-memcpy-no-tags.ll
; Check that we can inline the loads/stores generated when simplifiying
; string libcalls to memcpy() (since it should be marked as non-tag-preserving).
; CHERI-GENERIC-UTC: llc
; Note: unlike other tests we do want to test attributes in this one.
; CHERI-GENERIC-UTC: opt --function-signature
; RUN: opt < %s -passes=instcombine -S | FileCheck %s --check-prefix=CHECK-IR
; RUN: opt < %s -passes=instcombine -S | llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap - -o - | FileCheck %s --check-prefix=CHECK-ASM
target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"

@str = private unnamed_addr addrspace(200) constant [17 x i8] c"exactly 16 chars\00", align 8

declare i8 addrspace(200)* @strcpy(i8 addrspace(200)*, i8 addrspace(200)*) addrspace(200)
declare i8 addrspace(200)* @stpcpy(i8 addrspace(200)*, i8 addrspace(200)*) addrspace(200)
declare i8 addrspace(200)* @strcat(i8 addrspace(200)*, i8 addrspace(200)*) addrspace(200)
declare i8 addrspace(200)* @strncpy(i8 addrspace(200)*, i8 addrspace(200)*, i64) addrspace(200)
declare i8 addrspace(200)* @stpncpy(i8 addrspace(200)*, i8 addrspace(200)*, i64) addrspace(200)

define void @test_strcpy_to_memcpy(i8 addrspace(200)* align 8 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_strcpy_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-ASM-NEXT:    cgetpccincoffset $c1, $1
; CHECK-ASM-NEXT:    clcbi $c1, %captab20(.Lstr)($c1)
; CHECK-ASM-NEXT:    cld $1, $zero, 0($c1)
; CHECK-ASM-NEXT:    clb $2, $zero, 16($c1)
; CHECK-ASM-NEXT:    cld $3, $zero, 8($c1)
; CHECK-ASM-NEXT:    csd $1, $zero, 0($c3)
; CHECK-ASM-NEXT:    csb $2, $zero, 16($c3)
; CHECK-ASM-NEXT:    cjr $c17
; CHECK-ASM-NEXT:    csd $3, $zero, 8($c3)
; CHECK-IR-LABEL: define {{[^@]+}}@test_strcpy_to_memcpy
; CHECK-IR-SAME: (i8 addrspace(200)* align 8 [[DST:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noundef nonnull align 8 dereferenceable(17) [[DST]], i8 addrspace(200)* noundef nonnull align 8 dereferenceable(17) getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0), i64 17, i1 false) #[[ATTR3:[0-9]+]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call i8 addrspace(200)* @strcpy(i8 addrspace(200)* %dst, i8 addrspace(200)* getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0))
  ret void
}

define void @test_stpcpy_to_memcpy(i8 addrspace(200)* align 8 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_stpcpy_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-ASM-NEXT:    cgetpccincoffset $c1, $1
; CHECK-ASM-NEXT:    clcbi $c1, %captab20(.Lstr)($c1)
; CHECK-ASM-NEXT:    cld $1, $zero, 0($c1)
; CHECK-ASM-NEXT:    clb $2, $zero, 16($c1)
; CHECK-ASM-NEXT:    cld $3, $zero, 8($c1)
; CHECK-ASM-NEXT:    csd $1, $zero, 0($c3)
; CHECK-ASM-NEXT:    csb $2, $zero, 16($c3)
; CHECK-ASM-NEXT:    cjr $c17
; CHECK-ASM-NEXT:    csd $3, $zero, 8($c3)
; CHECK-IR-LABEL: define {{[^@]+}}@test_stpcpy_to_memcpy
; CHECK-IR-SAME: (i8 addrspace(200)* align 8 [[DST:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noundef nonnull align 8 dereferenceable(17) [[DST]], i8 addrspace(200)* noundef nonnull align 8 dereferenceable(17) getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0), i64 17, i1 false) #[[ATTR3]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call i8 addrspace(200)* @stpcpy(i8 addrspace(200)* %dst, i8 addrspace(200)* getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0))
  ret void
}

define void @test_strcat_to_memcpy(i8 addrspace(200)* align 8 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_strcat_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    cincoffset $c11, $c11, -48
; CHECK-ASM-NEXT:    csc $c19, $zero, 32($c11) # 16-byte Folded Spill
; CHECK-ASM-NEXT:    csc $c18, $zero, 16($c11) # 16-byte Folded Spill
; CHECK-ASM-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; CHECK-ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-ASM-NEXT:    cgetpccincoffset $c19, $1
; CHECK-ASM-NEXT:    clcbi $c12, %capcall20(strlen)($c19)
; CHECK-ASM-NEXT:    cjalr $c12, $c17
; CHECK-ASM-NEXT:    cmove $c18, $c3
; CHECK-ASM-NEXT:    cincoffset $c3, $c18, $2
; CHECK-ASM-NEXT:    clcbi $c4, %captab20(.Lstr)($c19)
; CHECK-ASM-NEXT:    clcbi $c12, %capcall20(memcpy)($c19)
; CHECK-ASM-NEXT:    cjalr $c12, $c17
; CHECK-ASM-NEXT:    daddiu $4, $zero, 17
; CHECK-ASM-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; CHECK-ASM-NEXT:    clc $c18, $zero, 16($c11) # 16-byte Folded Reload
; CHECK-ASM-NEXT:    clc $c19, $zero, 32($c11) # 16-byte Folded Reload
; CHECK-ASM-NEXT:    cjr $c17
; CHECK-ASM-NEXT:    cincoffset $c11, $c11, 48
; CHECK-IR-LABEL: define {{[^@]+}}@test_strcat_to_memcpy
; CHECK-IR-SAME: (i8 addrspace(200)* align 8 [[DST:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[STRLEN:%.*]] = call i64 @strlen(i8 addrspace(200)* noundef nonnull dereferenceable(1) [[DST]])
; CHECK-IR-NEXT:    [[ENDPTR:%.*]] = getelementptr i8, i8 addrspace(200)* [[DST]], i64 [[STRLEN]]
; CHECK-IR-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noundef nonnull align 1 dereferenceable(17) [[ENDPTR]], i8 addrspace(200)* noundef nonnull align 8 dereferenceable(17) getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0), i64 17, i1 false) #[[ATTR4:[0-9]+]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call i8 addrspace(200)* @strcat(i8 addrspace(200)* %dst, i8 addrspace(200)* getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0))
  ret void
}


define void @test_strncpy_to_memcpy(i8 addrspace(200)* align 8 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_strncpy_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-ASM-NEXT:    cgetpccincoffset $c1, $1
; CHECK-ASM-NEXT:    clcbi $c1, %captab20(.Lstr)($c1)
; CHECK-ASM-NEXT:    cld $1, $zero, 0($c1)
; CHECK-ASM-NEXT:    clb $2, $zero, 16($c1)
; CHECK-ASM-NEXT:    cld $3, $zero, 8($c1)
; CHECK-ASM-NEXT:    csd $1, $zero, 0($c3)
; CHECK-ASM-NEXT:    csb $2, $zero, 16($c3)
; CHECK-ASM-NEXT:    cjr $c17
; CHECK-ASM-NEXT:    csd $3, $zero, 8($c3)
; CHECK-IR-LABEL: define {{[^@]+}}@test_strncpy_to_memcpy
; CHECK-IR-SAME: (i8 addrspace(200)* align 8 [[DST:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noundef nonnull align 8 dereferenceable(17) [[DST]], i8 addrspace(200)* noundef nonnull align 8 dereferenceable(17) getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0), i64 17, i1 false) #[[ATTR3]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call i8 addrspace(200)* @strncpy(i8 addrspace(200)* %dst, i8 addrspace(200)* getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0), i64 17)
  ret void
}

; Note: stpncpy is not handled by SimplifyLibcalls yet, so this should not be changed.
define void @test_stpncpy_to_memcpy(i8 addrspace(200)* align 8 %dst) addrspace(200) nounwind {
; CHECK-ASM-LABEL: test_stpncpy_to_memcpy:
; CHECK-ASM:       # %bb.0: # %entry
; CHECK-ASM-NEXT:    cincoffset $c11, $c11, -16
; CHECK-ASM-NEXT:    csc $c17, $zero, 0($c11) # 16-byte Folded Spill
; CHECK-ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-ASM-NEXT:    cgetpccincoffset $c1, $1
; CHECK-ASM-NEXT:    clcbi $c4, %captab20(.Lstr)($c1)
; CHECK-ASM-NEXT:    clcbi $c12, %capcall20(stpncpy)($c1)
; CHECK-ASM-NEXT:    cjalr $c12, $c17
; CHECK-ASM-NEXT:    daddiu $4, $zero, 17
; CHECK-ASM-NEXT:    clc $c17, $zero, 0($c11) # 16-byte Folded Reload
; CHECK-ASM-NEXT:    cjr $c17
; CHECK-ASM-NEXT:    cincoffset $c11, $c11, 16
; CHECK-IR-LABEL: define {{[^@]+}}@test_stpncpy_to_memcpy
; CHECK-IR-SAME: (i8 addrspace(200)* align 8 [[DST:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-IR-NEXT:  entry:
; CHECK-IR-NEXT:    [[CALL:%.*]] = call i8 addrspace(200)* @stpncpy(i8 addrspace(200)* [[DST]], i8 addrspace(200)* getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0), i64 17) #[[ATTR0]]
; CHECK-IR-NEXT:    ret void
;
entry:
  %call = call i8 addrspace(200)* @stpncpy(i8 addrspace(200)* %dst, i8 addrspace(200)* getelementptr inbounds ([17 x i8], [17 x i8] addrspace(200)* @str, i64 0, i64 0), i64 17)
  ret void
}

; UTC_ARGS: --disable
; CHECK-IR: attributes #[[ATTR0]] = { nounwind }
; The no_preserve_cheri_tags should be attribute 3/4 in all cases
; CHECK-IR: attributes #[[ATTR3]] = { no_preserve_cheri_tags nounwind }
; CHECK-IR: attributes #[[ATTR4]] = { no_preserve_cheri_tags }
