; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --scrub-attributes --version 2
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/subobject-bounds-redundant-setbounds.c.ll
; REQUIRES: asserts
; RUN: rm -f %t.dbg-opt %t.dbg-llc
; RUN: opt -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -cheri-bound-allocas -debug-only=cheri-bound-allocas -S -o - %s 2>%t.dbg-opt | FileCheck %s
; RUN: FileCheck %s -input-file=%t.dbg-opt -check-prefix DBG
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -debug-only=cheri-bound-allocas -o - %s 2>%t.dbg-llc | FileCheck %s -check-prefix ASM
; RUN: FileCheck %s -input-file=%t.dbg-llc -check-prefix DBG
target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"

; created from the following C source code (when compiled with subobject bounds):
; void use(void* arg);
;
;void use_inline(int* arg) {
;  *arg = 2;
;}
;
;int stack_array() {
;  int array[10];
;  use(array);
;  return array[5];
;}
;
;int stack_int() {
;  int value = 1;
;  use(&value);
;  return value;
;}
;
;int stack_int_inlined() {
;  int value = 1;
;  use_inline(&value);
;  return value;
;}


define void @use_inline(ptr addrspace(200) nocapture %arg) local_unnamed_addr addrspace(200) {
; ASM-LABEL: use_inline:
; ASM:       # %bb.0:
; ASM-NEXT:    addiu $1, $zero, 2
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    csw $1, $zero, 0($c3)
; CHECK-LABEL: define void @use_inline
; CHECK-SAME: (ptr addrspace(200) nocapture [[ARG:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    store i32 2, ptr addrspace(200) [[ARG]], align 4
; CHECK-NEXT:    ret void
;
  store i32 2, ptr addrspace(200) %arg, align 4
  ret void
}

define signext i32 @stack_array() local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: stack_array:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -80
; ASM-NEXT:    csc $c18, $zero, 64($c11) # 16-byte Folded Spill
; ASM-NEXT:    csc $c17, $zero, 48($c11) # 16-byte Folded Spill
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    cincoffset $c2, $c11, 8
; ASM-NEXT:    csetbounds $c18, $c2, 40
; ASM-NEXT:    clcbi $c12, %capcall20(use)($c1)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    cmove $c3, $c18
; ASM-NEXT:    clw $2, $zero, 20($c18)
; ASM-NEXT:    clc $c17, $zero, 48($c11) # 16-byte Folded Reload
; ASM-NEXT:    clc $c18, $zero, 64($c11) # 16-byte Folded Reload
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 80
; CHECK-LABEL: define signext i32 @stack_array
; CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    [[ARRAY:%.*]] = alloca [10 x i32], align 4, addrspace(200)
; CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 40, ptr addrspace(200) nonnull [[ARRAY]])
; CHECK-NEXT:    [[BOUNDED:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[ARRAY]], i64 40)
; CHECK-NEXT:    call void @use(ptr addrspace(200) [[BOUNDED]])
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[BOUNDED]], i64 20
; CHECK-NEXT:    [[LD:%.*]] = load i32, ptr addrspace(200) [[ARRAYIDX]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p200(i64 40, ptr addrspace(200) nonnull [[ARRAY]])
; CHECK-NEXT:    ret i32 [[LD]]
;
  %array = alloca [10 x i32], align 4, addrspace(200)
  call void @llvm.lifetime.start.p200(i64 40, ptr addrspace(200) nonnull %array)
  %bounded = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %array, i64 40)
  call void @use(ptr addrspace(200) %bounded)
  %arrayidx = getelementptr inbounds i8, ptr addrspace(200) %bounded, i64 20
  %ld = load i32, ptr addrspace(200) %arrayidx, align 4
  call void @llvm.lifetime.end.p200(i64 40, ptr addrspace(200) nonnull %array)
  ret i32 %ld
}

; DBG-LABEL: Checking function stack_array
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.end.p200(i64 40, ptr addrspace(200) nonnull %array)
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for use in setbounds with smaller or equal size: original size=40, setbounds size=40 current offset=0:  %bounded = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %array, i64 40)
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200(i64 40, ptr addrspace(200) nonnull %array)
; DBG-NEXT: cheri-bound-allocas: stack_array: 0 of 3 users need bounds for   %array = alloca [10 x i32], align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %array = alloca [10 x i32], align 4, addrspace(200)
; DBG-EMPTY:

declare void @llvm.lifetime.start.p200(i64 immarg, ptr addrspace(200) nocapture) addrspace(200)

declare void @use(ptr addrspace(200)) local_unnamed_addr addrspace(200)

declare ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200), i64) addrspace(200)

declare void @llvm.lifetime.end.p200(i64 immarg, ptr addrspace(200) nocapture) addrspace(200)

define signext i32 @stack_int() local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: stack_int:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -32
; ASM-NEXT:    csc $c17, $zero, 16($c11) # 16-byte Folded Spill
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    addiu $1, $zero, 1
; ASM-NEXT:    csw $1, $zero, 12($c11)
; ASM-NEXT:    cincoffset $c2, $c11, 12
; ASM-NEXT:    clcbi $c12, %capcall20(use)($c1)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    csetbounds $c3, $c2, 4
; ASM-NEXT:    clw $2, $zero, 12($c11)
; ASM-NEXT:    clc $c17, $zero, 16($c11) # 16-byte Folded Reload
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 32
; CHECK-LABEL: define signext i32 @stack_int
; CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:    [[VALUE:%.*]] = alloca i32, align 4, addrspace(200)
; CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 4, ptr addrspace(200) nonnull [[VALUE]])
; CHECK-NEXT:    store i32 1, ptr addrspace(200) [[VALUE]], align 4
; CHECK-NEXT:    [[BOUNDED:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[VALUE]], i64 4)
; CHECK-NEXT:    call void @use(ptr addrspace(200) [[BOUNDED]])
; CHECK-NEXT:    [[LD:%.*]] = load i32, ptr addrspace(200) [[VALUE]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p200(i64 4, ptr addrspace(200) nonnull [[VALUE]])
; CHECK-NEXT:    ret i32 [[LD]]
;
  %value = alloca i32, align 4, addrspace(200)
  call void @llvm.lifetime.start.p200(i64 4, ptr addrspace(200) nonnull %value)
  store i32 1, ptr addrspace(200) %value, align 4
  %bounded = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %value, i64 4)
  call void @use(ptr addrspace(200) %bounded)
  %ld = load i32, ptr addrspace(200) %value, align 4
  call void @llvm.lifetime.end.p200(i64 4, ptr addrspace(200) nonnull %value)
  ret i32 %ld
}

; DBG-LABEL: Checking function stack_int
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.end.p200(i64 4, ptr addrspace(200) nonnull %value)
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %ld = load i32, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %ld = load i32, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for use in setbounds with smaller or equal size: original size=4, setbounds size=4 current offset=0:  %bounded = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %value, i64 4)
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store i32 1, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   store i32 1, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200(i64 4, ptr addrspace(200) nonnull %value)
; DBG-NEXT: cheri-bound-allocas: stack_int: 0 of 5 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

define signext i32 @stack_int_inlined() local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: stack_int_inlined:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -16
; ASM-NEXT:    addiu $1, $zero, 1
; ASM-NEXT:    csw $1, $zero, 12($c11)
; ASM-NEXT:    cincoffset $c1, $c11, 12
; ASM-NEXT:    csetbounds $c1, $c1, 4
; ASM-NEXT:    addiu $1, $zero, 2
; ASM-NEXT:    csw $1, $zero, 0($c1)
; ASM-NEXT:    clw $2, $zero, 12($c11)
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 16
; CHECK-LABEL: define signext i32 @stack_int_inlined
; CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:    [[VALUE:%.*]] = alloca i32, align 4, addrspace(200)
; CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 4, ptr addrspace(200) nonnull [[VALUE]])
; CHECK-NEXT:    store i32 1, ptr addrspace(200) [[VALUE]], align 4
; CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[VALUE]], i64 4)
; CHECK-NEXT:    store i32 2, ptr addrspace(200) [[ADDRESS_WITH_BOUNDS]], align 4
; CHECK-NEXT:    [[LD:%.*]] = load i32, ptr addrspace(200) [[VALUE]], align 4
; CHECK-NEXT:    call void @llvm.lifetime.end.p200(i64 4, ptr addrspace(200) nonnull [[VALUE]])
; CHECK-NEXT:    ret i32 [[LD]]
;
  %value = alloca i32, align 4, addrspace(200)
  call void @llvm.lifetime.start.p200(i64 4, ptr addrspace(200) nonnull %value)
  store i32 1, ptr addrspace(200) %value, align 4
  %address.with.bounds = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %value, i64 4)
  store i32 2, ptr addrspace(200) %address.with.bounds, align 4
  %ld = load i32, ptr addrspace(200) %value, align 4
  call void @llvm.lifetime.end.p200(i64 4, ptr addrspace(200) nonnull %value)
  ret i32 %ld
}

; DBG-LABEL: Checking function stack_int_inlined
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.end.p200(i64 4, ptr addrspace(200) nonnull %value)
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %ld = load i32, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %ld = load i32, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for use in setbounds with smaller or equal size: original size=4, setbounds size=4 current offset=0:  %address.with.bounds = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %value, i64 4)
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store i32 1, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   store i32 1, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200(i64 4, ptr addrspace(200) nonnull %value)
; DBG-NEXT: cheri-bound-allocas: stack_int_inlined: 0 of 5 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

define signext i32 @out_of_bounds_setbounds() local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: out_of_bounds_setbounds:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -16
; ASM-NEXT:    cincoffset $c1, $c11, 12
; ASM-NEXT:    csetbounds $c1, $c1, 4
; ASM-NEXT:    csetbounds $c1, $c1, 5
; ASM-NEXT:    addiu $1, $zero, 2
; ASM-NEXT:    csw $1, $zero, 0($c1)
; ASM-NEXT:    clw $2, $zero, 12($c11)
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 16
; CHECK-LABEL: define signext i32 @out_of_bounds_setbounds
; CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:    [[VALUE:%.*]] = alloca i32, align 4, addrspace(200)
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[VALUE]], i64 4)
; CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[TMP1]], i64 5)
; CHECK-NEXT:    store i32 2, ptr addrspace(200) [[ADDRESS_WITH_BOUNDS]], align 4
; CHECK-NEXT:    [[LD:%.*]] = load i32, ptr addrspace(200) [[VALUE]], align 4
; CHECK-NEXT:    ret i32 [[LD]]
;
  %value = alloca i32, align 4, addrspace(200)
  ; TOO big, cannot elide the setbonds:
  %address.with.bounds = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %value, i64 5)
  store i32 2, ptr addrspace(200) %address.with.bounds, align 4
  %ld = load i32, ptr addrspace(200) %value, align 4
  ret i32 %ld
}

; DBG-NEXT: Checking function out_of_bounds_setbounds
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %ld = load i32, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %ld = load i32, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -out_of_bounds_setbounds: setbounds use offset OUT OF BOUNDS and will trap -> adding csetbounds:   %address.with.bounds = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %value, i64 5)
; DBG-NEXT: cheri-bound-allocas: Found alloca use that needs bounds:   %address.with.bounds = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %value, i64 5)
; DBG-NEXT: cheri-bound-allocas: out_of_bounds_setbounds: 1 of 2 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: out_of_bounds_setbounds: setting bounds on stack alloca to 4  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

define signext i32 @setbounds_escapes() local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: setbounds_escapes:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -32
; ASM-NEXT:    csc $c17, $zero, 16($c11) # 16-byte Folded Spill
; ASM-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; ASM-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; ASM-NEXT:    cgetpccincoffset $c1, $1
; ASM-NEXT:    cincoffset $c2, $c11, 12
; ASM-NEXT:    csetbounds $c3, $c2, 4
; ASM-NEXT:    addiu $1, $zero, 2
; ASM-NEXT:    csw $1, $zero, 0($c3)
; ASM-NEXT:    clcbi $c12, %capcall20(use)($c1)
; ASM-NEXT:    cjalr $c12, $c17
; ASM-NEXT:    nop
; ASM-NEXT:    clw $2, $zero, 12($c11)
; ASM-NEXT:    clc $c17, $zero, 16($c11) # 16-byte Folded Reload
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 32
; CHECK-LABEL: define signext i32 @setbounds_escapes
; CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:    [[VALUE:%.*]] = alloca i32, align 4, addrspace(200)
; CHECK-NEXT:    [[ADDRESS_WITH_BOUNDS:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[VALUE]], i64 4)
; CHECK-NEXT:    store i32 2, ptr addrspace(200) [[ADDRESS_WITH_BOUNDS]], align 4
; CHECK-NEXT:    call void @use(ptr addrspace(200) [[ADDRESS_WITH_BOUNDS]])
; CHECK-NEXT:    [[LD:%.*]] = load i32, ptr addrspace(200) [[VALUE]], align 4
; CHECK-NEXT:    ret i32 [[LD]]
;
  %value = alloca i32, align 4, addrspace(200)
  ; Too big, cannot elide the setbonds:
  %address.with.bounds = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %value, i64 4)
  store i32 2, ptr addrspace(200) %address.with.bounds, align 4
  call void @use(ptr addrspace(200) %address.with.bounds)
  %ld = load i32, ptr addrspace(200) %value, align 4
  ret i32 %ld
}

; DBG-NEXT: Checking function setbounds_escapes
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %ld = load i32, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %ld = load i32, ptr addrspace(200) %value, align 4
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for use in setbounds with smaller or equal size: original size=4, setbounds size=4 current offset=0:  %address.with.bounds = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull %value, i64 4)
; DBG-NEXT: cheri-bound-allocas: setbounds_escapes: 0 of 2 users need bounds for   %value = alloca i32, align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %value = alloca i32, align 4, addrspace(200)
; DBG-EMPTY:

; llvm.assume() should not add bounds:
define void @assume_aligned() local_unnamed_addr addrspace(200) nounwind {
; ASM-LABEL: assume_aligned:
; ASM:       # %bb.0:
; ASM-NEXT:    cincoffset $c11, $c11, -16
; ASM-NEXT:    addiu $1, $zero, 1
; ASM-NEXT:    csw $1, $zero, 12($c11)
; ASM-NEXT:    cjr $c17
; ASM-NEXT:    cincoffset $c11, $c11, 16
; CHECK-LABEL: define void @assume_aligned
; CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:    [[TMP1:%.*]] = alloca [4 x i8], align 4, addrspace(200)
; CHECK-NEXT:    call void @llvm.assume(i1 true) [ "align"(ptr addrspace(200) [[TMP1]], i64 4) ]
; CHECK-NEXT:    store i32 1, ptr addrspace(200) [[TMP1]], align 4
; CHECK-NEXT:    ret void
;
  %1 = alloca [4 x i8], align 4, addrspace(200)
  call void @llvm.assume(i1 true) [ "align"([4 x i8] addrspace(200)* %1, i64 4) ]
  store i32 1, ptr addrspace(200) %1
  ret void
}

; DBG-NEXT: Checking function assume_aligned
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store i32 1, ptr addrspace(200) %1, align 4
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=4, alloca size=4, current GEP offset=0 for i32
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   store i32 1, ptr addrspace(200) %1, align 4
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for assume:   call void @llvm.assume(i1 true) [ "align"(ptr addrspace(200) %1, i64 4) ]
; DBG-NEXT: cheri-bound-allocas: assume_aligned: 0 of 2 users need bounds for   %1 = alloca [4 x i8], align 4, addrspace(200)
; DBG-NEXT: cheri-bound-allocas: No need to set bounds on stack alloca  %1 = alloca [4 x i8], align 4, addrspace(200)
; DBG-EMPTY:

declare void @llvm.assume(i1) addrspace(200)
