; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/stack-spill-unnecessary.c.ll
; The new CheriBoundedStackPseudo instruction lets us pretend that the incoffset+csetbounds
; is a single trivially rematerizable instruction so it can freely move it around to avoid stack spills.
; Previously we were moving the allocation of the register that is only used later to the beginning of
; the function and saving+restoring it instead of materializing it just before

; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -O2 --cheri-stack-bounds-single-intrinsic-threshold=0 < %s | %cheri_FileCheck %s --check-prefixes=CHECK
; Always use a single intrinsic for the calls (should result in same codegen)
; RUN: llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi purecap -O2 --cheri-stack-bounds-single-intrinsic-threshold=0 < %s | %cheri_FileCheck %s --check-prefixes=CHECK
; RUN: sed 's/addrspace(200)/addrspace(0)/g' %s | llc -mtriple=mips64 -mcpu=cheri128 -mattr=+cheri128 --relocation-model=pic -target-abi n64 | FileCheck --check-prefix HYBRID %s


declare void @foo() addrspace(200)
declare void @one_arg(i32 addrspace(200)*) addrspace(200)
declare void @multi_arg(i32 addrspace(200)* %start, i32 addrspace(200)* %end, i8 addrspace(200)* %buf) addrspace(200)

define void @use_after_call() addrspace(200) nounwind {
; CHECK-LABEL: use_after_call:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -48
; CHECK-NEXT:    csc $c18, $zero, 32($c11) # 16-byte Folded Spill
; CHECK-NEXT:    csc $c17, $zero, 16($c11) # 16-byte Folded Spill
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c18, $1
; CHECK-NEXT:    addiu $1, $zero, 123
; CHECK-NEXT:    csw $1, $zero, 12($c11)
; CHECK-NEXT:    clcbi $c12, %capcall20(foo)($c18)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clcbi $c12, %capcall20(one_arg)($c18)
; CHECK-NEXT:    cincoffset $c3, $c11, 12
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 4
; CHECK-NEXT:    clc $c17, $zero, 16($c11) # 16-byte Folded Reload
; CHECK-NEXT:    clc $c18, $zero, 32($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 48
;
; HYBRID-LABEL: use_after_call:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    daddiu $sp, $sp, -32
; HYBRID-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(use_after_call)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(use_after_call)))
; HYBRID-NEXT:    addiu $1, $zero, 123
; HYBRID-NEXT:    sw $1, 12($sp)
; HYBRID-NEXT:    ld $25, %call16(foo)($gp)
; HYBRID-NEXT:    .reloc .Ltmp0, R_MIPS_JALR, foo
; HYBRID-NEXT:  .Ltmp0:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    ld $25, %call16(one_arg)($gp)
; HYBRID-NEXT:    .reloc .Ltmp1, R_MIPS_JALR, one_arg
; HYBRID-NEXT:  .Ltmp1:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    daddiu $4, $sp, 12
; HYBRID-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 32
entry:
  %x = alloca i32, align 4, addrspace(200)
  store i32 123, i32 addrspace(200)* %x, align 4
  call void @foo()
  call void @one_arg(i32 addrspace(200)* %x)
  ret void
}


define void @use_after_call_no_store() addrspace(200) nounwind {
; CHECK-LABEL: use_after_call_no_store:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -48
; CHECK-NEXT:    csc $c18, $zero, 32($c11) # 16-byte Folded Spill
; CHECK-NEXT:    csc $c17, $zero, 16($c11) # 16-byte Folded Spill
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c18, $1
; CHECK-NEXT:    clcbi $c12, %capcall20(foo)($c18)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    nop
; CHECK-NEXT:    clcbi $c12, %capcall20(one_arg)($c18)
; CHECK-NEXT:    cincoffset $c3, $c11, 12
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 4
; CHECK-NEXT:    clcbi $c12, %capcall20(one_arg)($c18)
; CHECK-NEXT:    cincoffset $c3, $c11, 8
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 4
; CHECK-NEXT:    clc $c17, $zero, 16($c11) # 16-byte Folded Reload
; CHECK-NEXT:    clc $c18, $zero, 32($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 48
;
; HYBRID-LABEL: use_after_call_no_store:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    daddiu $sp, $sp, -32
; HYBRID-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(use_after_call_no_store)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(use_after_call_no_store)))
; HYBRID-NEXT:    ld $25, %call16(foo)($gp)
; HYBRID-NEXT:    .reloc .Ltmp2, R_MIPS_JALR, foo
; HYBRID-NEXT:  .Ltmp2:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    ld $25, %call16(one_arg)($gp)
; HYBRID-NEXT:    .reloc .Ltmp3, R_MIPS_JALR, one_arg
; HYBRID-NEXT:  .Ltmp3:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    daddiu $4, $sp, 12
; HYBRID-NEXT:    ld $25, %call16(one_arg)($gp)
; HYBRID-NEXT:    .reloc .Ltmp4, R_MIPS_JALR, one_arg
; HYBRID-NEXT:  .Ltmp4:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    daddiu $4, $sp, 8
; HYBRID-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 32
entry:
  %x = alloca i32, align 4, addrspace(200)
  %y = alloca i32, align 4, addrspace(200)
  call void @foo()
  call void @one_arg(i32 addrspace(200)* %x)
  call void @one_arg(i32 addrspace(200)* %y)
  ret void
}

define void @multi_use() addrspace(200) nounwind {
; CHECK-LABEL: multi_use:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset $c11, $c11, -64
; CHECK-NEXT:    csc $c19, $zero, 48($c11) # 16-byte Folded Spill
; CHECK-NEXT:    csc $c18, $zero, 32($c11) # 16-byte Folded Spill
; CHECK-NEXT:    csc $c17, $zero, 16($c11) # 16-byte Folded Spill
; CHECK-NEXT:    lui $1, %pcrel_hi(_CHERI_CAPABILITY_TABLE_-8)
; CHECK-NEXT:    daddiu $1, $1, %pcrel_lo(_CHERI_CAPABILITY_TABLE_-4)
; CHECK-NEXT:    cgetpccincoffset $c18, $1
; CHECK-NEXT:    cincoffset $c19, $c11, 8
; CHECK-NEXT:    clcbi $c12, %capcall20(foo)($c18)
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c19, $c19, 4
; CHECK-NEXT:    cincoffset $c4, $c19, 4
; CHECK-NEXT:    cincoffset $c5, $c19, 1
; CHECK-NEXT:    clcbi $c12, %capcall20(multi_arg)($c18)
; CHECK-NEXT:    cincoffset $c3, $c11, 8
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 4
; CHECK-NEXT:    clcbi $c12, %capcall20(one_arg)($c18)
; CHECK-NEXT:    cincoffset $c3, $c11, 12
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 4
; CHECK-NEXT:    clcbi $c12, %capcall20(one_arg)($c18)
; CHECK-NEXT:    cincoffset $c3, $c11, 8
; CHECK-NEXT:    cjalr $c12, $c17
; CHECK-NEXT:    csetbounds $c3, $c3, 4
; CHECK-NEXT:    clc $c17, $zero, 16($c11) # 16-byte Folded Reload
; CHECK-NEXT:    clc $c18, $zero, 32($c11) # 16-byte Folded Reload
; CHECK-NEXT:    clc $c19, $zero, 48($c11) # 16-byte Folded Reload
; CHECK-NEXT:    cjr $c17
; CHECK-NEXT:    cincoffset $c11, $c11, 64
;
; HYBRID-LABEL: multi_use:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    daddiu $sp, $sp, -32
; HYBRID-NEXT:    sd $ra, 24($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $gp, 16($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    sd $16, 8($sp) # 8-byte Folded Spill
; HYBRID-NEXT:    lui $1, %hi(%neg(%gp_rel(multi_use)))
; HYBRID-NEXT:    daddu $1, $1, $25
; HYBRID-NEXT:    daddiu $gp, $1, %lo(%neg(%gp_rel(multi_use)))
; HYBRID-NEXT:    ld $25, %call16(foo)($gp)
; HYBRID-NEXT:    .reloc .Ltmp5, R_MIPS_JALR, foo
; HYBRID-NEXT:  .Ltmp5:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    nop
; HYBRID-NEXT:    daddiu $16, $sp, 0
; HYBRID-NEXT:    daddiu $5, $16, 4
; HYBRID-NEXT:    ori $6, $16, 1
; HYBRID-NEXT:    ld $25, %call16(multi_arg)($gp)
; HYBRID-NEXT:    .reloc .Ltmp6, R_MIPS_JALR, multi_arg
; HYBRID-NEXT:  .Ltmp6:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    move $4, $16
; HYBRID-NEXT:    ld $25, %call16(one_arg)($gp)
; HYBRID-NEXT:    .reloc .Ltmp7, R_MIPS_JALR, one_arg
; HYBRID-NEXT:  .Ltmp7:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    daddiu $4, $sp, 4
; HYBRID-NEXT:    ld $25, %call16(one_arg)($gp)
; HYBRID-NEXT:    .reloc .Ltmp8, R_MIPS_JALR, one_arg
; HYBRID-NEXT:  .Ltmp8:
; HYBRID-NEXT:    jalr $25
; HYBRID-NEXT:    move $4, $16
; HYBRID-NEXT:    ld $16, 8($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $gp, 16($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    ld $ra, 24($sp) # 8-byte Folded Reload
; HYBRID-NEXT:    jr $ra
; HYBRID-NEXT:    daddiu $sp, $sp, 32
entry:
  %y = alloca i32, align 4, addrspace(200)
  %x = alloca i32, align 4, addrspace(200)
  call void @foo()
  %x_plus0 = getelementptr inbounds i32, i32 addrspace(200)* %x, i32 0
  %x_plus1 = getelementptr i32, i32 addrspace(200)* %x, i32 1
  %x_i8 = bitcast i32 addrspace(200)* %x to i8 addrspace(200)*
  %x_i8_plus_1 = getelementptr inbounds i8, i8 addrspace(200)* %x_i8, i32 1
  call void @multi_arg(i32 addrspace(200)* %x_plus0, i32 addrspace(200)* %x_plus1, i8 addrspace(200)* %x_i8_plus_1)
  call void @one_arg(i32 addrspace(200)* %y)
  call void @one_arg(i32 addrspace(200)* %x)
  ret void
}
