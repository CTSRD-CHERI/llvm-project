; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/c11-atomic-caps-hybrid.ll
; RUN: %cheri128_llc %s -o - | FileCheck %s
; target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128"

; Function Attrs: nofree norecurse nounwind
define i8 addrspace(200)* @test_load(i8 addrspace(200)** nocapture readonly %f) local_unnamed_addr #0 {
; CHECK-LABEL: test_load:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    clc $c3, $4, 0($ddc)
; CHECK-NEXT:    sync
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    nop
entry:
  %0 = load atomic i8 addrspace(200)*, i8 addrspace(200)** %f seq_cst, align 16
  ret i8 addrspace(200)* %0
}

; Function Attrs: nofree norecurse nounwind
define void @test_store(i8 addrspace(200)** nocapture %f, i8 addrspace(200)* %value) local_unnamed_addr #0 {
; CHECK-LABEL: test_store:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    csc $c3, $4, 0($ddc)
; CHECK-NEXT:    sync
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    nop
entry:
  store atomic i8 addrspace(200)* %value, i8 addrspace(200)** %f seq_cst, align 16
  ret void
}

; Function Attrs: nofree norecurse nounwind writeonly
define void @test_init(i8 addrspace(200)** nocapture %f, i8 addrspace(200)* %value) local_unnamed_addr #1 {
; CHECK-LABEL: test_init:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    csc $c3, $4, 0($ddc)
entry:
  store i8 addrspace(200)* %value, i8 addrspace(200)** %f, align 16
  ret void
}

; Function Attrs: nofree norecurse nounwind
define i8 addrspace(200)* @test_xchg(i8 addrspace(200)** nocapture %f, i8 addrspace(200)* %value) local_unnamed_addr #0 {
; CHECK-LABEL: test_xchg:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cfromddc $c2, $4
; CHECK-NEXT:  .LBB3_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c2
; CHECK-NEXT:    cscc $1, $c3, $c2
; CHECK-NEXT:    beqz $1, .LBB3_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    cmove $c3, $c1
entry:
  %0 = atomicrmw xchg i8 addrspace(200)** %f, i8 addrspace(200)* %value seq_cst
  ret i8 addrspace(200)* %0
}

; Function Attrs: nofree norecurse nounwind
define i64 addrspace(200)* @test_xchg_long_ptr(i64 addrspace(200)** nocapture %f, i64 addrspace(200)* %value) local_unnamed_addr #0 {
; CHECK-LABEL: test_xchg_long_ptr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    cfromddc $c2, $4
; CHECK-NEXT:  .LBB4_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c2
; CHECK-NEXT:    cscc $1, $c3, $c2
; CHECK-NEXT:    beqz $1, .LBB4_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    sync
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    cmove $c3, $c1
entry:
  %0 = bitcast i64 addrspace(200)** %f to i8 addrspace(200)**
  %1 = bitcast i64 addrspace(200)* %value to i8 addrspace(200)*
  %2 = atomicrmw xchg i8 addrspace(200)** %0, i8 addrspace(200)* %1 seq_cst
  %3 = bitcast i8 addrspace(200)* %2 to i64 addrspace(200)*
  ret i64 addrspace(200)* %3
}

; Function Attrs: nofree norecurse nounwind
define zeroext i1 @test_cmpxchg_weak(i8 addrspace(200)** nocapture %f, i8 addrspace(200)** nocapture %exp, i8 addrspace(200)* %new) local_unnamed_addr #0 {
; CHECK-LABEL: test_cmpxchg_weak:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    clc $c2, $5, 0($ddc)
; CHECK-NEXT:    cfromddc $c4, $4
; CHECK-NEXT:  .LBB5_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c4
; CHECK-NEXT:    ceq $1, $c1, $c2
; CHECK-NEXT:    beqz $1, .LBB5_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB5_1 Depth=1
; CHECK-NEXT:    cscc $1, $c3, $c4
; CHECK-NEXT:    beqz $1, .LBB5_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB5_3: # %entry
; CHECK-NEXT:    ceq $2, $c1, $c2
; CHECK-NEXT:    bnez $2, .LBB5_5
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.4: # %cmpxchg.store_expected
; CHECK-NEXT:    csc $c1, $5, 0($ddc)
; CHECK-NEXT:  .LBB5_5: # %cmpxchg.continue
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    nop
entry:
  %0 = load i8 addrspace(200)*, i8 addrspace(200)** %exp, align 16
  %1 = cmpxchg weak i8 addrspace(200)** %f, i8 addrspace(200)* %0, i8 addrspace(200)* %new monotonic monotonic
  %2 = extractvalue { i8 addrspace(200)*, i1 } %1, 1
  br i1 %2, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %entry
  %3 = extractvalue { i8 addrspace(200)*, i1 } %1, 0
  store i8 addrspace(200)* %3, i8 addrspace(200)** %exp, align 16
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %entry
  ret i1 %2
}

; Function Attrs: nofree norecurse nounwind
define zeroext i1 @test_cmpxchg_strong(i8 addrspace(200)** nocapture %f, i8 addrspace(200)** nocapture %exp, i8 addrspace(200)* %new) local_unnamed_addr #0 {
; CHECK-LABEL: test_cmpxchg_strong:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    clc $c2, $5, 0($ddc)
; CHECK-NEXT:    cfromddc $c4, $4
; CHECK-NEXT:  .LBB6_1: # %entry
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cllc $c1, $c4
; CHECK-NEXT:    ceq $1, $c1, $c2
; CHECK-NEXT:    beqz $1, .LBB6_3
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %entry
; CHECK-NEXT:    # in Loop: Header=BB6_1 Depth=1
; CHECK-NEXT:    cscc $1, $c3, $c4
; CHECK-NEXT:    beqz $1, .LBB6_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  .LBB6_3: # %entry
; CHECK-NEXT:    ceq $2, $c1, $c2
; CHECK-NEXT:    bnez $2, .LBB6_5
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.4: # %cmpxchg.store_expected
; CHECK-NEXT:    csc $c1, $5, 0($ddc)
; CHECK-NEXT:  .LBB6_5: # %cmpxchg.continue
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    nop
entry:
  %0 = load i8 addrspace(200)*, i8 addrspace(200)** %exp, align 16
  %1 = cmpxchg i8 addrspace(200)** %f, i8 addrspace(200)* %0, i8 addrspace(200)* %new monotonic monotonic
  %2 = extractvalue { i8 addrspace(200)*, i1 } %1, 1
  br i1 %2, label %cmpxchg.continue, label %cmpxchg.store_expected

cmpxchg.store_expected:                           ; preds = %entry
  %3 = extractvalue { i8 addrspace(200)*, i1 } %1, 0
  store i8 addrspace(200)* %3, i8 addrspace(200)** %exp, align 16
  br label %cmpxchg.continue

cmpxchg.continue:                                 ; preds = %cmpxchg.store_expected, %entry
  ret i1 %2
}

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_add_uintcap(i8 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_add_uintcap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    jal __atomic_fetch_add_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_add_cap(i8* %0, i8 addrspace(200)* %value, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

declare i8 addrspace(200)* @__atomic_fetch_add_cap(i8*, i8 addrspace(200)*, i32) local_unnamed_addr

; Function Attrs: nounwind
define i64 addrspace(200)* @test_fetch_add_longptr(i64 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_add_longptr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    cgetaddr $1, $c3
; CHECK-NEXT:    dsll $1, $1, 3
; CHECK-NEXT:    cincoffset $c3, $cnull, $1
; CHECK-NEXT:    jal __atomic_fetch_add_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %value)
  %1 = shl i64 %0, 3
  %2 = getelementptr i8, i8 addrspace(200)* null, i64 %1
  %3 = bitcast i64 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_add_cap(i8* %3, i8 addrspace(200)* %2, i32 signext 5) #4
  %4 = bitcast i8 addrspace(200)* %call to i64 addrspace(200)*
  ret i64 addrspace(200)* %4
}

; Function Attrs: nounwind readnone willreturn
declare i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)*) #3

; Function Attrs: nounwind
define i64 addrspace(200)* @test_fetch_add_longptr_and_short(i64 addrspace(200)** %ptr, i16 signext %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_add_longptr_and_short:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    dsll $1, $5, 3
; CHECK-NEXT:    cincoffset $c3, $cnull, $1
; CHECK-NEXT:    jal __atomic_fetch_add_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %conv = sext i16 %value to i64
  %0 = shl nsw i64 %conv, 3
  %1 = getelementptr i8, i8 addrspace(200)* null, i64 %0
  %2 = bitcast i64 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_add_cap(i8* %2, i8 addrspace(200)* %1, i32 signext 5) #4
  %3 = bitcast i8 addrspace(200)* %call to i64 addrspace(200)*
  ret i64 addrspace(200)* %3
}

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_add_charptr(i8 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_add_charptr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    cgetaddr $1, $c3
; CHECK-NEXT:    cincoffset $c3, $cnull, $1
; CHECK-NEXT:    jal __atomic_fetch_add_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %value)
  %1 = getelementptr i8, i8 addrspace(200)* null, i64 %0
  %2 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_add_cap(i8* %2, i8 addrspace(200)* %1, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_add_charptr_and_short(i8 addrspace(200)** %ptr, i16 signext %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_add_charptr_and_short:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    cincoffset $c3, $cnull, $5
; CHECK-NEXT:    jal __atomic_fetch_add_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %conv = sext i16 %value to i64
  %0 = getelementptr i8, i8 addrspace(200)* null, i64 %conv
  %1 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_add_cap(i8* %1, i8 addrspace(200)* %0, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_sub_uintcap(i8 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_sub_uintcap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    jal __atomic_fetch_sub_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_sub_cap(i8* %0, i8 addrspace(200)* %value, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

declare i8 addrspace(200)* @__atomic_fetch_sub_cap(i8*, i8 addrspace(200)*, i32) local_unnamed_addr

; Function Attrs: nounwind
define i64 addrspace(200)* @test_fetch_sub_longptr(i64 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_sub_longptr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    cgetaddr $1, $c3
; CHECK-NEXT:    dsll $1, $1, 3
; CHECK-NEXT:    cincoffset $c3, $cnull, $1
; CHECK-NEXT:    jal __atomic_fetch_sub_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %value)
  %1 = shl i64 %0, 3
  %2 = getelementptr i8, i8 addrspace(200)* null, i64 %1
  %3 = bitcast i64 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_sub_cap(i8* %3, i8 addrspace(200)* %2, i32 signext 5) #4
  %4 = bitcast i8 addrspace(200)* %call to i64 addrspace(200)*
  ret i64 addrspace(200)* %4
}

; Function Attrs: nounwind
define i64 addrspace(200)* @test_fetch_sub_longptr_and_short(i64 addrspace(200)** %ptr, i16 signext %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_sub_longptr_and_short:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    dsll $1, $5, 3
; CHECK-NEXT:    cincoffset $c3, $cnull, $1
; CHECK-NEXT:    jal __atomic_fetch_sub_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %conv = sext i16 %value to i64
  %0 = shl nsw i64 %conv, 3
  %1 = getelementptr i8, i8 addrspace(200)* null, i64 %0
  %2 = bitcast i64 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_sub_cap(i8* %2, i8 addrspace(200)* %1, i32 signext 5) #4
  %3 = bitcast i8 addrspace(200)* %call to i64 addrspace(200)*
  ret i64 addrspace(200)* %3
}

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_sub_charptr(i8 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_sub_charptr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    cgetaddr $1, $c3
; CHECK-NEXT:    cincoffset $c3, $cnull, $1
; CHECK-NEXT:    jal __atomic_fetch_sub_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %value)
  %1 = getelementptr i8, i8 addrspace(200)* null, i64 %0
  %2 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_sub_cap(i8* %2, i8 addrspace(200)* %1, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_sub_charptr_and_short(i8 addrspace(200)** %ptr, i16 signext %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_sub_charptr_and_short:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    cincoffset $c3, $cnull, $5
; CHECK-NEXT:    jal __atomic_fetch_sub_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %conv = sext i16 %value to i64
  %0 = getelementptr i8, i8 addrspace(200)* null, i64 %conv
  %1 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_sub_cap(i8* %1, i8 addrspace(200)* %0, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_and_uintcap(i8 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_and_uintcap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    jal __atomic_fetch_and_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_and_cap(i8* %0, i8 addrspace(200)* %value, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

declare i8 addrspace(200)* @__atomic_fetch_and_cap(i8*, i8 addrspace(200)*, i32) local_unnamed_addr

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_or_uintcap(i8 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_or_uintcap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    jal __atomic_fetch_or_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_or_cap(i8* %0, i8 addrspace(200)* %value, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

declare i8 addrspace(200)* @__atomic_fetch_or_cap(i8*, i8 addrspace(200)*, i32) local_unnamed_addr

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_xor_uintcap(i8 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_xor_uintcap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    jal __atomic_fetch_xor_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_xor_cap(i8* %0, i8 addrspace(200)* %value, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

declare i8 addrspace(200)* @__atomic_fetch_xor_cap(i8*, i8 addrspace(200)*, i32) local_unnamed_addr

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_max_uintcap(i8 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_max_uintcap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    jal __atomic_fetch_umax_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_umax_cap(i8* %0, i8 addrspace(200)* %value, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

declare i8 addrspace(200)* @__atomic_fetch_umax_cap(i8*, i8 addrspace(200)*, i32) local_unnamed_addr

; Function Attrs: nounwind
define i8 addrspace(200)* @test_fetch_min_uintcap(i8 addrspace(200)** %ptr, i8 addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-LABEL: test_fetch_min_uintcap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    .cfi_def_cfa_offset 16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    .cfi_offset 31, -8
; CHECK-NEXT:    jal __atomic_fetch_umin_cap
; CHECK-NEXT:    daddiu $5, $zero, 5
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %0 = bitcast i8 addrspace(200)** %ptr to i8*
  %call = call i8 addrspace(200)* @__atomic_fetch_umin_cap(i8* %0, i8 addrspace(200)* %value, i32 signext 5) #4
  ret i8 addrspace(200)* %call
}

declare i8 addrspace(200)* @__atomic_fetch_umin_cap(i8*, i8 addrspace(200)*, i32) local_unnamed_addr
