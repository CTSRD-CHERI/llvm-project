; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/atomic-rmw-cap-ptr-cap-arg.ll
; Check that we can generate sensible code for atomic operations using capability pointers on capabilities
; in both hybrid and purecap mode. For RISC-V this means expanding the instruction using the explicit
; addressing mode LR/SC instructions.
; See https://github.com/CTSRD-CHERI/llvm-project/issues/470
; RUN: %riscv64_cheri_purecap_llc %s -o - -mattr=+f,+a -verify-machineinstrs | FileCheck %s --check-prefixes=PURECAP,PURECAP-ATOMICS
; RUN: %riscv64_cheri_purecap_llc %s -o - -mattr=+f,-a -verify-machineinstrs | FileCheck %s --check-prefixes=PURECAP,PURECAP-LIBCALLS
; RUN: %riscv64_cheri_llc %s -o - -mattr=+f,+a -verify-machineinstrs | FileCheck %s --check-prefixes=HYBRID,HYBRID-ATOMICS
; RUN: %riscv64_cheri_llc %s -o - -mattr=+f,-a -verify-machineinstrs | FileCheck %s --check-prefixes=HYBRID,HYBRID-LIBCALLS

define dso_local i8 addrspace(200)* @atomic_cap_ptr_xchg_sc(i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_cap_ptr_xchg_sc:
; PURECAP-ATOMICS:       # %bb.0: # %bb
; PURECAP-ATOMICS-NEXT:    camoswap.c.aqrl ca0, ca1, (ca0)
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_cap_ptr_xchg_sc:
; PURECAP-LIBCALLS:       # %bb.0: # %bb
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:  .LBB0_1: # %bb
; PURECAP-LIBCALLS-NEXT:    # Label of block must be emitted
; PURECAP-LIBCALLS-NEXT:    auipcc ca3, %captab_pcrel_hi(__atomic_exchange_cap)
; PURECAP-LIBCALLS-NEXT:    clc ca3, %pcrel_lo(.LBB0_1)(ca3)
; PURECAP-LIBCALLS-NEXT:    addi a2, zero, 5
; PURECAP-LIBCALLS-NEXT:    cjalr ca3
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_cap_ptr_xchg_sc:
; HYBRID-ATOMICS:       # %bb.0: # %bb
; HYBRID-ATOMICS-NEXT:    fence rw, rw
; HYBRID-ATOMICS-NEXT:  .LBB0_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    lr.c.cap ca2, (ca0)
; HYBRID-ATOMICS-NEXT:    cmove ca3, ca1
; HYBRID-ATOMICS-NEXT:    sc.c.cap ca3, (ca0)
; HYBRID-ATOMICS-NEXT:    bnez a3, .LBB0_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    fence r, rw
; HYBRID-ATOMICS-NEXT:    cmove ca0, ca2
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_cap_ptr_xchg_sc:
; HYBRID-LIBCALLS:       # %bb.0: # %bb
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi a2, zero, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_exchange_cap_c
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
bb:
  %tmp = atomicrmw xchg i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val seq_cst
  ret i8 addrspace(200)* %tmp
}

define dso_local i8 addrspace(200)* @atomic_cap_ptr_xchg_relaxed(i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_cap_ptr_xchg_relaxed:
; PURECAP-ATOMICS:       # %bb.0: # %bb
; PURECAP-ATOMICS-NEXT:    camoswap.c ca0, ca1, (ca0)
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_cap_ptr_xchg_relaxed:
; PURECAP-LIBCALLS:       # %bb.0: # %bb
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:  .LBB1_1: # %bb
; PURECAP-LIBCALLS-NEXT:    # Label of block must be emitted
; PURECAP-LIBCALLS-NEXT:    auipcc ca3, %captab_pcrel_hi(__atomic_exchange_cap)
; PURECAP-LIBCALLS-NEXT:    clc ca3, %pcrel_lo(.LBB1_1)(ca3)
; PURECAP-LIBCALLS-NEXT:    mv a2, zero
; PURECAP-LIBCALLS-NEXT:    cjalr ca3
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_cap_ptr_xchg_relaxed:
; HYBRID-ATOMICS:       # %bb.0: # %bb
; HYBRID-ATOMICS-NEXT:  .LBB1_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    lr.c.cap ca2, (ca0)
; HYBRID-ATOMICS-NEXT:    cmove ca3, ca1
; HYBRID-ATOMICS-NEXT:    sc.c.cap ca3, (ca0)
; HYBRID-ATOMICS-NEXT:    bnez a3, .LBB1_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    cmove ca0, ca2
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_cap_ptr_xchg_relaxed:
; HYBRID-LIBCALLS:       # %bb.0: # %bb
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    mv a2, zero
; HYBRID-LIBCALLS-NEXT:    call __atomic_exchange_cap_c
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
bb:
  %tmp = atomicrmw xchg i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val monotonic
  ret i8 addrspace(200)* %tmp
}

define dso_local i8 addrspace(200)* @atomic_cap_ptr_xchg_acquire(i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_cap_ptr_xchg_acquire:
; PURECAP-ATOMICS:       # %bb.0: # %bb
; PURECAP-ATOMICS-NEXT:    camoswap.c.aq ca0, ca1, (ca0)
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_cap_ptr_xchg_acquire:
; PURECAP-LIBCALLS:       # %bb.0: # %bb
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:  .LBB2_1: # %bb
; PURECAP-LIBCALLS-NEXT:    # Label of block must be emitted
; PURECAP-LIBCALLS-NEXT:    auipcc ca3, %captab_pcrel_hi(__atomic_exchange_cap)
; PURECAP-LIBCALLS-NEXT:    clc ca3, %pcrel_lo(.LBB2_1)(ca3)
; PURECAP-LIBCALLS-NEXT:    addi a2, zero, 2
; PURECAP-LIBCALLS-NEXT:    cjalr ca3
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_cap_ptr_xchg_acquire:
; HYBRID-ATOMICS:       # %bb.0: # %bb
; HYBRID-ATOMICS-NEXT:    cmove ca2, ca0
; HYBRID-ATOMICS-NEXT:  .LBB2_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    lr.c.cap ca0, (ca2)
; HYBRID-ATOMICS-NEXT:    cmove ca3, ca1
; HYBRID-ATOMICS-NEXT:    sc.c.cap ca3, (ca2)
; HYBRID-ATOMICS-NEXT:    bnez a3, .LBB2_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    fence r, rw
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_cap_ptr_xchg_acquire:
; HYBRID-LIBCALLS:       # %bb.0: # %bb
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi a2, zero, 2
; HYBRID-LIBCALLS-NEXT:    call __atomic_exchange_cap_c
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
bb:
  %tmp = atomicrmw xchg i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val acquire
  ret i8 addrspace(200)* %tmp
}

define dso_local i8 addrspace(200)* @atomic_cap_ptr_xchg_rel(i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_cap_ptr_xchg_rel:
; PURECAP-ATOMICS:       # %bb.0: # %bb
; PURECAP-ATOMICS-NEXT:    camoswap.c.rl ca0, ca1, (ca0)
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_cap_ptr_xchg_rel:
; PURECAP-LIBCALLS:       # %bb.0: # %bb
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:  .LBB3_1: # %bb
; PURECAP-LIBCALLS-NEXT:    # Label of block must be emitted
; PURECAP-LIBCALLS-NEXT:    auipcc ca3, %captab_pcrel_hi(__atomic_exchange_cap)
; PURECAP-LIBCALLS-NEXT:    clc ca3, %pcrel_lo(.LBB3_1)(ca3)
; PURECAP-LIBCALLS-NEXT:    addi a2, zero, 3
; PURECAP-LIBCALLS-NEXT:    cjalr ca3
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_cap_ptr_xchg_rel:
; HYBRID-ATOMICS:       # %bb.0: # %bb
; HYBRID-ATOMICS-NEXT:    fence rw, w
; HYBRID-ATOMICS-NEXT:  .LBB3_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    lr.c.cap ca2, (ca0)
; HYBRID-ATOMICS-NEXT:    cmove ca3, ca1
; HYBRID-ATOMICS-NEXT:    sc.c.cap ca3, (ca0)
; HYBRID-ATOMICS-NEXT:    bnez a3, .LBB3_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    cmove ca0, ca2
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_cap_ptr_xchg_rel:
; HYBRID-LIBCALLS:       # %bb.0: # %bb
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi a2, zero, 3
; HYBRID-LIBCALLS-NEXT:    call __atomic_exchange_cap_c
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
bb:
  %tmp = atomicrmw xchg i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val release
  ret i8 addrspace(200)* %tmp
}

define dso_local i8 addrspace(200)* @atomic_cap_ptr_xchg_acq_rel(i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_cap_ptr_xchg_acq_rel:
; PURECAP-ATOMICS:       # %bb.0: # %bb
; PURECAP-ATOMICS-NEXT:    camoswap.c.aqrl ca0, ca1, (ca0)
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_cap_ptr_xchg_acq_rel:
; PURECAP-LIBCALLS:       # %bb.0: # %bb
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:  .LBB4_1: # %bb
; PURECAP-LIBCALLS-NEXT:    # Label of block must be emitted
; PURECAP-LIBCALLS-NEXT:    auipcc ca3, %captab_pcrel_hi(__atomic_exchange_cap)
; PURECAP-LIBCALLS-NEXT:    clc ca3, %pcrel_lo(.LBB4_1)(ca3)
; PURECAP-LIBCALLS-NEXT:    addi a2, zero, 4
; PURECAP-LIBCALLS-NEXT:    cjalr ca3
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_cap_ptr_xchg_acq_rel:
; HYBRID-ATOMICS:       # %bb.0: # %bb
; HYBRID-ATOMICS-NEXT:    fence rw, w
; HYBRID-ATOMICS-NEXT:  .LBB4_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    lr.c.cap ca2, (ca0)
; HYBRID-ATOMICS-NEXT:    cmove ca3, ca1
; HYBRID-ATOMICS-NEXT:    sc.c.cap ca3, (ca0)
; HYBRID-ATOMICS-NEXT:    bnez a3, .LBB4_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    fence r, rw
; HYBRID-ATOMICS-NEXT:    cmove ca0, ca2
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_cap_ptr_xchg_acq_rel:
; HYBRID-LIBCALLS:       # %bb.0: # %bb
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi a2, zero, 4
; HYBRID-LIBCALLS-NEXT:    call __atomic_exchange_cap_c
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
bb:
  %tmp = atomicrmw xchg i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %val acq_rel
  ret i8 addrspace(200)* %tmp
}

; Also check non-i8* xchg:
define dso_local i32 addrspace(200)* @atomic_cap_ptr_xchg_i32ptr(i32 addrspace(200)* addrspace(200)* %ptr, i32 addrspace(200)* %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_cap_ptr_xchg_i32ptr:
; PURECAP-ATOMICS:       # %bb.0: # %bb
; PURECAP-ATOMICS-NEXT:    camoswap.c.aqrl ca0, ca1, (ca0)
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_cap_ptr_xchg_i32ptr:
; PURECAP-LIBCALLS:       # %bb.0: # %bb
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:  .LBB5_1: # %bb
; PURECAP-LIBCALLS-NEXT:    # Label of block must be emitted
; PURECAP-LIBCALLS-NEXT:    auipcc ca3, %captab_pcrel_hi(__atomic_exchange_cap)
; PURECAP-LIBCALLS-NEXT:    clc ca3, %pcrel_lo(.LBB5_1)(ca3)
; PURECAP-LIBCALLS-NEXT:    addi a2, zero, 4
; PURECAP-LIBCALLS-NEXT:    cjalr ca3
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp)
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_cap_ptr_xchg_i32ptr:
; HYBRID-ATOMICS:       # %bb.0: # %bb
; HYBRID-ATOMICS-NEXT:    fence rw, w
; HYBRID-ATOMICS-NEXT:  .LBB5_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    lr.c.cap ca2, (ca0)
; HYBRID-ATOMICS-NEXT:    cmove ca3, ca1
; HYBRID-ATOMICS-NEXT:    sc.c.cap ca3, (ca0)
; HYBRID-ATOMICS-NEXT:    bnez a3, .LBB5_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    fence r, rw
; HYBRID-ATOMICS-NEXT:    cmove ca0, ca2
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_cap_ptr_xchg_i32ptr:
; HYBRID-LIBCALLS:       # %bb.0: # %bb
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi a2, zero, 4
; HYBRID-LIBCALLS-NEXT:    call __atomic_exchange_cap_c
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp)
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
bb:
  %tmp = atomicrmw xchg i32 addrspace(200)* addrspace(200)* %ptr, i32 addrspace(200)* %val acq_rel
  ret i32 addrspace(200)* %tmp
}

; TODO: support all these:
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_add(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw add i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
;
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_sub(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw sub i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
;
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_and(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw and i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
;
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_nand(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw nand i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
;
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_or(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw or i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
;
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_xor(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw xor i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
;
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_max(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw max i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
;
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_min(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw min i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
;
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_umax(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw umax i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
;
; define dso_local i8 addrspace(200)* @atomic_cap_ptr_umin(i8 addrspace(200)* addrspace(200)* %ptr, i64 %val) nounwind {
; bb:
;   %tmp = atomicrmw umin i8 addrspace(200)* addrspace(200)* %ptr, i64 %val seq_cst
;   ret i8 addrspace(200)* %tmp
; }
