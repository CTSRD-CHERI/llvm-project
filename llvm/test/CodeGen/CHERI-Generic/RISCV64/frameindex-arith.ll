; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/frameindex-arith.ll
; RUN: llc -mtriple=riscv64 --relocation-model=pic -target-abi l64pc128d -mattr=+xcheri,+cap-mode,+f,+d %s -o - | FileCheck %s

; Check that we can fold the GEP (PTRADD) into the FrameIndex calculation
; rather than emitting two instructions.

; Contains an explicit @llvm.cheri.cap.bounds.set so CheriBoundAllocas sees the
; use as safe and doesn't interfere by inserting bounds on the FrameIndex
; before the GEP/PTRADD.
define void @foo() nounwind {
; CHECK-LABEL: foo:
; CHECK:       # %bb.0:
; CHECK-NEXT:    cincoffset csp, csp, -32
; CHECK-NEXT:    csc cra, 16(csp) # 16-byte Folded Spill
; CHECK-NEXT:    cincoffset ca0, csp, 14
; CHECK-NEXT:    cincoffset ca0, ca0, 1
; CHECK-NEXT:    csetbounds ca0, ca0, 0
; CHECK-NEXT:    ccall bar
; CHECK-NEXT:    clc cra, 16(csp) # 16-byte Folded Reload
; CHECK-NEXT:    cincoffset csp, csp, 32
; CHECK-NEXT:    cret
  %x = alloca [2 x i8], align 1, addrspace(200)
  %x_plus_1 = getelementptr inbounds [2 x i8], [2 x i8] addrspace(200)* %x, i64 0, i64 1
  %p = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* %x_plus_1, i64 0)
  call void @bar(i8 addrspace(200)* %p)
  ret void
}

declare void @bar(i8 addrspace(200)*)

declare i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)*, i64)
