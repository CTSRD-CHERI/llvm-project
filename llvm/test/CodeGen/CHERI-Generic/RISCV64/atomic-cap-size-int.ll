; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/atomic-cap-size-int.ll
;; Check that we can atomically update i128 (i64 for 32-bit systems)
;; For systems without double-width atomics (RISC-V, MIPS) we can use capability atomics
;; This is needed so we can report true for __atomic_always_lock_free(sizeof(uintptr_t), 0)
; RUN: opt -data-layout="e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200" -mtriple=riscv64 --relocation-model=pic -target-abi l64pc128d -mattr=+xcheri,+cap-mode,+f,+d -atomic-expand -S -mattr=+a < %s | FileCheck %s --check-prefix=PURECAP-IR
; RUN: opt -data-layout="e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128" -mtriple=riscv64 --relocation-model=pic -target-abi lp64d -mattr=+xcheri,+f,+d -atomic-expand -S -mattr=+a < %s | FileCheck %s --check-prefix=HYBRID-IR
; RUN: llc -mtriple=riscv64 --relocation-model=pic -target-abi l64pc128d -mattr=+xcheri,+cap-mode,+f,+d -mattr=+a < %s | FileCheck %s --check-prefixes=PURECAP,PURECAP-ATOMICS --allow-unused-prefixes
; RUN: llc -mtriple=riscv64 --relocation-model=pic -target-abi l64pc128d -mattr=+xcheri,+cap-mode,+f,+d -mattr=-a < %s | FileCheck %s --check-prefixes=PURECAP,PURECAP-LIBCALLS --allow-unused-prefixes
; RUN: sed 's/addrspace(200)/addrspace(0)/g' %s | llc -mtriple=riscv64 --relocation-model=pic -target-abi lp64d -mattr=+xcheri,+f,+d -mattr=+a | FileCheck %s --check-prefixes=HYBRID,HYBRID-ATOMICS --allow-unused-prefixes
; RUN: sed 's/addrspace(200)/addrspace(0)/g' %s | llc -mtriple=riscv64 --relocation-model=pic -target-abi lp64d -mattr=+xcheri,+f,+d -mattr=-a | FileCheck %s --check-prefixes=HYBRID,HYBRID-LIBCALLS --allow-unused-prefixes
; RUN: llc -mtriple=riscv64 --relocation-model=pic -target-abi lp64d -mattr=+xcheri,+f,+d -mattr=+a < %s | FileCheck %s --check-prefixes=HYBRID-CAP-PTR,HYBRID-CAP-PTR-ATOMICS --allow-unused-prefixes
; RUN: llc -mtriple=riscv64 --relocation-model=pic -target-abi lp64d -mattr=+xcheri,+f,+d -mattr=-a < %s | FileCheck %s --check-prefixes=HYBRID-CAP-PTR,HYBRID-CAP-PTR-LIBCALLS --allow-unused-prefixes

define i128 @store(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: store:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    fence rw, w
; PURECAP-ATOMICS-NEXT:    cincoffset ca3, cnull, a1
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca3, a2
; PURECAP-ATOMICS-NEXT:    csc ca3, 0(ca0)
; PURECAP-ATOMICS-NEXT:    mv a0, a1
; PURECAP-ATOMICS-NEXT:    mv a1, a2
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: store:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -48
; PURECAP-LIBCALLS-NEXT:    csc cra, 32(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs0, 16(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs1, 0(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    mv s0, a2
; PURECAP-LIBCALLS-NEXT:    mv s1, a1
; PURECAP-LIBCALLS-NEXT:    li a3, 5
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_store_16
; PURECAP-LIBCALLS-NEXT:    mv a0, s1
; PURECAP-LIBCALLS-NEXT:    mv a1, s0
; PURECAP-LIBCALLS-NEXT:    clc cra, 32(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs0, 16(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs1, 0(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 48
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: store:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    fence rw, w
; HYBRID-ATOMICS-NEXT:    cincoffset ca3, cnull, a1
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca3, a2
; HYBRID-ATOMICS-NEXT:    sc ca3, 0(a0)
; HYBRID-ATOMICS-NEXT:    mv a0, a1
; HYBRID-ATOMICS-NEXT:    mv a1, a2
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: store:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -32
; HYBRID-LIBCALLS-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    mv s0, a2
; HYBRID-LIBCALLS-NEXT:    mv s1, a1
; HYBRID-LIBCALLS-NEXT:    li a3, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_store_16@plt
; HYBRID-LIBCALLS-NEXT:    mv a0, s1
; HYBRID-LIBCALLS-NEXT:    mv a1, s0
; HYBRID-LIBCALLS-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 32
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: store:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -32
; HYBRID-CAP-PTR-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s1, 8(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    mv s0, a2
; HYBRID-CAP-PTR-NEXT:    mv s1, a1
; HYBRID-CAP-PTR-NEXT:    li a3, 5
; HYBRID-CAP-PTR-NEXT:    call __atomic_store_16_c@plt
; HYBRID-CAP-PTR-NEXT:    mv a0, s1
; HYBRID-CAP-PTR-NEXT:    mv a1, s0
; HYBRID-CAP-PTR-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s1, 8(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 32
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@store
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
; PURECAP-IR-NEXT:    fence release
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[VAL]]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = lshr i128 [[VAL]], 64
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = trunc i128 [[TMP2]] to i64
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP1]], i64 [[TMP3]])
; PURECAP-IR-NEXT:    store atomic ptr addrspace(200) [[TMP4]], ptr addrspace(200) [[PTR]] monotonic, align 16
; PURECAP-IR-NEXT:    ret i128 [[VAL]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@store
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0:[0-9]+]] {
; HYBRID-IR-NEXT:    call void @__atomic_store_16_c(ptr addrspace(200) [[PTR]], i128 [[VAL]], i32 5)
; HYBRID-IR-NEXT:    ret i128 [[VAL]]
;
  store atomic i128 %val, ptr addrspace(200) %ptr seq_cst, align 16
  ret i128 %val
}

define i128 @load(ptr addrspace(200) %ptr) nounwind {
; PURECAP-ATOMICS-LABEL: load:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    fence rw, rw
; PURECAP-ATOMICS-NEXT:    clc ca1, 0(ca0)
; PURECAP-ATOMICS-NEXT:    mv a0, a1
; PURECAP-ATOMICS-NEXT:    cgethigh a1, ca1
; PURECAP-ATOMICS-NEXT:    fence r, rw
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: load:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    li a1, 5
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_load_16
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: load:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    fence rw, rw
; HYBRID-ATOMICS-NEXT:    lc ca1, 0(a0)
; HYBRID-ATOMICS-NEXT:    mv a0, a1
; HYBRID-ATOMICS-NEXT:    cgethigh a1, ca1
; HYBRID-ATOMICS-NEXT:    fence r, rw
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: load:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    li a1, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_load_16@plt
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: load:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -16
; HYBRID-CAP-PTR-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    li a1, 5
; HYBRID-CAP-PTR-NEXT:    call __atomic_load_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 16
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@load
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    fence seq_cst
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load atomic ptr addrspace(200), ptr addrspace(200) [[PTR]] monotonic, align 16
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP1]])
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP1]])
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = zext i64 [[TMP2]] to i128
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = zext i64 [[TMP3]] to i128
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = shl i128 [[TMP5]], 64
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = or i128 [[TMP4]], [[TMP6]]
; PURECAP-IR-NEXT:    fence acquire
; PURECAP-IR-NEXT:    ret i128 [[TMP7]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@load
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = call i128 @__atomic_load_16_c(ptr addrspace(200) [[PTR]], i32 5)
; HYBRID-IR-NEXT:    ret i128 [[TMP1]]
;
  %val = load atomic i128, ptr addrspace(200) %ptr seq_cst, align 16
  ret i128 %val
}

define i128 @atomic_xchg(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_xchg:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:  .LBB2_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB2_3 Depth 2
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a1
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a2
; PURECAP-ATOMICS-NEXT:  .LBB2_3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB2_1 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB2_5
; PURECAP-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB2_3 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB2_3
; PURECAP-ATOMICS-NEXT:  .LBB2_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB2_1 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB2_1
; PURECAP-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_xchg:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    li a3, 5
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_exchange_16
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_xchg:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:  .LBB2_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB2_3 Depth 2
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a1
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a2
; HYBRID-ATOMICS-NEXT:  .LBB2_3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB2_1 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB2_5
; HYBRID-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB2_3 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB2_3
; HYBRID-ATOMICS-NEXT:  .LBB2_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB2_1 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB2_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_xchg:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    li a3, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_exchange_16@plt
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_xchg:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -16
; HYBRID-CAP-PTR-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    li a3, 5
; HYBRID-CAP-PTR-NEXT:    call __atomic_exchange_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 16
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_xchg
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = trunc i128 [[TMP3]] to i64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP2]], i64 [[TMP4]])
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[VAL]]
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = lshr i128 [[VAL]], 64
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = trunc i128 [[TMP7]] to i64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP6]], i64 [[TMP8]])
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP5]], ptr addrspace(200) [[TMP9]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 0
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 1
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = zext i64 [[TMP13]] to i128
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = shl i128 [[TMP16]], 64
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = or i128 [[TMP15]], [[TMP17]]
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP18]], 0
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } [[TMP19]], i1 [[TMP12]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP20]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP20]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_xchg
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = call i128 @__atomic_exchange_16_c(ptr addrspace(200) [[PTR]], i128 [[VAL]], i32 5)
; HYBRID-IR-NEXT:    ret i128 [[TMP1]]
;
  %tmp = atomicrmw xchg ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_add(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_add:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:  .LBB3_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB3_3 Depth 2
; PURECAP-ATOMICS-NEXT:    add a5, a4, a1
; PURECAP-ATOMICS-NEXT:    sltu a6, a5, a4
; PURECAP-ATOMICS-NEXT:    add a7, a3, a2
; PURECAP-ATOMICS-NEXT:    add a6, a7, a6
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a5
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a6
; PURECAP-ATOMICS-NEXT:  .LBB3_3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB3_1 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB3_5
; PURECAP-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB3_3 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB3_3
; PURECAP-ATOMICS-NEXT:  .LBB3_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB3_1 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB3_1
; PURECAP-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_add:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    li a3, 5
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_fetch_add_16
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_add:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:  .LBB3_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB3_3 Depth 2
; HYBRID-ATOMICS-NEXT:    add a5, a4, a1
; HYBRID-ATOMICS-NEXT:    sltu a6, a5, a4
; HYBRID-ATOMICS-NEXT:    add a7, a3, a2
; HYBRID-ATOMICS-NEXT:    add a6, a7, a6
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a5
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a6
; HYBRID-ATOMICS-NEXT:  .LBB3_3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB3_1 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB3_5
; HYBRID-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB3_3 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB3_3
; HYBRID-ATOMICS-NEXT:  .LBB3_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB3_1 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB3_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_add:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    li a3, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_fetch_add_16@plt
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_add:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -16
; HYBRID-CAP-PTR-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    li a3, 5
; HYBRID-CAP-PTR-NEXT:    call __atomic_fetch_add_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 16
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_add
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = add i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = trunc i128 [[TMP3]] to i64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP2]], i64 [[TMP4]])
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = trunc i128 [[TMP7]] to i64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP6]], i64 [[TMP8]])
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP5]], ptr addrspace(200) [[TMP9]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 0
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 1
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = zext i64 [[TMP13]] to i128
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = shl i128 [[TMP16]], 64
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = or i128 [[TMP15]], [[TMP17]]
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP18]], 0
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } [[TMP19]], i1 [[TMP12]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP20]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP20]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_add
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = call i128 @__atomic_fetch_add_16_c(ptr addrspace(200) [[PTR]], i128 [[VAL]], i32 5)
; HYBRID-IR-NEXT:    ret i128 [[TMP1]]
;
  %tmp = atomicrmw add ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_sub(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_sub:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:  .LBB4_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB4_3 Depth 2
; PURECAP-ATOMICS-NEXT:    sltu a5, a4, a1
; PURECAP-ATOMICS-NEXT:    sub a6, a3, a2
; PURECAP-ATOMICS-NEXT:    sub a5, a6, a5
; PURECAP-ATOMICS-NEXT:    sub a6, a4, a1
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a6
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; PURECAP-ATOMICS-NEXT:  .LBB4_3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB4_1 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB4_5
; PURECAP-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB4_3 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB4_3
; PURECAP-ATOMICS-NEXT:  .LBB4_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB4_1 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB4_1
; PURECAP-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_sub:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    li a3, 5
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_fetch_sub_16
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_sub:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:  .LBB4_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB4_3 Depth 2
; HYBRID-ATOMICS-NEXT:    sltu a5, a4, a1
; HYBRID-ATOMICS-NEXT:    sub a6, a3, a2
; HYBRID-ATOMICS-NEXT:    sub a5, a6, a5
; HYBRID-ATOMICS-NEXT:    sub a6, a4, a1
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a6
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; HYBRID-ATOMICS-NEXT:  .LBB4_3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB4_1 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB4_5
; HYBRID-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB4_3 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB4_3
; HYBRID-ATOMICS-NEXT:  .LBB4_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB4_1 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB4_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_sub:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    li a3, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_fetch_sub_16@plt
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_sub:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -16
; HYBRID-CAP-PTR-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    li a3, 5
; HYBRID-CAP-PTR-NEXT:    call __atomic_fetch_sub_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 16
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_sub
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = sub i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = trunc i128 [[TMP3]] to i64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP2]], i64 [[TMP4]])
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = trunc i128 [[TMP7]] to i64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP6]], i64 [[TMP8]])
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP5]], ptr addrspace(200) [[TMP9]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 0
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 1
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = zext i64 [[TMP13]] to i128
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = shl i128 [[TMP16]], 64
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = or i128 [[TMP15]], [[TMP17]]
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP18]], 0
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } [[TMP19]], i1 [[TMP12]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP20]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP20]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_sub
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = call i128 @__atomic_fetch_sub_16_c(ptr addrspace(200) [[PTR]], i128 [[VAL]], i32 5)
; HYBRID-IR-NEXT:    ret i128 [[TMP1]]
;
  %tmp = atomicrmw sub ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_and(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_and:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:  .LBB5_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB5_3 Depth 2
; PURECAP-ATOMICS-NEXT:    and a5, a3, a2
; PURECAP-ATOMICS-NEXT:    and a6, a4, a1
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a6
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; PURECAP-ATOMICS-NEXT:  .LBB5_3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB5_1 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB5_5
; PURECAP-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB5_3 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB5_3
; PURECAP-ATOMICS-NEXT:  .LBB5_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB5_1 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB5_1
; PURECAP-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_and:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    li a3, 5
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_fetch_and_16
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_and:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:  .LBB5_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB5_3 Depth 2
; HYBRID-ATOMICS-NEXT:    and a5, a3, a2
; HYBRID-ATOMICS-NEXT:    and a6, a4, a1
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a6
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; HYBRID-ATOMICS-NEXT:  .LBB5_3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB5_1 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB5_5
; HYBRID-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB5_3 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB5_3
; HYBRID-ATOMICS-NEXT:  .LBB5_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB5_1 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB5_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_and:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    li a3, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_fetch_and_16@plt
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_and:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -16
; HYBRID-CAP-PTR-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    li a3, 5
; HYBRID-CAP-PTR-NEXT:    call __atomic_fetch_and_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 16
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_and
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = and i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = trunc i128 [[TMP3]] to i64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP2]], i64 [[TMP4]])
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = trunc i128 [[TMP7]] to i64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP6]], i64 [[TMP8]])
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP5]], ptr addrspace(200) [[TMP9]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 0
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 1
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = zext i64 [[TMP13]] to i128
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = shl i128 [[TMP16]], 64
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = or i128 [[TMP15]], [[TMP17]]
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP18]], 0
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } [[TMP19]], i1 [[TMP12]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP20]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP20]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_and
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = call i128 @__atomic_fetch_and_16_c(ptr addrspace(200) [[PTR]], i128 [[VAL]], i32 5)
; HYBRID-IR-NEXT:    ret i128 [[TMP1]]
;
  %tmp = atomicrmw and ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_nand(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_nand:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:  .LBB6_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB6_3 Depth 2
; PURECAP-ATOMICS-NEXT:    and a5, a4, a1
; PURECAP-ATOMICS-NEXT:    and a6, a3, a2
; PURECAP-ATOMICS-NEXT:    not a6, a6
; PURECAP-ATOMICS-NEXT:    not a5, a5
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a5
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a6
; PURECAP-ATOMICS-NEXT:  .LBB6_3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB6_1 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB6_5
; PURECAP-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB6_3 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB6_3
; PURECAP-ATOMICS-NEXT:  .LBB6_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB6_1 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB6_1
; PURECAP-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_nand:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    li a3, 5
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_fetch_nand_16
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_nand:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:  .LBB6_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB6_3 Depth 2
; HYBRID-ATOMICS-NEXT:    and a5, a4, a1
; HYBRID-ATOMICS-NEXT:    and a6, a3, a2
; HYBRID-ATOMICS-NEXT:    not a6, a6
; HYBRID-ATOMICS-NEXT:    not a5, a5
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a5
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a6
; HYBRID-ATOMICS-NEXT:  .LBB6_3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB6_1 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB6_5
; HYBRID-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB6_3 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB6_3
; HYBRID-ATOMICS-NEXT:  .LBB6_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB6_1 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB6_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_nand:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    li a3, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_fetch_nand_16@plt
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_nand:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -16
; HYBRID-CAP-PTR-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    li a3, 5
; HYBRID-CAP-PTR-NEXT:    call __atomic_fetch_nand_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 16
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_nand
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = and i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = xor i128 [[TMP2]], -1
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = trunc i128 [[TMP4]] to i64
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP3]], i64 [[TMP5]])
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = trunc i128 [[TMP8]] to i64
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP7]], i64 [[TMP9]])
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP6]], ptr addrspace(200) [[TMP10]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 0
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 1
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = zext i64 [[TMP15]] to i128
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = shl i128 [[TMP17]], 64
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = or i128 [[TMP16]], [[TMP18]]
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP19]], 0
; PURECAP-IR-NEXT:    [[TMP21:%.*]] = insertvalue { i128, i1 } [[TMP20]], i1 [[TMP13]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP21]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP21]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_nand
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = call i128 @__atomic_fetch_nand_16_c(ptr addrspace(200) [[PTR]], i128 [[VAL]], i32 5)
; HYBRID-IR-NEXT:    ret i128 [[TMP1]]
;
  %tmp = atomicrmw nand ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_or(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_or:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:  .LBB7_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB7_3 Depth 2
; PURECAP-ATOMICS-NEXT:    or a5, a3, a2
; PURECAP-ATOMICS-NEXT:    or a6, a4, a1
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a6
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; PURECAP-ATOMICS-NEXT:  .LBB7_3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB7_1 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB7_5
; PURECAP-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB7_3 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB7_3
; PURECAP-ATOMICS-NEXT:  .LBB7_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB7_1 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB7_1
; PURECAP-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_or:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    li a3, 5
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_fetch_or_16
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_or:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:  .LBB7_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB7_3 Depth 2
; HYBRID-ATOMICS-NEXT:    or a5, a3, a2
; HYBRID-ATOMICS-NEXT:    or a6, a4, a1
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a6
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; HYBRID-ATOMICS-NEXT:  .LBB7_3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB7_1 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB7_5
; HYBRID-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB7_3 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB7_3
; HYBRID-ATOMICS-NEXT:  .LBB7_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB7_1 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB7_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_or:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    li a3, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_fetch_or_16@plt
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_or:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -16
; HYBRID-CAP-PTR-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    li a3, 5
; HYBRID-CAP-PTR-NEXT:    call __atomic_fetch_or_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 16
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_or
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = or i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = trunc i128 [[TMP3]] to i64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP2]], i64 [[TMP4]])
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = trunc i128 [[TMP7]] to i64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP6]], i64 [[TMP8]])
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP5]], ptr addrspace(200) [[TMP9]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 0
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 1
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = zext i64 [[TMP13]] to i128
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = shl i128 [[TMP16]], 64
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = or i128 [[TMP15]], [[TMP17]]
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP18]], 0
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } [[TMP19]], i1 [[TMP12]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP20]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP20]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_or
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = call i128 @__atomic_fetch_or_16_c(ptr addrspace(200) [[PTR]], i128 [[VAL]], i32 5)
; HYBRID-IR-NEXT:    ret i128 [[TMP1]]
;
  %tmp = atomicrmw or ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_xor(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_xor:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:  .LBB8_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB8_3 Depth 2
; PURECAP-ATOMICS-NEXT:    xor a5, a3, a2
; PURECAP-ATOMICS-NEXT:    xor a6, a4, a1
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a6
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; PURECAP-ATOMICS-NEXT:  .LBB8_3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB8_1 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB8_5
; PURECAP-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB8_3 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB8_3
; PURECAP-ATOMICS-NEXT:  .LBB8_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB8_1 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB8_1
; PURECAP-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_xor:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -16
; PURECAP-LIBCALLS-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    li a3, 5
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_fetch_xor_16
; PURECAP-LIBCALLS-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 16
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_xor:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:  .LBB8_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB8_3 Depth 2
; HYBRID-ATOMICS-NEXT:    xor a5, a3, a2
; HYBRID-ATOMICS-NEXT:    xor a6, a4, a1
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a6
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; HYBRID-ATOMICS-NEXT:  .LBB8_3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB8_1 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB8_5
; HYBRID-ATOMICS-NEXT:  # %bb.4: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB8_3 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB8_3
; HYBRID-ATOMICS-NEXT:  .LBB8_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB8_1 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB8_1
; HYBRID-ATOMICS-NEXT:  # %bb.2: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_xor:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -16
; HYBRID-LIBCALLS-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    li a3, 5
; HYBRID-LIBCALLS-NEXT:    call __atomic_fetch_xor_16@plt
; HYBRID-LIBCALLS-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 16
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_xor:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -16
; HYBRID-CAP-PTR-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    li a3, 5
; HYBRID-CAP-PTR-NEXT:    call __atomic_fetch_xor_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 16
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_xor
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = xor i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = trunc i128 [[TMP3]] to i64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP2]], i64 [[TMP4]])
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = trunc i128 [[TMP7]] to i64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP6]], i64 [[TMP8]])
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP5]], ptr addrspace(200) [[TMP9]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 0
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP10]], 1
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP11]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = zext i64 [[TMP13]] to i128
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = shl i128 [[TMP16]], 64
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = or i128 [[TMP15]], [[TMP17]]
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP18]], 0
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } [[TMP19]], i1 [[TMP12]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP20]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP20]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_xor
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = call i128 @__atomic_fetch_xor_16_c(ptr addrspace(200) [[PTR]], i128 [[VAL]], i32 5)
; HYBRID-IR-NEXT:    ret i128 [[TMP1]]
;
  %tmp = atomicrmw xor ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_max(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_max:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:    j .LBB9_2
; PURECAP-ATOMICS-NEXT:  .LBB9_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a7
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; PURECAP-ATOMICS-NEXT:  .LBB9_8: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB9_2 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB9_10
; PURECAP-ATOMICS-NEXT:  # %bb.9: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB9_8 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB9_8
; PURECAP-ATOMICS-NEXT:  .LBB9_10: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB9_7
; PURECAP-ATOMICS-NEXT:  .LBB9_2: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB9_8 Depth 2
; PURECAP-ATOMICS-NEXT:    beq a3, a2, .LBB9_4
; PURECAP-ATOMICS-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; PURECAP-ATOMICS-NEXT:    slt a6, a2, a3
; PURECAP-ATOMICS-NEXT:    j .LBB9_5
; PURECAP-ATOMICS-NEXT:  .LBB9_4: # in Loop: Header=BB9_2 Depth=1
; PURECAP-ATOMICS-NEXT:    sltu a6, a1, a4
; PURECAP-ATOMICS-NEXT:  .LBB9_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; PURECAP-ATOMICS-NEXT:    mv a5, a3
; PURECAP-ATOMICS-NEXT:    mv a7, a4
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB9_1
; PURECAP-ATOMICS-NEXT:  # %bb.6: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; PURECAP-ATOMICS-NEXT:    mv a5, a2
; PURECAP-ATOMICS-NEXT:    mv a7, a1
; PURECAP-ATOMICS-NEXT:    j .LBB9_1
; PURECAP-ATOMICS-NEXT:  .LBB9_7: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_max:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -96
; PURECAP-LIBCALLS-NEXT:    csc cra, 80(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs0, 64(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs1, 48(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs2, 32(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs3, 16(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    cmove cs3, ca0
; PURECAP-LIBCALLS-NEXT:    cld a5, 8(ca0)
; PURECAP-LIBCALLS-NEXT:    cld a4, 0(ca0)
; PURECAP-LIBCALLS-NEXT:    mv s1, a2
; PURECAP-LIBCALLS-NEXT:    mv s2, a1
; PURECAP-LIBCALLS-NEXT:    cincoffset ca0, csp, 0
; PURECAP-LIBCALLS-NEXT:    csetbounds cs0, ca0, 16
; PURECAP-LIBCALLS-NEXT:    j .LBB9_2
; PURECAP-LIBCALLS-NEXT:  .LBB9_1: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    csd a4, 0(csp)
; PURECAP-LIBCALLS-NEXT:    csd a5, 8(csp)
; PURECAP-LIBCALLS-NEXT:    li a4, 5
; PURECAP-LIBCALLS-NEXT:    li a5, 5
; PURECAP-LIBCALLS-NEXT:    cmove ca0, cs3
; PURECAP-LIBCALLS-NEXT:    cmove ca1, cs0
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_compare_exchange_16
; PURECAP-LIBCALLS-NEXT:    cld a5, 8(csp)
; PURECAP-LIBCALLS-NEXT:    cld a4, 0(csp)
; PURECAP-LIBCALLS-NEXT:    bnez a0, .LBB9_7
; PURECAP-LIBCALLS-NEXT:  .LBB9_2: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-LIBCALLS-NEXT:    beq a5, s1, .LBB9_4
; PURECAP-LIBCALLS-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    slt a0, s1, a5
; PURECAP-LIBCALLS-NEXT:    j .LBB9_5
; PURECAP-LIBCALLS-NEXT:  .LBB9_4: # in Loop: Header=BB9_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    sltu a0, s2, a4
; PURECAP-LIBCALLS-NEXT:  .LBB9_5: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    mv a2, a4
; PURECAP-LIBCALLS-NEXT:    mv a3, a5
; PURECAP-LIBCALLS-NEXT:    bnez a0, .LBB9_1
; PURECAP-LIBCALLS-NEXT:  # %bb.6: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    mv a2, s2
; PURECAP-LIBCALLS-NEXT:    mv a3, s1
; PURECAP-LIBCALLS-NEXT:    j .LBB9_1
; PURECAP-LIBCALLS-NEXT:  .LBB9_7: # %atomicrmw.end
; PURECAP-LIBCALLS-NEXT:    mv a0, a4
; PURECAP-LIBCALLS-NEXT:    mv a1, a5
; PURECAP-LIBCALLS-NEXT:    clc cra, 80(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs0, 64(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs1, 48(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs2, 32(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs3, 16(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 96
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_max:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:    j .LBB9_2
; HYBRID-ATOMICS-NEXT:  .LBB9_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a7
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; HYBRID-ATOMICS-NEXT:  .LBB9_8: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB9_2 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB9_10
; HYBRID-ATOMICS-NEXT:  # %bb.9: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB9_8 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB9_8
; HYBRID-ATOMICS-NEXT:  .LBB9_10: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB9_7
; HYBRID-ATOMICS-NEXT:  .LBB9_2: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB9_8 Depth 2
; HYBRID-ATOMICS-NEXT:    beq a3, a2, .LBB9_4
; HYBRID-ATOMICS-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-ATOMICS-NEXT:    slt a6, a2, a3
; HYBRID-ATOMICS-NEXT:    j .LBB9_5
; HYBRID-ATOMICS-NEXT:  .LBB9_4: # in Loop: Header=BB9_2 Depth=1
; HYBRID-ATOMICS-NEXT:    sltu a6, a1, a4
; HYBRID-ATOMICS-NEXT:  .LBB9_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-ATOMICS-NEXT:    mv a5, a3
; HYBRID-ATOMICS-NEXT:    mv a7, a4
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB9_1
; HYBRID-ATOMICS-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-ATOMICS-NEXT:    mv a5, a2
; HYBRID-ATOMICS-NEXT:    mv a7, a1
; HYBRID-ATOMICS-NEXT:    j .LBB9_1
; HYBRID-ATOMICS-NEXT:  .LBB9_7: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_max:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -48
; HYBRID-LIBCALLS-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    mv s0, a0
; HYBRID-LIBCALLS-NEXT:    ld a5, 8(a0)
; HYBRID-LIBCALLS-NEXT:    ld a4, 0(a0)
; HYBRID-LIBCALLS-NEXT:    mv s1, a2
; HYBRID-LIBCALLS-NEXT:    mv s2, a1
; HYBRID-LIBCALLS-NEXT:    j .LBB9_2
; HYBRID-LIBCALLS-NEXT:  .LBB9_1: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sd a4, 0(sp)
; HYBRID-LIBCALLS-NEXT:    sd a5, 8(sp)
; HYBRID-LIBCALLS-NEXT:    mv a1, sp
; HYBRID-LIBCALLS-NEXT:    li a4, 5
; HYBRID-LIBCALLS-NEXT:    li a5, 5
; HYBRID-LIBCALLS-NEXT:    mv a0, s0
; HYBRID-LIBCALLS-NEXT:    call __atomic_compare_exchange_16@plt
; HYBRID-LIBCALLS-NEXT:    ld a5, 8(sp)
; HYBRID-LIBCALLS-NEXT:    ld a4, 0(sp)
; HYBRID-LIBCALLS-NEXT:    bnez a0, .LBB9_7
; HYBRID-LIBCALLS-NEXT:  .LBB9_2: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-LIBCALLS-NEXT:    beq a5, s1, .LBB9_4
; HYBRID-LIBCALLS-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    slt a0, s1, a5
; HYBRID-LIBCALLS-NEXT:    j .LBB9_5
; HYBRID-LIBCALLS-NEXT:  .LBB9_4: # in Loop: Header=BB9_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sltu a0, s2, a4
; HYBRID-LIBCALLS-NEXT:  .LBB9_5: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    mv a2, a4
; HYBRID-LIBCALLS-NEXT:    mv a3, a5
; HYBRID-LIBCALLS-NEXT:    bnez a0, .LBB9_1
; HYBRID-LIBCALLS-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    mv a2, s2
; HYBRID-LIBCALLS-NEXT:    mv a3, s1
; HYBRID-LIBCALLS-NEXT:    j .LBB9_1
; HYBRID-LIBCALLS-NEXT:  .LBB9_7: # %atomicrmw.end
; HYBRID-LIBCALLS-NEXT:    mv a0, a4
; HYBRID-LIBCALLS-NEXT:    mv a1, a5
; HYBRID-LIBCALLS-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 48
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_max:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -64
; HYBRID-CAP-PTR-NEXT:    sd ra, 56(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s0, 48(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s1, 40(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    ld.cap a4, (ca0)
; HYBRID-CAP-PTR-NEXT:    sc ca0, 0(sp) # 16-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    cincoffset ca0, ca0, 8
; HYBRID-CAP-PTR-NEXT:    ld.cap a5, (ca0)
; HYBRID-CAP-PTR-NEXT:    mv s0, a2
; HYBRID-CAP-PTR-NEXT:    mv s1, a1
; HYBRID-CAP-PTR-NEXT:    j .LBB9_2
; HYBRID-CAP-PTR-NEXT:  .LBB9_1: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sd a4, 16(sp)
; HYBRID-CAP-PTR-NEXT:    sd a5, 24(sp)
; HYBRID-CAP-PTR-NEXT:    addi a1, sp, 16
; HYBRID-CAP-PTR-NEXT:    li a4, 5
; HYBRID-CAP-PTR-NEXT:    li a5, 5
; HYBRID-CAP-PTR-NEXT:    lc ca0, 0(sp) # 16-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    call __atomic_compare_exchange_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld a5, 24(sp)
; HYBRID-CAP-PTR-NEXT:    ld a4, 16(sp)
; HYBRID-CAP-PTR-NEXT:    bnez a0, .LBB9_7
; HYBRID-CAP-PTR-NEXT:  .LBB9_2: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-CAP-PTR-NEXT:    beq a5, s0, .LBB9_4
; HYBRID-CAP-PTR-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    slt a0, s0, a5
; HYBRID-CAP-PTR-NEXT:    j .LBB9_5
; HYBRID-CAP-PTR-NEXT:  .LBB9_4: # in Loop: Header=BB9_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sltu a0, s1, a4
; HYBRID-CAP-PTR-NEXT:  .LBB9_5: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    mv a2, a4
; HYBRID-CAP-PTR-NEXT:    mv a3, a5
; HYBRID-CAP-PTR-NEXT:    bnez a0, .LBB9_1
; HYBRID-CAP-PTR-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB9_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    mv a2, s1
; HYBRID-CAP-PTR-NEXT:    mv a3, s0
; HYBRID-CAP-PTR-NEXT:    j .LBB9_1
; HYBRID-CAP-PTR-NEXT:  .LBB9_7: # %atomicrmw.end
; HYBRID-CAP-PTR-NEXT:    mv a0, a4
; HYBRID-CAP-PTR-NEXT:    mv a1, a5
; HYBRID-CAP-PTR-NEXT:    ld ra, 56(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s0, 48(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s1, 40(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 64
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_max
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = icmp sgt i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = select i1 [[TMP2]], i128 [[LOADED]], i128 [[VAL]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = trunc i128 [[TMP4]] to i64
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP3]], i64 [[TMP5]])
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = trunc i128 [[TMP8]] to i64
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP7]], i64 [[TMP9]])
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP6]], ptr addrspace(200) [[TMP10]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 0
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 1
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = zext i64 [[TMP15]] to i128
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = shl i128 [[TMP17]], 64
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = or i128 [[TMP16]], [[TMP18]]
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP19]], 0
; PURECAP-IR-NEXT:    [[TMP21:%.*]] = insertvalue { i128, i1 } [[TMP20]], i1 [[TMP13]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP21]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP21]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_max
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = alloca i128, align 16
; HYBRID-IR-NEXT:    [[TMP2:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; HYBRID-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; HYBRID-IR:       atomicrmw.start:
; HYBRID-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP2]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; HYBRID-IR-NEXT:    [[TMP3:%.*]] = icmp sgt i128 [[LOADED]], [[VAL]]
; HYBRID-IR-NEXT:    [[NEW:%.*]] = select i1 [[TMP3]], i128 [[LOADED]], i128 [[VAL]]
; HYBRID-IR-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    store i128 [[LOADED]], ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    [[TMP4:%.*]] = call zeroext i1 @__atomic_compare_exchange_16_c(ptr addrspace(200) [[PTR]], ptr [[TMP1]], i128 [[NEW]], i32 5, i32 5)
; HYBRID-IR-NEXT:    [[TMP5:%.*]] = load i128, ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    [[TMP6:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP5]], 0
; HYBRID-IR-NEXT:    [[TMP7:%.*]] = insertvalue { i128, i1 } [[TMP6]], i1 [[TMP4]], 1
; HYBRID-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP7]], 1
; HYBRID-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP7]], 0
; HYBRID-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; HYBRID-IR:       atomicrmw.end:
; HYBRID-IR-NEXT:    ret i128 [[NEWLOADED]]
;
  %tmp = atomicrmw max ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_min(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_min:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:    j .LBB10_2
; PURECAP-ATOMICS-NEXT:  .LBB10_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a7
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; PURECAP-ATOMICS-NEXT:  .LBB10_8: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB10_2 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB10_10
; PURECAP-ATOMICS-NEXT:  # %bb.9: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB10_8 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB10_8
; PURECAP-ATOMICS-NEXT:  .LBB10_10: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB10_7
; PURECAP-ATOMICS-NEXT:  .LBB10_2: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB10_8 Depth 2
; PURECAP-ATOMICS-NEXT:    beq a3, a2, .LBB10_4
; PURECAP-ATOMICS-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; PURECAP-ATOMICS-NEXT:    slt a5, a2, a3
; PURECAP-ATOMICS-NEXT:    j .LBB10_5
; PURECAP-ATOMICS-NEXT:  .LBB10_4: # in Loop: Header=BB10_2 Depth=1
; PURECAP-ATOMICS-NEXT:    sltu a5, a1, a4
; PURECAP-ATOMICS-NEXT:  .LBB10_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; PURECAP-ATOMICS-NEXT:    xori a6, a5, 1
; PURECAP-ATOMICS-NEXT:    mv a5, a3
; PURECAP-ATOMICS-NEXT:    mv a7, a4
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB10_1
; PURECAP-ATOMICS-NEXT:  # %bb.6: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; PURECAP-ATOMICS-NEXT:    mv a5, a2
; PURECAP-ATOMICS-NEXT:    mv a7, a1
; PURECAP-ATOMICS-NEXT:    j .LBB10_1
; PURECAP-ATOMICS-NEXT:  .LBB10_7: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_min:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -96
; PURECAP-LIBCALLS-NEXT:    csc cra, 80(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs0, 64(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs1, 48(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs2, 32(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs3, 16(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    cmove cs3, ca0
; PURECAP-LIBCALLS-NEXT:    cld a5, 8(ca0)
; PURECAP-LIBCALLS-NEXT:    cld a4, 0(ca0)
; PURECAP-LIBCALLS-NEXT:    mv s1, a2
; PURECAP-LIBCALLS-NEXT:    mv s2, a1
; PURECAP-LIBCALLS-NEXT:    cincoffset ca0, csp, 0
; PURECAP-LIBCALLS-NEXT:    csetbounds cs0, ca0, 16
; PURECAP-LIBCALLS-NEXT:    j .LBB10_2
; PURECAP-LIBCALLS-NEXT:  .LBB10_1: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    csd a4, 0(csp)
; PURECAP-LIBCALLS-NEXT:    csd a5, 8(csp)
; PURECAP-LIBCALLS-NEXT:    li a4, 5
; PURECAP-LIBCALLS-NEXT:    li a5, 5
; PURECAP-LIBCALLS-NEXT:    cmove ca0, cs3
; PURECAP-LIBCALLS-NEXT:    cmove ca1, cs0
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_compare_exchange_16
; PURECAP-LIBCALLS-NEXT:    cld a5, 8(csp)
; PURECAP-LIBCALLS-NEXT:    cld a4, 0(csp)
; PURECAP-LIBCALLS-NEXT:    bnez a0, .LBB10_7
; PURECAP-LIBCALLS-NEXT:  .LBB10_2: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-LIBCALLS-NEXT:    beq a5, s1, .LBB10_4
; PURECAP-LIBCALLS-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    slt a0, s1, a5
; PURECAP-LIBCALLS-NEXT:    j .LBB10_5
; PURECAP-LIBCALLS-NEXT:  .LBB10_4: # in Loop: Header=BB10_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    sltu a0, s2, a4
; PURECAP-LIBCALLS-NEXT:  .LBB10_5: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    xori a0, a0, 1
; PURECAP-LIBCALLS-NEXT:    mv a2, a4
; PURECAP-LIBCALLS-NEXT:    mv a3, a5
; PURECAP-LIBCALLS-NEXT:    bnez a0, .LBB10_1
; PURECAP-LIBCALLS-NEXT:  # %bb.6: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    mv a2, s2
; PURECAP-LIBCALLS-NEXT:    mv a3, s1
; PURECAP-LIBCALLS-NEXT:    j .LBB10_1
; PURECAP-LIBCALLS-NEXT:  .LBB10_7: # %atomicrmw.end
; PURECAP-LIBCALLS-NEXT:    mv a0, a4
; PURECAP-LIBCALLS-NEXT:    mv a1, a5
; PURECAP-LIBCALLS-NEXT:    clc cra, 80(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs0, 64(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs1, 48(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs2, 32(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs3, 16(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 96
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_min:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:    j .LBB10_2
; HYBRID-ATOMICS-NEXT:  .LBB10_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a7
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; HYBRID-ATOMICS-NEXT:  .LBB10_8: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB10_2 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB10_10
; HYBRID-ATOMICS-NEXT:  # %bb.9: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB10_8 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB10_8
; HYBRID-ATOMICS-NEXT:  .LBB10_10: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB10_7
; HYBRID-ATOMICS-NEXT:  .LBB10_2: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB10_8 Depth 2
; HYBRID-ATOMICS-NEXT:    beq a3, a2, .LBB10_4
; HYBRID-ATOMICS-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-ATOMICS-NEXT:    slt a5, a2, a3
; HYBRID-ATOMICS-NEXT:    j .LBB10_5
; HYBRID-ATOMICS-NEXT:  .LBB10_4: # in Loop: Header=BB10_2 Depth=1
; HYBRID-ATOMICS-NEXT:    sltu a5, a1, a4
; HYBRID-ATOMICS-NEXT:  .LBB10_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-ATOMICS-NEXT:    xori a6, a5, 1
; HYBRID-ATOMICS-NEXT:    mv a5, a3
; HYBRID-ATOMICS-NEXT:    mv a7, a4
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB10_1
; HYBRID-ATOMICS-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-ATOMICS-NEXT:    mv a5, a2
; HYBRID-ATOMICS-NEXT:    mv a7, a1
; HYBRID-ATOMICS-NEXT:    j .LBB10_1
; HYBRID-ATOMICS-NEXT:  .LBB10_7: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_min:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -48
; HYBRID-LIBCALLS-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    mv s0, a0
; HYBRID-LIBCALLS-NEXT:    ld a5, 8(a0)
; HYBRID-LIBCALLS-NEXT:    ld a4, 0(a0)
; HYBRID-LIBCALLS-NEXT:    mv s1, a2
; HYBRID-LIBCALLS-NEXT:    mv s2, a1
; HYBRID-LIBCALLS-NEXT:    j .LBB10_2
; HYBRID-LIBCALLS-NEXT:  .LBB10_1: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sd a4, 0(sp)
; HYBRID-LIBCALLS-NEXT:    sd a5, 8(sp)
; HYBRID-LIBCALLS-NEXT:    mv a1, sp
; HYBRID-LIBCALLS-NEXT:    li a4, 5
; HYBRID-LIBCALLS-NEXT:    li a5, 5
; HYBRID-LIBCALLS-NEXT:    mv a0, s0
; HYBRID-LIBCALLS-NEXT:    call __atomic_compare_exchange_16@plt
; HYBRID-LIBCALLS-NEXT:    ld a5, 8(sp)
; HYBRID-LIBCALLS-NEXT:    ld a4, 0(sp)
; HYBRID-LIBCALLS-NEXT:    bnez a0, .LBB10_7
; HYBRID-LIBCALLS-NEXT:  .LBB10_2: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-LIBCALLS-NEXT:    beq a5, s1, .LBB10_4
; HYBRID-LIBCALLS-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    slt a0, s1, a5
; HYBRID-LIBCALLS-NEXT:    j .LBB10_5
; HYBRID-LIBCALLS-NEXT:  .LBB10_4: # in Loop: Header=BB10_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sltu a0, s2, a4
; HYBRID-LIBCALLS-NEXT:  .LBB10_5: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    xori a0, a0, 1
; HYBRID-LIBCALLS-NEXT:    mv a2, a4
; HYBRID-LIBCALLS-NEXT:    mv a3, a5
; HYBRID-LIBCALLS-NEXT:    bnez a0, .LBB10_1
; HYBRID-LIBCALLS-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    mv a2, s2
; HYBRID-LIBCALLS-NEXT:    mv a3, s1
; HYBRID-LIBCALLS-NEXT:    j .LBB10_1
; HYBRID-LIBCALLS-NEXT:  .LBB10_7: # %atomicrmw.end
; HYBRID-LIBCALLS-NEXT:    mv a0, a4
; HYBRID-LIBCALLS-NEXT:    mv a1, a5
; HYBRID-LIBCALLS-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 48
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_min:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -64
; HYBRID-CAP-PTR-NEXT:    sd ra, 56(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s0, 48(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s1, 40(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    ld.cap a4, (ca0)
; HYBRID-CAP-PTR-NEXT:    sc ca0, 0(sp) # 16-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    cincoffset ca0, ca0, 8
; HYBRID-CAP-PTR-NEXT:    ld.cap a5, (ca0)
; HYBRID-CAP-PTR-NEXT:    mv s0, a2
; HYBRID-CAP-PTR-NEXT:    mv s1, a1
; HYBRID-CAP-PTR-NEXT:    j .LBB10_2
; HYBRID-CAP-PTR-NEXT:  .LBB10_1: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sd a4, 16(sp)
; HYBRID-CAP-PTR-NEXT:    sd a5, 24(sp)
; HYBRID-CAP-PTR-NEXT:    addi a1, sp, 16
; HYBRID-CAP-PTR-NEXT:    li a4, 5
; HYBRID-CAP-PTR-NEXT:    li a5, 5
; HYBRID-CAP-PTR-NEXT:    lc ca0, 0(sp) # 16-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    call __atomic_compare_exchange_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld a5, 24(sp)
; HYBRID-CAP-PTR-NEXT:    ld a4, 16(sp)
; HYBRID-CAP-PTR-NEXT:    bnez a0, .LBB10_7
; HYBRID-CAP-PTR-NEXT:  .LBB10_2: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-CAP-PTR-NEXT:    beq a5, s0, .LBB10_4
; HYBRID-CAP-PTR-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    slt a0, s0, a5
; HYBRID-CAP-PTR-NEXT:    j .LBB10_5
; HYBRID-CAP-PTR-NEXT:  .LBB10_4: # in Loop: Header=BB10_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sltu a0, s1, a4
; HYBRID-CAP-PTR-NEXT:  .LBB10_5: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    xori a0, a0, 1
; HYBRID-CAP-PTR-NEXT:    mv a2, a4
; HYBRID-CAP-PTR-NEXT:    mv a3, a5
; HYBRID-CAP-PTR-NEXT:    bnez a0, .LBB10_1
; HYBRID-CAP-PTR-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB10_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    mv a2, s1
; HYBRID-CAP-PTR-NEXT:    mv a3, s0
; HYBRID-CAP-PTR-NEXT:    j .LBB10_1
; HYBRID-CAP-PTR-NEXT:  .LBB10_7: # %atomicrmw.end
; HYBRID-CAP-PTR-NEXT:    mv a0, a4
; HYBRID-CAP-PTR-NEXT:    mv a1, a5
; HYBRID-CAP-PTR-NEXT:    ld ra, 56(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s0, 48(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s1, 40(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 64
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_min
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = icmp sle i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = select i1 [[TMP2]], i128 [[LOADED]], i128 [[VAL]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = trunc i128 [[TMP4]] to i64
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP3]], i64 [[TMP5]])
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = trunc i128 [[TMP8]] to i64
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP7]], i64 [[TMP9]])
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP6]], ptr addrspace(200) [[TMP10]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 0
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 1
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = zext i64 [[TMP15]] to i128
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = shl i128 [[TMP17]], 64
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = or i128 [[TMP16]], [[TMP18]]
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP19]], 0
; PURECAP-IR-NEXT:    [[TMP21:%.*]] = insertvalue { i128, i1 } [[TMP20]], i1 [[TMP13]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP21]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP21]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_min
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = alloca i128, align 16
; HYBRID-IR-NEXT:    [[TMP2:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; HYBRID-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; HYBRID-IR:       atomicrmw.start:
; HYBRID-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP2]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; HYBRID-IR-NEXT:    [[TMP3:%.*]] = icmp sle i128 [[LOADED]], [[VAL]]
; HYBRID-IR-NEXT:    [[NEW:%.*]] = select i1 [[TMP3]], i128 [[LOADED]], i128 [[VAL]]
; HYBRID-IR-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    store i128 [[LOADED]], ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    [[TMP4:%.*]] = call zeroext i1 @__atomic_compare_exchange_16_c(ptr addrspace(200) [[PTR]], ptr [[TMP1]], i128 [[NEW]], i32 5, i32 5)
; HYBRID-IR-NEXT:    [[TMP5:%.*]] = load i128, ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    [[TMP6:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP5]], 0
; HYBRID-IR-NEXT:    [[TMP7:%.*]] = insertvalue { i128, i1 } [[TMP6]], i1 [[TMP4]], 1
; HYBRID-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP7]], 1
; HYBRID-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP7]], 0
; HYBRID-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; HYBRID-IR:       atomicrmw.end:
; HYBRID-IR-NEXT:    ret i128 [[NEWLOADED]]
;
  %tmp = atomicrmw min ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_umax(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_umax:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:    j .LBB11_2
; PURECAP-ATOMICS-NEXT:  .LBB11_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a7
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; PURECAP-ATOMICS-NEXT:  .LBB11_8: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB11_2 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB11_10
; PURECAP-ATOMICS-NEXT:  # %bb.9: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB11_8 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB11_8
; PURECAP-ATOMICS-NEXT:  .LBB11_10: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB11_7
; PURECAP-ATOMICS-NEXT:  .LBB11_2: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB11_8 Depth 2
; PURECAP-ATOMICS-NEXT:    beq a3, a2, .LBB11_4
; PURECAP-ATOMICS-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; PURECAP-ATOMICS-NEXT:    sltu a6, a2, a3
; PURECAP-ATOMICS-NEXT:    j .LBB11_5
; PURECAP-ATOMICS-NEXT:  .LBB11_4: # in Loop: Header=BB11_2 Depth=1
; PURECAP-ATOMICS-NEXT:    sltu a6, a1, a4
; PURECAP-ATOMICS-NEXT:  .LBB11_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; PURECAP-ATOMICS-NEXT:    mv a5, a3
; PURECAP-ATOMICS-NEXT:    mv a7, a4
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB11_1
; PURECAP-ATOMICS-NEXT:  # %bb.6: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; PURECAP-ATOMICS-NEXT:    mv a5, a2
; PURECAP-ATOMICS-NEXT:    mv a7, a1
; PURECAP-ATOMICS-NEXT:    j .LBB11_1
; PURECAP-ATOMICS-NEXT:  .LBB11_7: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_umax:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -96
; PURECAP-LIBCALLS-NEXT:    csc cra, 80(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs0, 64(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs1, 48(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs2, 32(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs3, 16(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    cmove cs3, ca0
; PURECAP-LIBCALLS-NEXT:    cld a5, 8(ca0)
; PURECAP-LIBCALLS-NEXT:    cld a4, 0(ca0)
; PURECAP-LIBCALLS-NEXT:    mv s1, a2
; PURECAP-LIBCALLS-NEXT:    mv s2, a1
; PURECAP-LIBCALLS-NEXT:    cincoffset ca0, csp, 0
; PURECAP-LIBCALLS-NEXT:    csetbounds cs0, ca0, 16
; PURECAP-LIBCALLS-NEXT:    j .LBB11_2
; PURECAP-LIBCALLS-NEXT:  .LBB11_1: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    csd a4, 0(csp)
; PURECAP-LIBCALLS-NEXT:    csd a5, 8(csp)
; PURECAP-LIBCALLS-NEXT:    li a4, 5
; PURECAP-LIBCALLS-NEXT:    li a5, 5
; PURECAP-LIBCALLS-NEXT:    cmove ca0, cs3
; PURECAP-LIBCALLS-NEXT:    cmove ca1, cs0
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_compare_exchange_16
; PURECAP-LIBCALLS-NEXT:    cld a5, 8(csp)
; PURECAP-LIBCALLS-NEXT:    cld a4, 0(csp)
; PURECAP-LIBCALLS-NEXT:    bnez a0, .LBB11_7
; PURECAP-LIBCALLS-NEXT:  .LBB11_2: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-LIBCALLS-NEXT:    beq a5, s1, .LBB11_4
; PURECAP-LIBCALLS-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    sltu a0, s1, a5
; PURECAP-LIBCALLS-NEXT:    j .LBB11_5
; PURECAP-LIBCALLS-NEXT:  .LBB11_4: # in Loop: Header=BB11_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    sltu a0, s2, a4
; PURECAP-LIBCALLS-NEXT:  .LBB11_5: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    mv a2, a4
; PURECAP-LIBCALLS-NEXT:    mv a3, a5
; PURECAP-LIBCALLS-NEXT:    bnez a0, .LBB11_1
; PURECAP-LIBCALLS-NEXT:  # %bb.6: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    mv a2, s2
; PURECAP-LIBCALLS-NEXT:    mv a3, s1
; PURECAP-LIBCALLS-NEXT:    j .LBB11_1
; PURECAP-LIBCALLS-NEXT:  .LBB11_7: # %atomicrmw.end
; PURECAP-LIBCALLS-NEXT:    mv a0, a4
; PURECAP-LIBCALLS-NEXT:    mv a1, a5
; PURECAP-LIBCALLS-NEXT:    clc cra, 80(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs0, 64(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs1, 48(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs2, 32(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs3, 16(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 96
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_umax:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:    j .LBB11_2
; HYBRID-ATOMICS-NEXT:  .LBB11_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a7
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; HYBRID-ATOMICS-NEXT:  .LBB11_8: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB11_2 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB11_10
; HYBRID-ATOMICS-NEXT:  # %bb.9: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB11_8 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB11_8
; HYBRID-ATOMICS-NEXT:  .LBB11_10: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB11_7
; HYBRID-ATOMICS-NEXT:  .LBB11_2: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB11_8 Depth 2
; HYBRID-ATOMICS-NEXT:    beq a3, a2, .LBB11_4
; HYBRID-ATOMICS-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-ATOMICS-NEXT:    sltu a6, a2, a3
; HYBRID-ATOMICS-NEXT:    j .LBB11_5
; HYBRID-ATOMICS-NEXT:  .LBB11_4: # in Loop: Header=BB11_2 Depth=1
; HYBRID-ATOMICS-NEXT:    sltu a6, a1, a4
; HYBRID-ATOMICS-NEXT:  .LBB11_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-ATOMICS-NEXT:    mv a5, a3
; HYBRID-ATOMICS-NEXT:    mv a7, a4
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB11_1
; HYBRID-ATOMICS-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-ATOMICS-NEXT:    mv a5, a2
; HYBRID-ATOMICS-NEXT:    mv a7, a1
; HYBRID-ATOMICS-NEXT:    j .LBB11_1
; HYBRID-ATOMICS-NEXT:  .LBB11_7: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_umax:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -48
; HYBRID-LIBCALLS-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    mv s0, a0
; HYBRID-LIBCALLS-NEXT:    ld a5, 8(a0)
; HYBRID-LIBCALLS-NEXT:    ld a4, 0(a0)
; HYBRID-LIBCALLS-NEXT:    mv s1, a2
; HYBRID-LIBCALLS-NEXT:    mv s2, a1
; HYBRID-LIBCALLS-NEXT:    j .LBB11_2
; HYBRID-LIBCALLS-NEXT:  .LBB11_1: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sd a4, 0(sp)
; HYBRID-LIBCALLS-NEXT:    sd a5, 8(sp)
; HYBRID-LIBCALLS-NEXT:    mv a1, sp
; HYBRID-LIBCALLS-NEXT:    li a4, 5
; HYBRID-LIBCALLS-NEXT:    li a5, 5
; HYBRID-LIBCALLS-NEXT:    mv a0, s0
; HYBRID-LIBCALLS-NEXT:    call __atomic_compare_exchange_16@plt
; HYBRID-LIBCALLS-NEXT:    ld a5, 8(sp)
; HYBRID-LIBCALLS-NEXT:    ld a4, 0(sp)
; HYBRID-LIBCALLS-NEXT:    bnez a0, .LBB11_7
; HYBRID-LIBCALLS-NEXT:  .LBB11_2: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-LIBCALLS-NEXT:    beq a5, s1, .LBB11_4
; HYBRID-LIBCALLS-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sltu a0, s1, a5
; HYBRID-LIBCALLS-NEXT:    j .LBB11_5
; HYBRID-LIBCALLS-NEXT:  .LBB11_4: # in Loop: Header=BB11_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sltu a0, s2, a4
; HYBRID-LIBCALLS-NEXT:  .LBB11_5: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    mv a2, a4
; HYBRID-LIBCALLS-NEXT:    mv a3, a5
; HYBRID-LIBCALLS-NEXT:    bnez a0, .LBB11_1
; HYBRID-LIBCALLS-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    mv a2, s2
; HYBRID-LIBCALLS-NEXT:    mv a3, s1
; HYBRID-LIBCALLS-NEXT:    j .LBB11_1
; HYBRID-LIBCALLS-NEXT:  .LBB11_7: # %atomicrmw.end
; HYBRID-LIBCALLS-NEXT:    mv a0, a4
; HYBRID-LIBCALLS-NEXT:    mv a1, a5
; HYBRID-LIBCALLS-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 48
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_umax:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -64
; HYBRID-CAP-PTR-NEXT:    sd ra, 56(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s0, 48(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s1, 40(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    ld.cap a4, (ca0)
; HYBRID-CAP-PTR-NEXT:    sc ca0, 0(sp) # 16-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    cincoffset ca0, ca0, 8
; HYBRID-CAP-PTR-NEXT:    ld.cap a5, (ca0)
; HYBRID-CAP-PTR-NEXT:    mv s0, a2
; HYBRID-CAP-PTR-NEXT:    mv s1, a1
; HYBRID-CAP-PTR-NEXT:    j .LBB11_2
; HYBRID-CAP-PTR-NEXT:  .LBB11_1: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sd a4, 16(sp)
; HYBRID-CAP-PTR-NEXT:    sd a5, 24(sp)
; HYBRID-CAP-PTR-NEXT:    addi a1, sp, 16
; HYBRID-CAP-PTR-NEXT:    li a4, 5
; HYBRID-CAP-PTR-NEXT:    li a5, 5
; HYBRID-CAP-PTR-NEXT:    lc ca0, 0(sp) # 16-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    call __atomic_compare_exchange_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld a5, 24(sp)
; HYBRID-CAP-PTR-NEXT:    ld a4, 16(sp)
; HYBRID-CAP-PTR-NEXT:    bnez a0, .LBB11_7
; HYBRID-CAP-PTR-NEXT:  .LBB11_2: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-CAP-PTR-NEXT:    beq a5, s0, .LBB11_4
; HYBRID-CAP-PTR-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sltu a0, s0, a5
; HYBRID-CAP-PTR-NEXT:    j .LBB11_5
; HYBRID-CAP-PTR-NEXT:  .LBB11_4: # in Loop: Header=BB11_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sltu a0, s1, a4
; HYBRID-CAP-PTR-NEXT:  .LBB11_5: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    mv a2, a4
; HYBRID-CAP-PTR-NEXT:    mv a3, a5
; HYBRID-CAP-PTR-NEXT:    bnez a0, .LBB11_1
; HYBRID-CAP-PTR-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB11_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    mv a2, s1
; HYBRID-CAP-PTR-NEXT:    mv a3, s0
; HYBRID-CAP-PTR-NEXT:    j .LBB11_1
; HYBRID-CAP-PTR-NEXT:  .LBB11_7: # %atomicrmw.end
; HYBRID-CAP-PTR-NEXT:    mv a0, a4
; HYBRID-CAP-PTR-NEXT:    mv a1, a5
; HYBRID-CAP-PTR-NEXT:    ld ra, 56(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s0, 48(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s1, 40(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 64
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_umax
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = icmp ugt i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = select i1 [[TMP2]], i128 [[LOADED]], i128 [[VAL]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = trunc i128 [[TMP4]] to i64
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP3]], i64 [[TMP5]])
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = trunc i128 [[TMP8]] to i64
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP7]], i64 [[TMP9]])
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP6]], ptr addrspace(200) [[TMP10]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 0
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 1
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = zext i64 [[TMP15]] to i128
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = shl i128 [[TMP17]], 64
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = or i128 [[TMP16]], [[TMP18]]
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP19]], 0
; PURECAP-IR-NEXT:    [[TMP21:%.*]] = insertvalue { i128, i1 } [[TMP20]], i1 [[TMP13]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP21]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP21]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_umax
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = alloca i128, align 16
; HYBRID-IR-NEXT:    [[TMP2:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; HYBRID-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; HYBRID-IR:       atomicrmw.start:
; HYBRID-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP2]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; HYBRID-IR-NEXT:    [[TMP3:%.*]] = icmp ugt i128 [[LOADED]], [[VAL]]
; HYBRID-IR-NEXT:    [[NEW:%.*]] = select i1 [[TMP3]], i128 [[LOADED]], i128 [[VAL]]
; HYBRID-IR-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    store i128 [[LOADED]], ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    [[TMP4:%.*]] = call zeroext i1 @__atomic_compare_exchange_16_c(ptr addrspace(200) [[PTR]], ptr [[TMP1]], i128 [[NEW]], i32 5, i32 5)
; HYBRID-IR-NEXT:    [[TMP5:%.*]] = load i128, ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    [[TMP6:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP5]], 0
; HYBRID-IR-NEXT:    [[TMP7:%.*]] = insertvalue { i128, i1 } [[TMP6]], i1 [[TMP4]], 1
; HYBRID-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP7]], 1
; HYBRID-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP7]], 0
; HYBRID-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; HYBRID-IR:       atomicrmw.end:
; HYBRID-IR-NEXT:    ret i128 [[NEWLOADED]]
;
  %tmp = atomicrmw umax ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define i128 @atomic_umin(ptr addrspace(200) %ptr, i128 %val) nounwind {
; PURECAP-ATOMICS-LABEL: atomic_umin:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cld a3, 8(ca0)
; PURECAP-ATOMICS-NEXT:    cld a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:    j .LBB12_2
; PURECAP-ATOMICS-NEXT:  .LBB12_1: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca4, cnull, a7
; PURECAP-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; PURECAP-ATOMICS-NEXT:  .LBB12_8: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # Parent Loop BB12_2 Depth=1
; PURECAP-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca5, (ca0)
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    beqz a6, .LBB12_10
; PURECAP-ATOMICS-NEXT:  # %bb.9: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB12_8 Depth=2
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a6, ca4, (ca0)
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB12_8
; PURECAP-ATOMICS-NEXT:  .LBB12_10: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; PURECAP-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; PURECAP-ATOMICS-NEXT:    mv a4, a5
; PURECAP-ATOMICS-NEXT:    cgethigh a3, ca5
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB12_7
; PURECAP-ATOMICS-NEXT:  .LBB12_2: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    # Child Loop BB12_8 Depth 2
; PURECAP-ATOMICS-NEXT:    beq a3, a2, .LBB12_4
; PURECAP-ATOMICS-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; PURECAP-ATOMICS-NEXT:    sltu a5, a2, a3
; PURECAP-ATOMICS-NEXT:    j .LBB12_5
; PURECAP-ATOMICS-NEXT:  .LBB12_4: # in Loop: Header=BB12_2 Depth=1
; PURECAP-ATOMICS-NEXT:    sltu a5, a1, a4
; PURECAP-ATOMICS-NEXT:  .LBB12_5: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; PURECAP-ATOMICS-NEXT:    xori a6, a5, 1
; PURECAP-ATOMICS-NEXT:    mv a5, a3
; PURECAP-ATOMICS-NEXT:    mv a7, a4
; PURECAP-ATOMICS-NEXT:    bnez a6, .LBB12_1
; PURECAP-ATOMICS-NEXT:  # %bb.6: # %atomicrmw.start
; PURECAP-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; PURECAP-ATOMICS-NEXT:    mv a5, a2
; PURECAP-ATOMICS-NEXT:    mv a7, a1
; PURECAP-ATOMICS-NEXT:    j .LBB12_1
; PURECAP-ATOMICS-NEXT:  .LBB12_7: # %atomicrmw.end
; PURECAP-ATOMICS-NEXT:    mv a0, a4
; PURECAP-ATOMICS-NEXT:    mv a1, a3
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: atomic_umin:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -96
; PURECAP-LIBCALLS-NEXT:    csc cra, 80(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs0, 64(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs1, 48(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs2, 32(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs3, 16(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    cmove cs3, ca0
; PURECAP-LIBCALLS-NEXT:    cld a5, 8(ca0)
; PURECAP-LIBCALLS-NEXT:    cld a4, 0(ca0)
; PURECAP-LIBCALLS-NEXT:    mv s1, a2
; PURECAP-LIBCALLS-NEXT:    mv s2, a1
; PURECAP-LIBCALLS-NEXT:    cincoffset ca0, csp, 0
; PURECAP-LIBCALLS-NEXT:    csetbounds cs0, ca0, 16
; PURECAP-LIBCALLS-NEXT:    j .LBB12_2
; PURECAP-LIBCALLS-NEXT:  .LBB12_1: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    csd a4, 0(csp)
; PURECAP-LIBCALLS-NEXT:    csd a5, 8(csp)
; PURECAP-LIBCALLS-NEXT:    li a4, 5
; PURECAP-LIBCALLS-NEXT:    li a5, 5
; PURECAP-LIBCALLS-NEXT:    cmove ca0, cs3
; PURECAP-LIBCALLS-NEXT:    cmove ca1, cs0
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_compare_exchange_16
; PURECAP-LIBCALLS-NEXT:    cld a5, 8(csp)
; PURECAP-LIBCALLS-NEXT:    cld a4, 0(csp)
; PURECAP-LIBCALLS-NEXT:    bnez a0, .LBB12_7
; PURECAP-LIBCALLS-NEXT:  .LBB12_2: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # =>This Inner Loop Header: Depth=1
; PURECAP-LIBCALLS-NEXT:    beq a5, s1, .LBB12_4
; PURECAP-LIBCALLS-NEXT:  # %bb.3: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    sltu a0, s1, a5
; PURECAP-LIBCALLS-NEXT:    j .LBB12_5
; PURECAP-LIBCALLS-NEXT:  .LBB12_4: # in Loop: Header=BB12_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    sltu a0, s2, a4
; PURECAP-LIBCALLS-NEXT:  .LBB12_5: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    xori a0, a0, 1
; PURECAP-LIBCALLS-NEXT:    mv a2, a4
; PURECAP-LIBCALLS-NEXT:    mv a3, a5
; PURECAP-LIBCALLS-NEXT:    bnez a0, .LBB12_1
; PURECAP-LIBCALLS-NEXT:  # %bb.6: # %atomicrmw.start
; PURECAP-LIBCALLS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; PURECAP-LIBCALLS-NEXT:    mv a2, s2
; PURECAP-LIBCALLS-NEXT:    mv a3, s1
; PURECAP-LIBCALLS-NEXT:    j .LBB12_1
; PURECAP-LIBCALLS-NEXT:  .LBB12_7: # %atomicrmw.end
; PURECAP-LIBCALLS-NEXT:    mv a0, a4
; PURECAP-LIBCALLS-NEXT:    mv a1, a5
; PURECAP-LIBCALLS-NEXT:    clc cra, 80(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs0, 64(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs1, 48(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs2, 32(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs3, 16(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 96
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: atomic_umin:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    ld a3, 8(a0)
; HYBRID-ATOMICS-NEXT:    ld a4, 0(a0)
; HYBRID-ATOMICS-NEXT:    j .LBB12_2
; HYBRID-ATOMICS-NEXT:  .LBB12_1: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca4, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca4, cnull, a7
; HYBRID-ATOMICS-NEXT:    csethigh ca4, ca4, a5
; HYBRID-ATOMICS-NEXT:  .LBB12_8: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # Parent Loop BB12_2 Depth=1
; HYBRID-ATOMICS-NEXT:    # => This Inner Loop Header: Depth=2
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca5, (a0)
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    beqz a6, .LBB12_10
; HYBRID-ATOMICS-NEXT:  # %bb.9: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB12_8 Depth=2
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a6, ca4, (a0)
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB12_8
; HYBRID-ATOMICS-NEXT:  .LBB12_10: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-ATOMICS-NEXT:    cseqx a6, ca5, ca3
; HYBRID-ATOMICS-NEXT:    mv a4, a5
; HYBRID-ATOMICS-NEXT:    cgethigh a3, ca5
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB12_7
; HYBRID-ATOMICS-NEXT:  .LBB12_2: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # =>This Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    # Child Loop BB12_8 Depth 2
; HYBRID-ATOMICS-NEXT:    beq a3, a2, .LBB12_4
; HYBRID-ATOMICS-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-ATOMICS-NEXT:    sltu a5, a2, a3
; HYBRID-ATOMICS-NEXT:    j .LBB12_5
; HYBRID-ATOMICS-NEXT:  .LBB12_4: # in Loop: Header=BB12_2 Depth=1
; HYBRID-ATOMICS-NEXT:    sltu a5, a1, a4
; HYBRID-ATOMICS-NEXT:  .LBB12_5: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-ATOMICS-NEXT:    xori a6, a5, 1
; HYBRID-ATOMICS-NEXT:    mv a5, a3
; HYBRID-ATOMICS-NEXT:    mv a7, a4
; HYBRID-ATOMICS-NEXT:    bnez a6, .LBB12_1
; HYBRID-ATOMICS-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-ATOMICS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-ATOMICS-NEXT:    mv a5, a2
; HYBRID-ATOMICS-NEXT:    mv a7, a1
; HYBRID-ATOMICS-NEXT:    j .LBB12_1
; HYBRID-ATOMICS-NEXT:  .LBB12_7: # %atomicrmw.end
; HYBRID-ATOMICS-NEXT:    mv a0, a4
; HYBRID-ATOMICS-NEXT:    mv a1, a3
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: atomic_umin:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -48
; HYBRID-LIBCALLS-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s1, 24(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s2, 16(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    mv s0, a0
; HYBRID-LIBCALLS-NEXT:    ld a5, 8(a0)
; HYBRID-LIBCALLS-NEXT:    ld a4, 0(a0)
; HYBRID-LIBCALLS-NEXT:    mv s1, a2
; HYBRID-LIBCALLS-NEXT:    mv s2, a1
; HYBRID-LIBCALLS-NEXT:    j .LBB12_2
; HYBRID-LIBCALLS-NEXT:  .LBB12_1: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sd a4, 0(sp)
; HYBRID-LIBCALLS-NEXT:    sd a5, 8(sp)
; HYBRID-LIBCALLS-NEXT:    mv a1, sp
; HYBRID-LIBCALLS-NEXT:    li a4, 5
; HYBRID-LIBCALLS-NEXT:    li a5, 5
; HYBRID-LIBCALLS-NEXT:    mv a0, s0
; HYBRID-LIBCALLS-NEXT:    call __atomic_compare_exchange_16@plt
; HYBRID-LIBCALLS-NEXT:    ld a5, 8(sp)
; HYBRID-LIBCALLS-NEXT:    ld a4, 0(sp)
; HYBRID-LIBCALLS-NEXT:    bnez a0, .LBB12_7
; HYBRID-LIBCALLS-NEXT:  .LBB12_2: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-LIBCALLS-NEXT:    beq a5, s1, .LBB12_4
; HYBRID-LIBCALLS-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sltu a0, s1, a5
; HYBRID-LIBCALLS-NEXT:    j .LBB12_5
; HYBRID-LIBCALLS-NEXT:  .LBB12_4: # in Loop: Header=BB12_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    sltu a0, s2, a4
; HYBRID-LIBCALLS-NEXT:  .LBB12_5: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    xori a0, a0, 1
; HYBRID-LIBCALLS-NEXT:    mv a2, a4
; HYBRID-LIBCALLS-NEXT:    mv a3, a5
; HYBRID-LIBCALLS-NEXT:    bnez a0, .LBB12_1
; HYBRID-LIBCALLS-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-LIBCALLS-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-LIBCALLS-NEXT:    mv a2, s2
; HYBRID-LIBCALLS-NEXT:    mv a3, s1
; HYBRID-LIBCALLS-NEXT:    j .LBB12_1
; HYBRID-LIBCALLS-NEXT:  .LBB12_7: # %atomicrmw.end
; HYBRID-LIBCALLS-NEXT:    mv a0, a4
; HYBRID-LIBCALLS-NEXT:    mv a1, a5
; HYBRID-LIBCALLS-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s1, 24(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s2, 16(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 48
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: atomic_umin:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -64
; HYBRID-CAP-PTR-NEXT:    sd ra, 56(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s0, 48(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s1, 40(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    ld.cap a4, (ca0)
; HYBRID-CAP-PTR-NEXT:    sc ca0, 0(sp) # 16-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    cincoffset ca0, ca0, 8
; HYBRID-CAP-PTR-NEXT:    ld.cap a5, (ca0)
; HYBRID-CAP-PTR-NEXT:    mv s0, a2
; HYBRID-CAP-PTR-NEXT:    mv s1, a1
; HYBRID-CAP-PTR-NEXT:    j .LBB12_2
; HYBRID-CAP-PTR-NEXT:  .LBB12_1: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sd a4, 16(sp)
; HYBRID-CAP-PTR-NEXT:    sd a5, 24(sp)
; HYBRID-CAP-PTR-NEXT:    addi a1, sp, 16
; HYBRID-CAP-PTR-NEXT:    li a4, 5
; HYBRID-CAP-PTR-NEXT:    li a5, 5
; HYBRID-CAP-PTR-NEXT:    lc ca0, 0(sp) # 16-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    call __atomic_compare_exchange_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld a5, 24(sp)
; HYBRID-CAP-PTR-NEXT:    ld a4, 16(sp)
; HYBRID-CAP-PTR-NEXT:    bnez a0, .LBB12_7
; HYBRID-CAP-PTR-NEXT:  .LBB12_2: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # =>This Inner Loop Header: Depth=1
; HYBRID-CAP-PTR-NEXT:    beq a5, s0, .LBB12_4
; HYBRID-CAP-PTR-NEXT:  # %bb.3: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sltu a0, s0, a5
; HYBRID-CAP-PTR-NEXT:    j .LBB12_5
; HYBRID-CAP-PTR-NEXT:  .LBB12_4: # in Loop: Header=BB12_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    sltu a0, s1, a4
; HYBRID-CAP-PTR-NEXT:  .LBB12_5: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    xori a0, a0, 1
; HYBRID-CAP-PTR-NEXT:    mv a2, a4
; HYBRID-CAP-PTR-NEXT:    mv a3, a5
; HYBRID-CAP-PTR-NEXT:    bnez a0, .LBB12_1
; HYBRID-CAP-PTR-NEXT:  # %bb.6: # %atomicrmw.start
; HYBRID-CAP-PTR-NEXT:    # in Loop: Header=BB12_2 Depth=1
; HYBRID-CAP-PTR-NEXT:    mv a2, s1
; HYBRID-CAP-PTR-NEXT:    mv a3, s0
; HYBRID-CAP-PTR-NEXT:    j .LBB12_1
; HYBRID-CAP-PTR-NEXT:  .LBB12_7: # %atomicrmw.end
; HYBRID-CAP-PTR-NEXT:    mv a0, a4
; HYBRID-CAP-PTR-NEXT:    mv a1, a5
; HYBRID-CAP-PTR-NEXT:    ld ra, 56(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s0, 48(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s1, 40(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 64
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@atomic_umin
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; PURECAP-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; PURECAP-IR:       atomicrmw.start:
; PURECAP-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP1]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = icmp ule i128 [[LOADED]], [[VAL]]
; PURECAP-IR-NEXT:    [[NEW:%.*]] = select i1 [[TMP2]], i128 [[LOADED]], i128 [[VAL]]
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[LOADED]]
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = lshr i128 [[LOADED]], 64
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = trunc i128 [[TMP4]] to i64
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP3]], i64 [[TMP5]])
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = trunc i128 [[TMP8]] to i64
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP7]], i64 [[TMP9]])
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP6]], ptr addrspace(200) [[TMP10]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 0
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP11]], 1
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP12]])
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = zext i64 [[TMP14]] to i128
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = zext i64 [[TMP15]] to i128
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = shl i128 [[TMP17]], 64
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = or i128 [[TMP16]], [[TMP18]]
; PURECAP-IR-NEXT:    [[TMP20:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP19]], 0
; PURECAP-IR-NEXT:    [[TMP21:%.*]] = insertvalue { i128, i1 } [[TMP20]], i1 [[TMP13]], 1
; PURECAP-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP21]], 1
; PURECAP-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP21]], 0
; PURECAP-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; PURECAP-IR:       atomicrmw.end:
; PURECAP-IR-NEXT:    ret i128 [[NEWLOADED]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@atomic_umin
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[VAL:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = alloca i128, align 16
; HYBRID-IR-NEXT:    [[TMP2:%.*]] = load i128, ptr addrspace(200) [[PTR]], align 16
; HYBRID-IR-NEXT:    br label [[ATOMICRMW_START:%.*]]
; HYBRID-IR:       atomicrmw.start:
; HYBRID-IR-NEXT:    [[LOADED:%.*]] = phi i128 [ [[TMP2]], [[TMP0:%.*]] ], [ [[NEWLOADED:%.*]], [[ATOMICRMW_START]] ]
; HYBRID-IR-NEXT:    [[TMP3:%.*]] = icmp ule i128 [[LOADED]], [[VAL]]
; HYBRID-IR-NEXT:    [[NEW:%.*]] = select i1 [[TMP3]], i128 [[LOADED]], i128 [[VAL]]
; HYBRID-IR-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    store i128 [[LOADED]], ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    [[TMP4:%.*]] = call zeroext i1 @__atomic_compare_exchange_16_c(ptr addrspace(200) [[PTR]], ptr [[TMP1]], i128 [[NEW]], i32 5, i32 5)
; HYBRID-IR-NEXT:    [[TMP5:%.*]] = load i128, ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    [[TMP6:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP5]], 0
; HYBRID-IR-NEXT:    [[TMP7:%.*]] = insertvalue { i128, i1 } [[TMP6]], i1 [[TMP4]], 1
; HYBRID-IR-NEXT:    [[SUCCESS:%.*]] = extractvalue { i128, i1 } [[TMP7]], 1
; HYBRID-IR-NEXT:    [[NEWLOADED]] = extractvalue { i128, i1 } [[TMP7]], 0
; HYBRID-IR-NEXT:    br i1 [[SUCCESS]], label [[ATOMICRMW_END:%.*]], label [[ATOMICRMW_START]]
; HYBRID-IR:       atomicrmw.end:
; HYBRID-IR-NEXT:    ret i128 [[NEWLOADED]]
;
  %tmp = atomicrmw umin ptr addrspace(200) %ptr, i128 %val seq_cst
  ret i128 %tmp
}

define { i128, i1 } @cmpxchg_weak(ptr addrspace(200) %ptr, i128 %exp, i128 %new) nounwind {
; PURECAP-ATOMICS-LABEL: cmpxchg_weak:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cincoffset ca2, cnull, a2
; PURECAP-ATOMICS-NEXT:    csethigh ca2, ca2, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca3, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca3, a5
; PURECAP-ATOMICS-NEXT:  .LBB13_1: # =>This Inner Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    clr.c.aq ca4, (ca1)
; PURECAP-ATOMICS-NEXT:    cseqx a5, ca4, ca2
; PURECAP-ATOMICS-NEXT:    beqz a5, .LBB13_3
; PURECAP-ATOMICS-NEXT:  # %bb.2: # in Loop: Header=BB13_1 Depth=1
; PURECAP-ATOMICS-NEXT:    csc.c.aq a5, ca3, (ca1)
; PURECAP-ATOMICS-NEXT:    bnez a5, .LBB13_1
; PURECAP-ATOMICS-NEXT:  .LBB13_3:
; PURECAP-ATOMICS-NEXT:    cseqx a1, ca4, ca2
; PURECAP-ATOMICS-NEXT:    cgethigh a2, ca4
; PURECAP-ATOMICS-NEXT:    csd a2, 8(ca0)
; PURECAP-ATOMICS-NEXT:    csd a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:    csb a1, 16(ca0)
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: cmpxchg_weak:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -48
; PURECAP-LIBCALLS-NEXT:    csc cra, 32(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs0, 16(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    mv a6, a5
; PURECAP-LIBCALLS-NEXT:    mv a7, a4
; PURECAP-LIBCALLS-NEXT:    cmove ct0, ca1
; PURECAP-LIBCALLS-NEXT:    cmove cs0, ca0
; PURECAP-LIBCALLS-NEXT:    csd a3, 8(csp)
; PURECAP-LIBCALLS-NEXT:    csd a2, 0(csp)
; PURECAP-LIBCALLS-NEXT:    cincoffset ca0, csp, 0
; PURECAP-LIBCALLS-NEXT:    csetbounds ca1, ca0, 16
; PURECAP-LIBCALLS-NEXT:    li a4, 4
; PURECAP-LIBCALLS-NEXT:    li a5, 2
; PURECAP-LIBCALLS-NEXT:    cmove ca0, ct0
; PURECAP-LIBCALLS-NEXT:    mv a2, a7
; PURECAP-LIBCALLS-NEXT:    mv a3, a6
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_compare_exchange_16
; PURECAP-LIBCALLS-NEXT:    cld a1, 8(csp)
; PURECAP-LIBCALLS-NEXT:    cld a2, 0(csp)
; PURECAP-LIBCALLS-NEXT:    csd a1, 8(cs0)
; PURECAP-LIBCALLS-NEXT:    csd a2, 0(cs0)
; PURECAP-LIBCALLS-NEXT:    csb a0, 16(cs0)
; PURECAP-LIBCALLS-NEXT:    clc cra, 32(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs0, 16(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 48
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: cmpxchg_weak:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    cincoffset ca2, cnull, a2
; HYBRID-ATOMICS-NEXT:    csethigh ca2, ca2, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca3, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca3, a5
; HYBRID-ATOMICS-NEXT:  .LBB13_1: # =>This Inner Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    lr.c.aq ca4, (a1)
; HYBRID-ATOMICS-NEXT:    cseqx a5, ca4, ca2
; HYBRID-ATOMICS-NEXT:    beqz a5, .LBB13_3
; HYBRID-ATOMICS-NEXT:  # %bb.2: # in Loop: Header=BB13_1 Depth=1
; HYBRID-ATOMICS-NEXT:    sc.c.aq a5, ca3, (a1)
; HYBRID-ATOMICS-NEXT:    bnez a5, .LBB13_1
; HYBRID-ATOMICS-NEXT:  .LBB13_3:
; HYBRID-ATOMICS-NEXT:    cseqx a1, ca4, ca2
; HYBRID-ATOMICS-NEXT:    cgethigh a2, ca4
; HYBRID-ATOMICS-NEXT:    sd a2, 8(a0)
; HYBRID-ATOMICS-NEXT:    sd a4, 0(a0)
; HYBRID-ATOMICS-NEXT:    sb a1, 16(a0)
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: cmpxchg_weak:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -32
; HYBRID-LIBCALLS-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    mv a6, a5
; HYBRID-LIBCALLS-NEXT:    mv a7, a4
; HYBRID-LIBCALLS-NEXT:    mv t0, a1
; HYBRID-LIBCALLS-NEXT:    mv s0, a0
; HYBRID-LIBCALLS-NEXT:    sd a3, 8(sp)
; HYBRID-LIBCALLS-NEXT:    sd a2, 0(sp)
; HYBRID-LIBCALLS-NEXT:    mv a1, sp
; HYBRID-LIBCALLS-NEXT:    li a4, 4
; HYBRID-LIBCALLS-NEXT:    li a5, 2
; HYBRID-LIBCALLS-NEXT:    mv a0, t0
; HYBRID-LIBCALLS-NEXT:    mv a2, a7
; HYBRID-LIBCALLS-NEXT:    mv a3, a6
; HYBRID-LIBCALLS-NEXT:    call __atomic_compare_exchange_16@plt
; HYBRID-LIBCALLS-NEXT:    ld a1, 8(sp)
; HYBRID-LIBCALLS-NEXT:    ld a2, 0(sp)
; HYBRID-LIBCALLS-NEXT:    sd a1, 8(s0)
; HYBRID-LIBCALLS-NEXT:    sd a2, 0(s0)
; HYBRID-LIBCALLS-NEXT:    sb a0, 16(s0)
; HYBRID-LIBCALLS-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 32
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: cmpxchg_weak:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -32
; HYBRID-CAP-PTR-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    mv a6, a5
; HYBRID-CAP-PTR-NEXT:    mv a7, a4
; HYBRID-CAP-PTR-NEXT:    cmove ct0, ca1
; HYBRID-CAP-PTR-NEXT:    mv s0, a0
; HYBRID-CAP-PTR-NEXT:    sd a3, 8(sp)
; HYBRID-CAP-PTR-NEXT:    sd a2, 0(sp)
; HYBRID-CAP-PTR-NEXT:    mv a1, sp
; HYBRID-CAP-PTR-NEXT:    li a4, 4
; HYBRID-CAP-PTR-NEXT:    li a5, 2
; HYBRID-CAP-PTR-NEXT:    cmove ca0, ct0
; HYBRID-CAP-PTR-NEXT:    mv a2, a7
; HYBRID-CAP-PTR-NEXT:    mv a3, a6
; HYBRID-CAP-PTR-NEXT:    call __atomic_compare_exchange_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld a1, 8(sp)
; HYBRID-CAP-PTR-NEXT:    ld a2, 0(sp)
; HYBRID-CAP-PTR-NEXT:    sd a1, 8(s0)
; HYBRID-CAP-PTR-NEXT:    sd a2, 0(s0)
; HYBRID-CAP-PTR-NEXT:    sb a0, 16(s0)
; HYBRID-CAP-PTR-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 32
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@cmpxchg_weak
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[EXP:%.*]], i128 [[NEW:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[EXP]]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = lshr i128 [[EXP]], 64
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = trunc i128 [[TMP2]] to i64
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP1]], i64 [[TMP3]])
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = trunc i128 [[TMP6]] to i64
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP5]], i64 [[TMP7]])
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = cmpxchg weak exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP4]], ptr addrspace(200) [[TMP8]] acq_rel acquire, align 16
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP9]], 0
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP9]], 1
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP10]])
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP10]])
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = zext i64 [[TMP12]] to i128
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = zext i64 [[TMP13]] to i128
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = shl i128 [[TMP15]], 64
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = or i128 [[TMP14]], [[TMP16]]
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP17]], 0
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = insertvalue { i128, i1 } [[TMP18]], i1 [[TMP11]], 1
; PURECAP-IR-NEXT:    ret { i128, i1 } [[TMP19]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@cmpxchg_weak
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[EXP:%.*]], i128 [[NEW:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = alloca i128, align 16
; HYBRID-IR-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    store i128 [[EXP]], ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    [[TMP2:%.*]] = call zeroext i1 @__atomic_compare_exchange_16_c(ptr addrspace(200) [[PTR]], ptr [[TMP1]], i128 [[NEW]], i32 4, i32 2)
; HYBRID-IR-NEXT:    [[TMP3:%.*]] = load i128, ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    [[TMP4:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP3]], 0
; HYBRID-IR-NEXT:    [[TMP5:%.*]] = insertvalue { i128, i1 } [[TMP4]], i1 [[TMP2]], 1
; HYBRID-IR-NEXT:    ret { i128, i1 } [[TMP5]]
;
  %1 = cmpxchg weak ptr addrspace(200) %ptr, i128 %exp, i128 %new acq_rel acquire
  ret { i128, i1 } %1
}

define { i128, i1 } @cmpxchg_strong(ptr addrspace(200) %ptr, i128 %exp, i128 %new) nounwind {
; PURECAP-ATOMICS-LABEL: cmpxchg_strong:
; PURECAP-ATOMICS:       # %bb.0:
; PURECAP-ATOMICS-NEXT:    cincoffset ca2, cnull, a2
; PURECAP-ATOMICS-NEXT:    csethigh ca2, ca2, a3
; PURECAP-ATOMICS-NEXT:    cincoffset ca3, cnull, a4
; PURECAP-ATOMICS-NEXT:    csethigh ca3, ca3, a5
; PURECAP-ATOMICS-NEXT:  .LBB14_1: # =>This Inner Loop Header: Depth=1
; PURECAP-ATOMICS-NEXT:    clr.c.aqrl ca4, (ca1)
; PURECAP-ATOMICS-NEXT:    cseqx a5, ca4, ca2
; PURECAP-ATOMICS-NEXT:    beqz a5, .LBB14_3
; PURECAP-ATOMICS-NEXT:  # %bb.2: # in Loop: Header=BB14_1 Depth=1
; PURECAP-ATOMICS-NEXT:    csc.c.aqrl a5, ca3, (ca1)
; PURECAP-ATOMICS-NEXT:    bnez a5, .LBB14_1
; PURECAP-ATOMICS-NEXT:  .LBB14_3:
; PURECAP-ATOMICS-NEXT:    cseqx a1, ca4, ca2
; PURECAP-ATOMICS-NEXT:    cgethigh a2, ca4
; PURECAP-ATOMICS-NEXT:    csd a2, 8(ca0)
; PURECAP-ATOMICS-NEXT:    csd a4, 0(ca0)
; PURECAP-ATOMICS-NEXT:    csb a1, 16(ca0)
; PURECAP-ATOMICS-NEXT:    cret
;
; PURECAP-LIBCALLS-LABEL: cmpxchg_strong:
; PURECAP-LIBCALLS:       # %bb.0:
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, -48
; PURECAP-LIBCALLS-NEXT:    csc cra, 32(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    csc cs0, 16(csp) # 16-byte Folded Spill
; PURECAP-LIBCALLS-NEXT:    mv a6, a5
; PURECAP-LIBCALLS-NEXT:    mv a7, a4
; PURECAP-LIBCALLS-NEXT:    cmove ct0, ca1
; PURECAP-LIBCALLS-NEXT:    cmove cs0, ca0
; PURECAP-LIBCALLS-NEXT:    csd a3, 8(csp)
; PURECAP-LIBCALLS-NEXT:    csd a2, 0(csp)
; PURECAP-LIBCALLS-NEXT:    cincoffset ca0, csp, 0
; PURECAP-LIBCALLS-NEXT:    csetbounds ca1, ca0, 16
; PURECAP-LIBCALLS-NEXT:    li a4, 5
; PURECAP-LIBCALLS-NEXT:    li a5, 5
; PURECAP-LIBCALLS-NEXT:    cmove ca0, ct0
; PURECAP-LIBCALLS-NEXT:    mv a2, a7
; PURECAP-LIBCALLS-NEXT:    mv a3, a6
; PURECAP-LIBCALLS-NEXT:    ccall __atomic_compare_exchange_16
; PURECAP-LIBCALLS-NEXT:    cld a1, 8(csp)
; PURECAP-LIBCALLS-NEXT:    cld a2, 0(csp)
; PURECAP-LIBCALLS-NEXT:    csd a1, 8(cs0)
; PURECAP-LIBCALLS-NEXT:    csd a2, 0(cs0)
; PURECAP-LIBCALLS-NEXT:    csb a0, 16(cs0)
; PURECAP-LIBCALLS-NEXT:    clc cra, 32(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    clc cs0, 16(csp) # 16-byte Folded Reload
; PURECAP-LIBCALLS-NEXT:    cincoffset csp, csp, 48
; PURECAP-LIBCALLS-NEXT:    cret
;
; HYBRID-ATOMICS-LABEL: cmpxchg_strong:
; HYBRID-ATOMICS:       # %bb.0:
; HYBRID-ATOMICS-NEXT:    cincoffset ca2, cnull, a2
; HYBRID-ATOMICS-NEXT:    csethigh ca2, ca2, a3
; HYBRID-ATOMICS-NEXT:    cincoffset ca3, cnull, a4
; HYBRID-ATOMICS-NEXT:    csethigh ca3, ca3, a5
; HYBRID-ATOMICS-NEXT:  .LBB14_1: # =>This Inner Loop Header: Depth=1
; HYBRID-ATOMICS-NEXT:    lr.c.aqrl ca4, (a1)
; HYBRID-ATOMICS-NEXT:    cseqx a5, ca4, ca2
; HYBRID-ATOMICS-NEXT:    beqz a5, .LBB14_3
; HYBRID-ATOMICS-NEXT:  # %bb.2: # in Loop: Header=BB14_1 Depth=1
; HYBRID-ATOMICS-NEXT:    sc.c.aqrl a5, ca3, (a1)
; HYBRID-ATOMICS-NEXT:    bnez a5, .LBB14_1
; HYBRID-ATOMICS-NEXT:  .LBB14_3:
; HYBRID-ATOMICS-NEXT:    cseqx a1, ca4, ca2
; HYBRID-ATOMICS-NEXT:    cgethigh a2, ca4
; HYBRID-ATOMICS-NEXT:    sd a2, 8(a0)
; HYBRID-ATOMICS-NEXT:    sd a4, 0(a0)
; HYBRID-ATOMICS-NEXT:    sb a1, 16(a0)
; HYBRID-ATOMICS-NEXT:    ret
;
; HYBRID-LIBCALLS-LABEL: cmpxchg_strong:
; HYBRID-LIBCALLS:       # %bb.0:
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, -32
; HYBRID-LIBCALLS-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; HYBRID-LIBCALLS-NEXT:    mv a6, a5
; HYBRID-LIBCALLS-NEXT:    mv a7, a4
; HYBRID-LIBCALLS-NEXT:    mv t0, a1
; HYBRID-LIBCALLS-NEXT:    mv s0, a0
; HYBRID-LIBCALLS-NEXT:    sd a3, 8(sp)
; HYBRID-LIBCALLS-NEXT:    sd a2, 0(sp)
; HYBRID-LIBCALLS-NEXT:    mv a1, sp
; HYBRID-LIBCALLS-NEXT:    li a4, 5
; HYBRID-LIBCALLS-NEXT:    li a5, 5
; HYBRID-LIBCALLS-NEXT:    mv a0, t0
; HYBRID-LIBCALLS-NEXT:    mv a2, a7
; HYBRID-LIBCALLS-NEXT:    mv a3, a6
; HYBRID-LIBCALLS-NEXT:    call __atomic_compare_exchange_16@plt
; HYBRID-LIBCALLS-NEXT:    ld a1, 8(sp)
; HYBRID-LIBCALLS-NEXT:    ld a2, 0(sp)
; HYBRID-LIBCALLS-NEXT:    sd a1, 8(s0)
; HYBRID-LIBCALLS-NEXT:    sd a2, 0(s0)
; HYBRID-LIBCALLS-NEXT:    sb a0, 16(s0)
; HYBRID-LIBCALLS-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; HYBRID-LIBCALLS-NEXT:    addi sp, sp, 32
; HYBRID-LIBCALLS-NEXT:    ret
;
; HYBRID-CAP-PTR-LABEL: cmpxchg_strong:
; HYBRID-CAP-PTR:       # %bb.0:
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, -32
; HYBRID-CAP-PTR-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
; HYBRID-CAP-PTR-NEXT:    mv a6, a5
; HYBRID-CAP-PTR-NEXT:    mv a7, a4
; HYBRID-CAP-PTR-NEXT:    cmove ct0, ca1
; HYBRID-CAP-PTR-NEXT:    mv s0, a0
; HYBRID-CAP-PTR-NEXT:    sd a3, 8(sp)
; HYBRID-CAP-PTR-NEXT:    sd a2, 0(sp)
; HYBRID-CAP-PTR-NEXT:    mv a1, sp
; HYBRID-CAP-PTR-NEXT:    li a4, 5
; HYBRID-CAP-PTR-NEXT:    li a5, 5
; HYBRID-CAP-PTR-NEXT:    cmove ca0, ct0
; HYBRID-CAP-PTR-NEXT:    mv a2, a7
; HYBRID-CAP-PTR-NEXT:    mv a3, a6
; HYBRID-CAP-PTR-NEXT:    call __atomic_compare_exchange_16_c@plt
; HYBRID-CAP-PTR-NEXT:    ld a1, 8(sp)
; HYBRID-CAP-PTR-NEXT:    ld a2, 0(sp)
; HYBRID-CAP-PTR-NEXT:    sd a1, 8(s0)
; HYBRID-CAP-PTR-NEXT:    sd a2, 0(s0)
; HYBRID-CAP-PTR-NEXT:    sb a0, 16(s0)
; HYBRID-CAP-PTR-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
; HYBRID-CAP-PTR-NEXT:    addi sp, sp, 32
; HYBRID-CAP-PTR-NEXT:    ret
; PURECAP-IR-LABEL: define {{[^@]+}}@cmpxchg_strong
; PURECAP-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[EXP:%.*]], i128 [[NEW:%.*]]) addrspace(200) #[[ATTR0]] {
; PURECAP-IR-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[EXP]]
; PURECAP-IR-NEXT:    [[TMP2:%.*]] = lshr i128 [[EXP]], 64
; PURECAP-IR-NEXT:    [[TMP3:%.*]] = trunc i128 [[TMP2]] to i64
; PURECAP-IR-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP1]], i64 [[TMP3]])
; PURECAP-IR-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr addrspace(200) null, i128 [[NEW]]
; PURECAP-IR-NEXT:    [[TMP6:%.*]] = lshr i128 [[NEW]], 64
; PURECAP-IR-NEXT:    [[TMP7:%.*]] = trunc i128 [[TMP6]] to i64
; PURECAP-IR-NEXT:    [[TMP8:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.high.set.i64(ptr addrspace(200) [[TMP5]], i64 [[TMP7]])
; PURECAP-IR-NEXT:    [[TMP9:%.*]] = cmpxchg exact ptr addrspace(200) [[PTR]], ptr addrspace(200) [[TMP4]], ptr addrspace(200) [[TMP8]] seq_cst seq_cst, align 16
; PURECAP-IR-NEXT:    [[TMP10:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP9]], 0
; PURECAP-IR-NEXT:    [[TMP11:%.*]] = extractvalue { ptr addrspace(200), i1 } [[TMP9]], 1
; PURECAP-IR-NEXT:    [[TMP12:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP10]])
; PURECAP-IR-NEXT:    [[TMP13:%.*]] = call i64 @llvm.cheri.cap.high.get.i64(ptr addrspace(200) [[TMP10]])
; PURECAP-IR-NEXT:    [[TMP14:%.*]] = zext i64 [[TMP12]] to i128
; PURECAP-IR-NEXT:    [[TMP15:%.*]] = zext i64 [[TMP13]] to i128
; PURECAP-IR-NEXT:    [[TMP16:%.*]] = shl i128 [[TMP15]], 64
; PURECAP-IR-NEXT:    [[TMP17:%.*]] = or i128 [[TMP14]], [[TMP16]]
; PURECAP-IR-NEXT:    [[TMP18:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP17]], 0
; PURECAP-IR-NEXT:    [[TMP19:%.*]] = insertvalue { i128, i1 } [[TMP18]], i1 [[TMP11]], 1
; PURECAP-IR-NEXT:    ret { i128, i1 } [[TMP19]]
;
; HYBRID-IR-LABEL: define {{[^@]+}}@cmpxchg_strong
; HYBRID-IR-SAME: (ptr addrspace(200) [[PTR:%.*]], i128 [[EXP:%.*]], i128 [[NEW:%.*]]) #[[ATTR0]] {
; HYBRID-IR-NEXT:    [[TMP1:%.*]] = alloca i128, align 16
; HYBRID-IR-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    store i128 [[EXP]], ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    [[TMP2:%.*]] = call zeroext i1 @__atomic_compare_exchange_16_c(ptr addrspace(200) [[PTR]], ptr [[TMP1]], i128 [[NEW]], i32 5, i32 5)
; HYBRID-IR-NEXT:    [[TMP3:%.*]] = load i128, ptr [[TMP1]], align 16
; HYBRID-IR-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[TMP1]])
; HYBRID-IR-NEXT:    [[TMP4:%.*]] = insertvalue { i128, i1 } undef, i128 [[TMP3]], 0
; HYBRID-IR-NEXT:    [[TMP5:%.*]] = insertvalue { i128, i1 } [[TMP4]], i1 [[TMP2]], 1
; HYBRID-IR-NEXT:    ret { i128, i1 } [[TMP5]]
;
  %1 = cmpxchg ptr addrspace(200) %ptr, i128 %exp, i128 %new seq_cst seq_cst
  ret { i128, i1 } %1
}
