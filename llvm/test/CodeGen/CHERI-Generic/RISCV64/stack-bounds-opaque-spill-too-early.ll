; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes
; DO NOT EDIT -- This file was generated from test/CodeGen/CHERI-Generic/Inputs/stack-bounds-opaque-spill-too-early.ll
;; After merging to LLVM 15 the stack bounds pass the switch to opqaue pointers caused
;; miscompilations in the stack bounding pass (the unbounded value was used instead of
;; the bounded one due to the removal of the bitcast instructions).
; REQUIRES: asserts
; RUN: opt -mtriple=riscv64 --relocation-model=pic -target-abi l64pc128d -mattr=+xcheri,+cap-mode,+f,+d -cheri-bound-allocas -o - -S %s -debug-only=cheri-bound-allocas 2>%t.dbg| FileCheck %s
; RUN: FileCheck %s -input-file=%t.dbg -check-prefix DBG
; RUN: llc -mtriple=riscv64 --relocation-model=pic -target-abi l64pc128d -mattr=+xcheri,+cap-mode,+f,+d %s -o - | FileCheck %s -check-prefix ASM
target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200"

; DBG-LABEL: Checking function lazy_bind_args
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   %0 = load ptr addrspace(200), ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=16, alloca size=16, current GEP offset=0 for ptr addrspace(200)
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   %0 = load ptr addrspace(200), ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:  -Adding stack bounds since it is passed to call:   %call = call ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef nonnull %cap)
; DBG-NEXT: cheri-bound-allocas: Found alloca use that needs bounds:   %call = call ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef nonnull %cap)
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:   -Load/store size=16, alloca size=16, current GEP offset=0 for ptr addrspace(200)
; DBG-NEXT: cheri-bound-allocas:   -Load/store is in bounds -> can reuse $csp for   store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:  -Checking if load/store needs bounds (GEP offset is 0):   store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:   -Stack slot used as value and not pointer -> must set bounds
; DBG-NEXT: cheri-bound-allocas: Found alloca use that needs bounds: store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
; DBG-NEXT: cheri-bound-allocas:  -No need for stack bounds for lifetime_{start,end}:   call void @llvm.lifetime.start.p200(i64 16, ptr addrspace(200) nonnull %cap)
; DBG-NEXT: cheri-bound-allocas: lazy_bind_args: 2 of 5 users need bounds for   %cap = alloca ptr addrspace(200), align 16, addrspace(200)
; DBG-NEXT: lazy_bind_args: setting bounds on stack alloca to 16  %cap = alloca ptr addrspace(200), align 16, addrspace(200)

declare void @llvm.lifetime.start.p200(i64 immarg, ptr addrspace(200) nocapture) addrspace(200)

declare ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef) addrspace(200)

declare void @cheribsdtest_check_cap_eq(ptr addrspace(200) noundef, ptr addrspace(200) noundef) addrspace(200)

define dso_local void @lazy_bind_args() addrspace(200) nounwind {
; ASM-LABEL: lazy_bind_args:
; ASM:       # %bb.0: # %entry
; ASM-NEXT:    cincoffset csp, csp, -32
; ASM-NEXT:    csc cra, 16(csp) # 16-byte Folded Spill
; ASM-NEXT:    cincoffset ca0, csp, 0
; ASM-NEXT:    csetbounds ca0, ca0, 16
; ASM-NEXT:    csc ca0, 0(csp)
; ASM-NEXT:    ccall cheribsdtest_dynamic_identity_cap
; ASM-NEXT:    clc ca1, 0(csp)
; ASM-NEXT:    cmove ca2, ca0
; ASM-NEXT:    cmove ca0, ca1
; ASM-NEXT:    cmove ca1, ca2
; ASM-NEXT:    ccall cheribsdtest_check_cap_eq
; ASM-NEXT:    clc cra, 16(csp) # 16-byte Folded Reload
; ASM-NEXT:    cincoffset csp, csp, 32
; ASM-NEXT:    cret
; CHECK-LABEL: define {{[^@]+}}@lazy_bind_args
; CHECK-SAME: () addrspace(200) #[[ATTR2:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[CAP:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
; CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 16, ptr addrspace(200) nonnull [[CAP]])
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[CAP]], i64 16)
; CHECK-NEXT:    store ptr addrspace(200) [[TMP0]], ptr addrspace(200) [[CAP]], align 16
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[CAP]], i64 16)
; CHECK-NEXT:    [[CALL:%.*]] = call ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef nonnull [[TMP1]])
; CHECK-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[CAP]], align 16
; CHECK-NEXT:    call void @cheribsdtest_check_cap_eq(ptr addrspace(200) noundef [[TMP2]], ptr addrspace(200) noundef [[CALL]])
; CHECK-NEXT:    ret void
;
entry:
  %cap = alloca ptr addrspace(200), align 16, addrspace(200)
  call void @llvm.lifetime.start.p200(i64 16, ptr addrspace(200) nonnull %cap)
  store ptr addrspace(200) %cap, ptr addrspace(200) %cap, align 16
  %call = call ptr addrspace(200) @cheribsdtest_dynamic_identity_cap(ptr addrspace(200) noundef nonnull %cap)
  %0 = load ptr addrspace(200), ptr addrspace(200) %cap, align 16
  call void @cheribsdtest_check_cap_eq(ptr addrspace(200) noundef %0, ptr addrspace(200) noundef %call)
  ret void
}
