; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;; Check that we do not emit CToPtr in ISAv9 hybrid mode. Since there is no DDC
;; offsetting, hybrid mode can expand ptrtoint to to a branchless version of
;; `x.tag ? x.addr : 0`
; RUN: %riscv64_cheri_purecap_llc -mattr=+xcheri-v9-semantics < %s | FileCheck %s --check-prefix=PURECAP
; RUN: %riscv64_cheri_llc -mattr=+xcheri-v9-semantics < %s | FileCheck %s --check-prefix=HYBRID
;; Also emit a .o file since verifyInstructionPredicates() is only called for binary output.
; RUN: %riscv64_cheri_purecap_llc -mattr=+xcheri-v9-semantics -filetype=obj -o /dev/null < %s
; RUN: %riscv64_cheri_llc -mattr=+xcheri-v9-semantics -filetype=obj -o /dev/null < %s

define dso_local i64 @ptrtoint(i8 addrspace(200)* %cap) addrspace(200) nounwind {
; PURECAP-LABEL: ptrtoint:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    mv a0, a0
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: ptrtoint:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cgettag a1, ca0
; HYBRID-NEXT:    neg a1, a1
; HYBRID-NEXT:    and a0, a0, a1
; HYBRID-NEXT:    ret
  %ret = ptrtoint i8 addrspace(200)* %cap to i64
  ret i64 %ret
}

define dso_local i64 @ptrtoint_plus_const(i8 addrspace(200)* %cap) addrspace(200) nounwind {
; PURECAP-LABEL: ptrtoint_plus_const:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    addi a0, a0, 2
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: ptrtoint_plus_const:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cgettag a1, ca0
; HYBRID-NEXT:    neg a1, a1
; HYBRID-NEXT:    and a0, a0, a1
; HYBRID-NEXT:    addi a0, a0, 2
; HYBRID-NEXT:    ret
  %zero = ptrtoint i8 addrspace(200)* %cap to i64
  %ret = add i64 %zero, 2
  ret i64 %ret
}

define dso_local i64 @ptrtoint_plus_var(i8 addrspace(200)* %cap, i64 %add) addrspace(200) nounwind {
; PURECAP-LABEL: ptrtoint_plus_var:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    add a0, a0, a1
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: ptrtoint_plus_var:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cgettag a2, ca0
; HYBRID-NEXT:    neg a2, a2
; HYBRID-NEXT:    and a0, a0, a2
; HYBRID-NEXT:    add a0, a0, a1
; HYBRID-NEXT:    ret
  %zero = ptrtoint i8 addrspace(200)* %cap to i64
  %ret = add i64 %zero, %add
  ret i64 %ret
}

define dso_local i64 @ptrtoint_null() addrspace(200) nounwind {
; PURECAP-LABEL: ptrtoint_null:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    li a0, 0
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: ptrtoint_null:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cgettag a0, cnull
; HYBRID-NEXT:    neg a0, a0
; HYBRID-NEXT:    and a0, zero, a0
; HYBRID-NEXT:    ret
  %ret = ptrtoint i8 addrspace(200)* null to i64
  ret i64 %ret
}

define dso_local i64 @ptrtoint_null_plus_const() addrspace(200) nounwind {
; PURECAP-LABEL: ptrtoint_null_plus_const:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    li a0, 2
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: ptrtoint_null_plus_const:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cgettag a0, cnull
; HYBRID-NEXT:    neg a0, a0
; HYBRID-NEXT:    and a0, zero, a0
; HYBRID-NEXT:    addi a0, a0, 2
; HYBRID-NEXT:    ret
  %zero = ptrtoint i8 addrspace(200)* null to i64
  %ret = add i64 %zero, 2
  ret i64 %ret
}

define dso_local i64 @ptrtoint_null_plus_var(i64 %add) addrspace(200) nounwind {
; PURECAP-LABEL: ptrtoint_null_plus_var:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    add a0, zero, a0
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: ptrtoint_null_plus_var:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cgettag a1, cnull
; HYBRID-NEXT:    neg a1, a1
; HYBRID-NEXT:    and a1, zero, a1
; HYBRID-NEXT:    add a0, a1, a0
; HYBRID-NEXT:    ret
  %zero = ptrtoint i8 addrspace(200)* null to i64
  %ret = add i64 %zero, %add
  ret i64 %ret
}
