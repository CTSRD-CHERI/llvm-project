; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %riscv32_cheri_llc -verify-machineinstrs < %s | FileCheck --check-prefix=CHECK-ILP32 %s
; RUN: %riscv64_cheri_llc -verify-machineinstrs < %s | FileCheck --check-prefix=CHECK-LP64 %s
; RUN: %riscv32_cheri_purecap_llc -verify-machineinstrs < %s | FileCheck --check-prefix=CHECK-IL32PC64 %s
; RUN: %riscv64_cheri_purecap_llc -verify-machineinstrs < %s | FileCheck --check-prefix=CHECK-L64PC128 %s

define void @callee_cap_int(i8 addrspace(200)* %cap, i8 %int) nounwind {
; CHECK-ILP32-LABEL: callee_cap_int:
; CHECK-ILP32:       # %bb.0:
; CHECK-ILP32-NEXT:    sb.cap a1, (ca0)
; CHECK-ILP32-NEXT:    ret
;
; CHECK-LP64-LABEL: callee_cap_int:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sb.cap a1, (ca0)
; CHECK-LP64-NEXT:    ret
;
; CHECK-IL32PC64-LABEL: callee_cap_int:
; CHECK-IL32PC64:       # %bb.0:
; CHECK-IL32PC64-NEXT:    sb a1, 0(ca0)
; CHECK-IL32PC64-NEXT:    ret
;
; CHECK-L64PC128-LABEL: callee_cap_int:
; CHECK-L64PC128:       # %bb.0:
; CHECK-L64PC128-NEXT:    sb a1, 0(ca0)
; CHECK-L64PC128-NEXT:    ret
  store i8 %int, i8 addrspace(200)* %cap
  ret void
}

define void @callee_int_cap(i8 %int, i8 addrspace(200)* %cap) nounwind {
; CHECK-ILP32-LABEL: callee_int_cap:
; CHECK-ILP32:       # %bb.0:
; CHECK-ILP32-NEXT:    sb.cap a0, (ca1)
; CHECK-ILP32-NEXT:    ret
;
; CHECK-LP64-LABEL: callee_int_cap:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    sb.cap a0, (ca1)
; CHECK-LP64-NEXT:    ret
;
; CHECK-IL32PC64-LABEL: callee_int_cap:
; CHECK-IL32PC64:       # %bb.0:
; CHECK-IL32PC64-NEXT:    sb a0, 0(ca1)
; CHECK-IL32PC64-NEXT:    ret
;
; CHECK-L64PC128-LABEL: callee_int_cap:
; CHECK-L64PC128:       # %bb.0:
; CHECK-L64PC128-NEXT:    sb a0, 0(ca1)
; CHECK-L64PC128-NEXT:    ret
  store i8 %int, i8 addrspace(200)* %cap
  ret void
}

define void @callee_cap_cap_int(i8 addrspace(200)* %dst, i8 addrspace(200)* %src, i32 signext %offset) nounwind {
; CHECK-ILP32-LABEL: callee_cap_cap_int:
; CHECK-ILP32:       # %bb.0:
; CHECK-ILP32-NEXT:    cincoffset ca1, ca1, a2
; CHECK-ILP32-NEXT:    lb.cap a1, (ca1)
; CHECK-ILP32-NEXT:    cincoffset ca0, ca0, a2
; CHECK-ILP32-NEXT:    sb.cap a1, (ca0)
; CHECK-ILP32-NEXT:    ret
;
; CHECK-LP64-LABEL: callee_cap_cap_int:
; CHECK-LP64:       # %bb.0:
; CHECK-LP64-NEXT:    cincoffset ca1, ca1, a2
; CHECK-LP64-NEXT:    lb.cap a1, (ca1)
; CHECK-LP64-NEXT:    cincoffset ca0, ca0, a2
; CHECK-LP64-NEXT:    sb.cap a1, (ca0)
; CHECK-LP64-NEXT:    ret
;
; CHECK-IL32PC64-LABEL: callee_cap_cap_int:
; CHECK-IL32PC64:       # %bb.0:
; CHECK-IL32PC64-NEXT:    cincoffset ca1, ca1, a2
; CHECK-IL32PC64-NEXT:    lb a1, 0(ca1)
; CHECK-IL32PC64-NEXT:    cincoffset ca0, ca0, a2
; CHECK-IL32PC64-NEXT:    sb a1, 0(ca0)
; CHECK-IL32PC64-NEXT:    ret
;
; CHECK-L64PC128-LABEL: callee_cap_cap_int:
; CHECK-L64PC128:       # %bb.0:
; CHECK-L64PC128-NEXT:    cincoffset ca1, ca1, a2
; CHECK-L64PC128-NEXT:    lb a1, 0(ca1)
; CHECK-L64PC128-NEXT:    cincoffset ca0, ca0, a2
; CHECK-L64PC128-NEXT:    sb a1, 0(ca0)
; CHECK-L64PC128-NEXT:    ret
  %srcoff = getelementptr inbounds i8, i8 addrspace(200)* %src, i32 %offset
  %val = load i8, i8 addrspace(200)* %srcoff
  %dstoff = getelementptr inbounds i8, i8 addrspace(200)* %dst, i32 %offset
  store i8 %val, i8 addrspace(200)* %dstoff
  ret void
}
