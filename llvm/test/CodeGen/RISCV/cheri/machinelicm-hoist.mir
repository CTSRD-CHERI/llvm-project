# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# Check that MachineLICM doesn't hoist a instructions that could potentially trap but are not guaranteed to execute
# FIXME: this is a baseline test showing the current incorrect behaviour
# See also llvm/test/CodeGen/MIPS/machinelicm-hoist.mir for CHERI-MIPS
# See https://github.com/CTSRD-CHERI/llvm-project/issues/348 and https://github.com/CTSRD-CHERI/llvm-project/issues/359
# RUN: %riscv64_cheri_purecap_llc -o - %s -run-pass=early-machinelicm -avoid-speculation=false -hoist-cheap-insts -machinelicm-ignore-reg-pressure | FileCheck %s
--- |
  ; ModuleID = '/Users/alex/cheri/llvm-project/llvm/test/CodeGen/CHERI-Generic/test.ll'
  source_filename = "/Users/alex/cheri/llvm-project/llvm/test/CodeGen/CHERI-Generic/test.ll"
  target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200"
  target triple = "riscv64-unknown-freebsd"

  %struct.foo = type { i32, i32 }

  ; Function Attrs: nounwind
  define dso_local void @hoist_csetbounds(i64 %arg, %struct.foo addrspace(200)* %f, %struct.foo addrspace(200)* %f2) local_unnamed_addr addrspace(200) #0 {
  entry:
    br label %for.body

  for.cond.cleanup:                                 ; preds = %for.inc
    ret void

  for.body:                                         ; preds = %for.inc, %entry
    br i1 undef, label %for.inc, label %if.then

  if.then:                                          ; preds = %for.body
    br label %for.inc

  for.inc:                                          ; preds = %if.then, %for.body
    br i1 undef, label %for.body, label %for.cond.cleanup
  }

  attributes #0 = { nounwind }
  attributes #1 = { nounwind readnone willreturn }

...
---
name:            hoist_csetbounds
alignment:       4
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
registers:
  - { id: 0, class: gpr, preferred-register: '' }
  - { id: 1, class: gpcr, preferred-register: '' }
  - { id: 2, class: gpcr, preferred-register: '' }
liveins:
  - { reg: '$x10', virtual-reg: '%0' }
  - { reg: '$c11', virtual-reg: '%1' }
  - { reg: '$c11', virtual-reg: '%2' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    1
  adjustsStack:    false
  hasCalls:        true
  stackProtector:  ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:           []
callSites:       []
constants:       []
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: hoist_csetbounds
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $x10, $c11, $c12
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr = COPY $x10
  ; CHECK-NEXT:   [[COPY1:%[0-9]+]]:gpcr = COPY $c11
  ; CHECK-NEXT:   [[COPY2:%[0-9]+]]:gpcr = COPY $c12
  ; CHECK-NEXT:   [[COPY3:%[0-9]+]]:gpcrc0isddc = COPY $c12
  ; CHECK-NEXT:   [[CIncOffsetImm:%[0-9]+]]:gpcr = CIncOffsetImm [[COPY1]], 4
  ; CHECK-NEXT:   [[CAndPerm:%[0-9]+]]:gpcr = CAndPerm [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CGetPerm:%[0-9]+]]:gpr = CGetPerm [[COPY2]]
  ; CHECK-NEXT:   [[CGetType:%[0-9]+]]:gpr = CGetType [[COPY2]]
  ; CHECK-NEXT:   [[CGetBase:%[0-9]+]]:gpr = CGetBase [[COPY2]]
  ; CHECK-NEXT:   [[CGetLen:%[0-9]+]]:gpr = CGetLen [[COPY2]]
  ; CHECK-NEXT:   [[CGetTag:%[0-9]+]]:gpr = CGetTag [[COPY2]]
  ; CHECK-NEXT:   [[CGetSealed:%[0-9]+]]:gpr = CGetSealed [[COPY2]]
  ; CHECK-NEXT:   [[CGetOffset:%[0-9]+]]:gpr = CGetOffset [[COPY2]]
  ; CHECK-NEXT:   [[CGetAddr:%[0-9]+]]:gpr = CGetAddr [[COPY2]]
  ; CHECK-NEXT:   [[CClearTag:%[0-9]+]]:gpcr = CClearTag [[COPY1]]
  ; CHECK-NEXT:   [[CSub:%[0-9]+]]:gpr = CSub [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CMove:%[0-9]+]]:gpcr = CMove [[COPY1]]
  ; CHECK-NEXT:   [[CTestSubset:%[0-9]+]]:gpr = CTestSubset [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CRRL:%[0-9]+]]:gpr = CRRL [[COPY]]
  ; CHECK-NEXT:   [[CRAM:%[0-9]+]]:gpr = CRAM [[COPY]]
  ; CHECK-NEXT:   PseudoBR %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.for.cond.cleanup:
  ; CHECK-NEXT:   PseudoCapRET
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.for.body:
  ; CHECK-NEXT:   successors: %bb.4(0x30000000), %bb.3(0x50000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BNE [[COPY]], $x0, %bb.4
  ; CHECK-NEXT:   PseudoBR %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.if.then:
  ; CHECK-NEXT:   successors: %bb.4(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[CSeal:%[0-9]+]]:gpcr = CSeal [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CUnseal:%[0-9]+]]:gpcr = CUnseal [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CAndPerm1:%[0-9]+]]:gpcr = CAndPerm [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetFlags:%[0-9]+]]:gpcr = CSetFlags [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetOffset:%[0-9]+]]:gpcr = CSetOffset [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetAddr:%[0-9]+]]:gpcr = CSetAddr [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffset:%[0-9]+]]:gpcr = CIncOffset [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CIncOffsetImm1:%[0-9]+]]:gpcr = CIncOffsetImm [[COPY1]], 10
  ; CHECK-NEXT:   [[CSetBounds:%[0-9]+]]:gpcr = CSetBounds [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsExact:%[0-9]+]]:gpcr = CSetBoundsExact [[COPY1]], [[COPY]]
  ; CHECK-NEXT:   [[CSetBoundsImm:%[0-9]+]]:gpcr = CSetBoundsImm [[COPY1]], 10
  ; CHECK-NEXT:   [[CBuildCap:%[0-9]+]]:gpcr = CBuildCap [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CCopyType:%[0-9]+]]:gpcr = CCopyType [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CCSeal:%[0-9]+]]:gpcr = CCSeal [[COPY1]], [[COPY2]]
  ; CHECK-NEXT:   [[CSealEntry:%[0-9]+]]:gpcr = CSealEntry [[COPY1]]
  ; CHECK-NEXT:   [[CToPtr:%[0-9]+]]:gpr = CToPtr [[COPY1]], [[COPY3]]
  ; CHECK-NEXT:   [[CFromPtr:%[0-9]+]]:gpcr = CFromPtr [[COPY3]], [[COPY]]
  ; CHECK-NEXT:   [[CSpecialRW:%[0-9]+]]:gpcr = CSpecialRW 0, [[COPY1]]
  ; CHECK-NEXT:   Clear 1, 1
  ; CHECK-NEXT:   FPClear 1, 1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.for.inc:
  ; CHECK-NEXT:   successors: %bb.2(0x7c000000), %bb.1(0x04000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BLTU [[COPY]], $x0, %bb.2
  ; CHECK-NEXT:   PseudoBR %bb.1
  bb.0.entry:
    successors: %bb.2(0x80000000)
    liveins: $x10, $c11, $c12

    %0:gpr = COPY $x10
    %1:gpcr = COPY $c11
    %2:gpcr = COPY $c12
    %3:gpcrc0isddc = COPY $c12
    ; %4 should be known to be unsealed (since CIncOffset succeeded)
    %4:gpcr = CIncOffsetImm %1, 4
    ; %5 should be known to be tagged and unsealed
    %5:gpcr = CAndPerm %1, %0


    PseudoBR %bb.2

  bb.1.for.cond.cleanup:
    PseudoCapRET

  bb.2.for.body:
    successors: %bb.4(0x30000000), %bb.3(0x50000000)

    BNE %0, $x0, %bb.4
    PseudoBR %bb.3

  bb.3.if.then:
    successors: %bb.4(0x80000000)
    ; Note: Please keep these in order of the ISA spec definitions
    ; All of the getters can be hoisted:
    %10:gpr = CGetPerm %2
    %11:gpr = CGetType %2
    %12:gpr = CGetBase %2
    %13:gpr = CGetLen %2
    %14:gpr = CGetTag %2
    %15:gpr = CGetSealed %2
    %16:gpr = CGetOffset %2
    %17:gpr = CGetAddr %2
    ; However, mutators can't since the input could be sealed/untagged/other constraints
    %30:gpcr = CSeal %1, %2
    %31:gpcr = CUnseal %1, %2
    %32:gpcr = CAndPerm %1, %0
    %33:gpcr = CSetFlags %1, %0
    %34:gpcr = CSetOffset %1, %0
    %35:gpcr = CSetAddr %1, %0
    %36:gpcr = CIncOffset %1, %0
    %37:gpcr = CIncOffsetImm %1, 10
    %38:gpcr = CSetBounds %1, %0
    %39:gpcr = CSetBoundsExact %1, %0
    %40:gpcr = CSetBoundsImm %1, 10
    %41:gpcr = CClearTag %1 ; Note: CClearTag can be hoisted since it can't trap
    %42:gpcr = CBuildCap %1, %2
    %43:gpcr = CCopyType %1, %2
    %44:gpcr = CCSeal %1, %2
    %45:gpcr = CSealEntry %1

    ; Pointer-arithmetic instructions
    %60:gpr = CToPtr %1, %3  ; can trap
    %61:gpcr = CFromPtr %3, %0 ; can trap
    %62:gpr = CSub %1, %2 ; never traps
    %63:gpcr = CMove %1 ; never traps

    ; Assertion Instructions
    %70:gpr = CTestSubset %1, %2 ; never traps
    ; Note: loads not tested here (yet)

    ; Special Capabilty Register Access Instructions
    %80:gpcr = CSpecialRW 0, %1

    ; Fast Register-Clearing Instructions
    Clear 1, 1
    FPClear 1, 1

    ; Adjusting to Compressed Capability Precision
    %90:gpr = CRRL %0
    %91:gpr = CRAM %0

  bb.4.for.inc:
    successors: %bb.2(0x7c000000), %bb.1(0x04000000)

    BLTU %0, $x0, %bb.2
    PseudoBR %bb.1

...
