# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# Check that we can hoist an inbounds setbounds on an alloca
# RUN: %riscv64_cheri_purecap_llc -o - %s -run-pass=early-machinelicm -avoid-speculation=false \
# RUN:    -hoist-cheap-insts -machinelicm-ignore-reg-pressure | FileCheck %s
--- |
  ; ModuleID = '<stdin>'
  source_filename = "<stdin>"
  target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200"
  target triple = "riscv64-unknown-freebsd"

  ; Function Attrs: nounwind
  declare void @call(i32 addrspace(200)*, i32 addrspace(200)*) local_unnamed_addr addrspace(200) #0

  ; Function Attrs: nounwind
  define void @hoist_alloca_cond(i32 signext %cond) local_unnamed_addr addrspace(200) #0 {
  entry:
    %buf1 = alloca [123 x i32], align 4, addrspace(200)
    %buf2 = alloca [22 x i32], align 4, addrspace(200)
    %tobool.not = icmp eq i32 %cond, 0
    br label %for.body

  for.cond.cleanup:                                 ; preds = %for.inc
    ret void

  for.body:                                         ; preds = %for.inc, %entry
    %i.04 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
    br i1 %tobool.not, label %for.inc, label %if.then

  if.then:                                          ; preds = %for.body
    %0 = bitcast [123 x i32] addrspace(200)* %buf1 to i8 addrspace(200)*
    %1 = call i8 addrspace(200)* @llvm.cheri.bounded.stack.cap.i64(i8 addrspace(200)* %0, i64 492)
    %2 = bitcast i8 addrspace(200)* %1 to [123 x i32] addrspace(200)*
    %arraydecay2 = bitcast [123 x i32] addrspace(200)* %2 to i32 addrspace(200)*
    %3 = bitcast [22 x i32] addrspace(200)* %buf2 to i8 addrspace(200)*
    %4 = call i8 addrspace(200)* @llvm.cheri.bounded.stack.cap.i64(i8 addrspace(200)* %3, i64 88)
    %5 = bitcast i8 addrspace(200)* %4 to [22 x i32] addrspace(200)*
    %arraydecay13 = bitcast [22 x i32] addrspace(200)* %5 to i32 addrspace(200)*
    call void @call(i32 addrspace(200)* nonnull %arraydecay2, i32 addrspace(200)* nonnull %arraydecay13)
    br label %for.inc

  for.inc:                                          ; preds = %if.then, %for.body
    %inc = add nuw nsw i32 %i.04, 1
    %exitcond.not = icmp eq i32 %inc, 100
    br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
  }

  ; Function Attrs: nounwind readnone willreturn
  declare i8 addrspace(200)* @llvm.cheri.bounded.stack.cap.i64(i8 addrspace(200)*, i64) addrspace(200) #1

  attributes #0 = { nounwind "target-features"="+cap-mode,+xcheri" }
  attributes #1 = { nounwind readnone willreturn }

...
---
name:            hoist_alloca_cond
alignment:       4
exposesReturnsTwice: false
legalized:       false
regBankSelected: false
selected:        false
failedISel:      false
tracksRegLiveness: true
hasWinCFI:       false
liveins:
  - { reg: '$x10', virtual-reg: '%3' }
frameInfo:
  isFrameAddressTaken: false
  isReturnAddressTaken: false
  hasStackMap:     false
  hasPatchPoint:   false
  stackSize:       0
  offsetAdjustment: 0
  maxAlignment:    4
  adjustsStack:    false
  hasCalls:        true
  stackProtector:  ''
  maxCallFrameSize: 4294967295
  cvBytesOfCalleeSavedRegisters: 0
  hasOpaqueSPAdjustment: false
  hasVAStart:      false
  hasMustTailInVarArgFunc: false
  localFrameSize:  0
  savePoint:       ''
  restorePoint:    ''
fixedStack:      []
stack:
  - { id: 0, name: buf1, type: default, offset: 0, size: 492, alignment: 4,
      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
  - { id: 1, name: buf2, type: default, offset: 0, size: 88, alignment: 4,
      stack-id: default, callee-saved-register: '', callee-saved-restored: true,
      debug-info-variable: '', debug-info-expression: '', debug-info-location: '' }
callSites:       []
constants:       []
machineFunctionInfo: {}
body:             |
  ; CHECK-LABEL: name: hoist_alloca_cond
  ; CHECK: bb.0.entry:
  ; CHECK-NEXT:   successors: %bb.2(0x80000000)
  ; CHECK-NEXT:   liveins: $x10
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[COPY:%[0-9]+]]:gpr = COPY $x10
  ; CHECK-NEXT:   [[ADDI:%[0-9]+]]:gpr = ADDI $x0, 492
  ; CHECK-NEXT:   [[ADDI1:%[0-9]+]]:gpr = ADDI $x0, 493
  ; CHECK-NEXT:   [[CIncOffsetImm:%[0-9]+]]:gpcr = CIncOffsetImm %stack.0.buf1, 0
  ; CHECK-NEXT:   [[CSetBounds:%[0-9]+]]:gpcr = CSetBounds [[CIncOffsetImm]], [[ADDI]]
  ; CHECK-NEXT:   [[CSetBoundsExact:%[0-9]+]]:gpcr = CSetBoundsExact [[CIncOffsetImm]], [[ADDI]]
  ; CHECK-NEXT:   [[CSetBoundsImm:%[0-9]+]]:gpcr = CSetBoundsImm [[CIncOffsetImm]], 492
  ; CHECK-NEXT:   [[CIncOffsetImm1:%[0-9]+]]:gpcr = CIncOffsetImm %stack.0.buf1, 1
  ; CHECK-NEXT:   [[ADDI2:%[0-9]+]]:gpr = ADDI $x0, 491
  ; CHECK-NEXT:   [[CSetBounds1:%[0-9]+]]:gpcr = CSetBounds [[CIncOffsetImm1]], [[ADDI2]]
  ; CHECK-NEXT:   [[CSetBoundsExact1:%[0-9]+]]:gpcr = CSetBoundsExact [[CIncOffsetImm1]], [[ADDI2]]
  ; CHECK-NEXT:   [[CSetBoundsImm1:%[0-9]+]]:gpcr = CSetBoundsImm [[CIncOffsetImm1]], 491
  ; CHECK-NEXT:   [[ADDI3:%[0-9]+]]:gpr = ADDI $x0, 88
  ; CHECK-NEXT:   [[CIncOffsetImm2:%[0-9]+]]:gpcr = CIncOffsetImm %stack.1.buf2, 0
  ; CHECK-NEXT:   [[CSetBounds2:%[0-9]+]]:gpcr = CSetBounds [[CIncOffsetImm2]], [[ADDI3]]
  ; CHECK-NEXT:   [[CSetBoundsExact2:%[0-9]+]]:gpcr = CSetBoundsExact [[CIncOffsetImm2]], [[ADDI3]]
  ; CHECK-NEXT:   [[CIncOffsetImm3:%[0-9]+]]:gpcr = CIncOffsetImm [[CIncOffsetImm1]], -1
  ; CHECK-NEXT:   [[CSetBounds3:%[0-9]+]]:gpcr = CSetBounds [[CIncOffsetImm3]], [[ADDI3]]
  ; CHECK-NEXT:   [[CSetBoundsExact3:%[0-9]+]]:gpcr = CSetBoundsExact [[CIncOffsetImm3]], [[ADDI3]]
  ; CHECK-NEXT:   [[CSetBoundsImm2:%[0-9]+]]:gpcr = CSetBoundsImm [[CIncOffsetImm3]], 492
  ; CHECK-NEXT:   [[CIncOffsetImm4:%[0-9]+]]:gpcr = CIncOffsetImm $c0, 1
  ; CHECK-NEXT:   [[CIncOffsetImm5:%[0-9]+]]:gpcr = CIncOffsetImm [[CIncOffsetImm4]], -1
  ; CHECK-NEXT:   [[CSetOffset:%[0-9]+]]:gpcr = CSetOffset [[CIncOffsetImm1]], $x0
  ; CHECK-NEXT:   [[CSetBoundsImm3:%[0-9]+]]:gpcr = CSetBoundsImm [[CIncOffsetImm1]], 0
  ; CHECK-NEXT:   [[CIncOffsetImm6:%[0-9]+]]:gpcr = CIncOffsetImm %stack.0.buf1, 492
  ; CHECK-NEXT:   [[CSetBoundsImm4:%[0-9]+]]:gpcr = CSetBoundsImm [[CIncOffsetImm6]], 0
  ; CHECK-NEXT:   PseudoBR %bb.2
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.1.for.cond.cleanup:
  ; CHECK-NEXT:   PseudoCRET
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.2.for.body:
  ; CHECK-NEXT:   successors: %bb.4(0x30000000), %bb.3(0x50000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BNE undef $x2, $x0, %bb.4
  ; CHECK-NEXT:   PseudoBR %bb.3
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.3.if.then:
  ; CHECK-NEXT:   successors: %bb.4(0x80000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   [[CSetBounds4:%[0-9]+]]:gpcr = CSetBounds [[CIncOffsetImm1]], [[ADDI]]
  ; CHECK-NEXT:   [[CSetBoundsExact4:%[0-9]+]]:gpcr = CSetBoundsExact [[CIncOffsetImm1]], [[ADDI]]
  ; CHECK-NEXT:   [[CSetBoundsImm5:%[0-9]+]]:gpcr = CSetBoundsImm [[CIncOffsetImm1]], 492
  ; CHECK-NEXT:   [[CSetBoundsImm6:%[0-9]+]]:gpcr = CSetBoundsImm [[CIncOffsetImm1]], 492
  ; CHECK-NEXT:   [[CSetBounds5:%[0-9]+]]:gpcr = CSetBounds [[CIncOffsetImm5]], [[ADDI3]]
  ; CHECK-NEXT:   [[CSetBoundsExact5:%[0-9]+]]:gpcr = CSetBoundsExact [[CIncOffsetImm5]], [[ADDI3]]
  ; CHECK-NEXT:   [[CSetBoundsImm7:%[0-9]+]]:gpcr = CSetBoundsImm [[CIncOffsetImm5]], 492
  ; CHECK-NEXT:   [[CSetBoundsImm8:%[0-9]+]]:gpcr = CSetBoundsImm [[CIncOffsetImm6]], 1
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT: bb.4.for.inc:
  ; CHECK-NEXT:   successors: %bb.1(0x04000000), %bb.2(0x7c000000)
  ; CHECK-NEXT: {{  $}}
  ; CHECK-NEXT:   BEQ undef $x2, undef $x1, %bb.1
  ; CHECK-NEXT:   PseudoBR %bb.2
  bb.0.entry:
    successors: %bb.2(0x80000000)
    liveins: $x10
    %3:gpr = COPY $x10
    PseudoBR %bb.2

  bb.1.for.cond.cleanup:
    PseudoCRET

  bb.2.for.body:
    successors: %bb.4(0x30000000), %bb.3(0x50000000)

    BNE undef $x2, $x0, %bb.4
    PseudoBR %bb.3

  bb.3.if.then:
    successors: %bb.4(0x80000000)
    %5:gpr = ADDI $x0, 492
    %6:gpr = ADDI $x0, 493
    ; These are fine
    %10:gpcr = CIncOffsetImm %stack.0.buf1, 0
    %11:gpcr = CSetBounds %10, %5
    %12:gpcr = CSetBoundsExact %10, %5
    %13:gpcr = CSetBoundsImm %10, 492
    ; These will trap since the length is too big:
    %14:gpcr = CSetBounds %10, %5
    %15:gpcr = CSetBoundsExact %10, %5
    %16:gpcr = CSetBoundsImm %10, 492

    ; plus + 1 -> OOB, so shouldn't be hoisted:
    %30:gpcr = CIncOffsetImm %stack.0.buf1, 1
    %31:gpcr = CSetBounds %30, %5
    %32:gpcr = CSetBoundsExact %30, %5
    %33:gpcr = CSetBoundsImm %30, 492
    %34:gpr = ADDI $x0, 491  ; length - 1 -> should be fine
    %35:gpcr = CSetBounds %30, %34
    %36:gpcr = CSetBoundsExact %30, %34
    %37:gpcr = CSetBoundsImm %30, 491
    %38:gpcr = CSetBoundsImm %30, 492 ; OOB

    ; One more check with a different buffer size
    %50:gpr = ADDI $x0, 88
    %51:gpcr = CIncOffsetImm %stack.1.buf2, 0
    %52:gpcr = CSetBounds %51, %50
    %53:gpcr = CSetBoundsExact %51, %50
    %54:gpcr = CSetBounds %51, %50


    ; And some more checks for non-stack values or multiple incoffset
    %100:gpcr = CIncOffsetImm %stack.0.buf1, 1
    %101:gpcr = CIncOffsetImm %100, -1
    %102:gpcr = CSetBounds %101, %50
    %103:gpcr = CSetBoundsExact %101, %50
    %104:gpcr = CSetBoundsImm %101, 492

    %110:gpcr = CIncOffsetImm $c0, 1
    %111:gpcr = CIncOffsetImm %110, -1
    %112:gpcr = CSetBounds %111, %50
    %113:gpcr = CSetBoundsExact %111, %50
    %114:gpcr = CSetBoundsImm %111, 492

    ; Non-CIncOffset instructions are not handled:
    %120:gpcr = CSetOffset %100, $x0
    %121:gpcr = CSetBoundsImm %100, 0
    ; OOB with size zero/one
    %122:gpcr = CIncOffsetImm %stack.0.buf1, 492
    %123:gpcr = CSetBoundsImm %122, 0
    %124:gpcr = CSetBoundsImm %122, 1


  bb.4.for.inc:
    successors: %bb.1(0x04000000), %bb.2(0x7c000000)

    BEQ undef $x2, undef $x1, %bb.1
    PseudoBR %bb.2

...
