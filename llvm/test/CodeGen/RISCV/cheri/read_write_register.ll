; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; Check that we handle llvm.read_register.p200i8/llvm.write_register.p200i8
; This test is derived from the clang/test/CodeGen/cheri/riscv/global-register-variable.c clang test
; RUN: %riscv64_cheri_purecap_llc < %s | FileCheck --check-prefix=CHECK-L64PC128 %s
; RUN: %riscv64_cheri_llc < %s | FileCheck --check-prefix=CHECK-LP64 %s

%struct.StackPtr = type opaque

; Function Attrs: nounwind readonly
define i64 @get_tp() local_unnamed_addr #0 {
; CHECK-L64PC128-LABEL: get_tp:
; CHECK-L64PC128:       # %bb.0: # %entry
; CHECK-L64PC128-NEXT:    mv a0, tp
; CHECK-L64PC128-NEXT:    cret
;
; CHECK-LP64-LABEL: get_tp:
; CHECK-LP64:       # %bb.0: # %entry
; CHECK-LP64-NEXT:    mv a0, tp
; CHECK-LP64-NEXT:    ret
entry:
  %0 = tail call i64 @llvm.read_register.i64(metadata !0)
  ret i64 %0
}

; Function Attrs: nounwind readonly
declare i64 @llvm.read_register.i64(metadata) #1

; Function Attrs: nounwind
define void @set_tp(i64 %value) local_unnamed_addr #2 {
; FIXME: this is wrong, but is a bug upstream and not in CHERI clang (https://godbolt.org/z/WTYh5q)
; CHECK-L64PC128-LABEL: set_tp:
; CHECK-L64PC128:       # %bb.0: # %entry
; CHECK-L64PC128-NEXT:    cincoffset csp, csp, -16
; CHECK-L64PC128-NEXT:    csc ctp, 0(csp) # 16-byte Folded Spill
; CHECK-L64PC128-NEXT:    mv tp, a0
; CHECK-L64PC128-NEXT:    clc ctp, 0(csp) # 16-byte Folded Reload
; CHECK-L64PC128-NEXT:    cincoffset csp, csp, 16
; CHECK-L64PC128-NEXT:    cret
;
; CHECK-LP64-LABEL: set_tp:
; CHECK-LP64:       # %bb.0: # %entry
; CHECK-LP64-NEXT:    addi sp, sp, -16
; CHECK-LP64-NEXT:    sd tp, 8(sp) # 8-byte Folded Spill
; CHECK-LP64-NEXT:    mv tp, a0
; CHECK-LP64-NEXT:    ld tp, 8(sp) # 8-byte Folded Reload
; CHECK-LP64-NEXT:    addi sp, sp, 16
; CHECK-LP64-NEXT:    ret
entry:
  tail call void @llvm.write_register.i64(metadata !0, i64 %value)
  ret void
}

; Function Attrs: nounwind
declare void @llvm.write_register.i64(metadata, i64) #3

; Function Attrs: nounwind readonly
define i8 addrspace(200)* @get_ctp() local_unnamed_addr #0 {
; CHECK-L64PC128-LABEL: get_ctp:
; CHECK-L64PC128:       # %bb.0: # %entry
; CHECK-L64PC128-NEXT:    cmove ca0, ctp
; CHECK-L64PC128-NEXT:    cret
;
; CHECK-LP64-LABEL: get_ctp:
; CHECK-LP64:       # %bb.0: # %entry
; CHECK-LP64-NEXT:    cmove ca0, ctp
; CHECK-LP64-NEXT:    ret
entry:
  %0 = tail call i8 addrspace(200)* @llvm.read_register.p200i8(metadata !1)
  ret i8 addrspace(200)* %0
}

; Function Attrs: nounwind readonly
declare i8 addrspace(200)* @llvm.read_register.p200i8(metadata) #1

; Function Attrs: nounwind
define void @set_ctp(i8 addrspace(200)* %value) local_unnamed_addr #2 {
; FIXME: this is wrong, but is a bug upstream and not in CHERI clang (https://godbolt.org/z/WTYh5q)
; CHECK-L64PC128-LABEL: set_ctp:
; CHECK-L64PC128:       # %bb.0: # %entry
; CHECK-L64PC128-NEXT:    cincoffset csp, csp, -16
; CHECK-L64PC128-NEXT:    csc ctp, 0(csp) # 16-byte Folded Spill
; CHECK-L64PC128-NEXT:    cmove ctp, ca0
; CHECK-L64PC128-NEXT:    clc ctp, 0(csp) # 16-byte Folded Reload
; CHECK-L64PC128-NEXT:    cincoffset csp, csp, 16
; CHECK-L64PC128-NEXT:    cret
;
; CHECK-LP64-LABEL: set_ctp:
; CHECK-LP64:       # %bb.0: # %entry
; CHECK-LP64-NEXT:    addi sp, sp, -16
; CHECK-LP64-NEXT:    sd tp, 8(sp) # 8-byte Folded Spill
; CHECK-LP64-NEXT:    cmove ctp, ca0
; CHECK-LP64-NEXT:    ld tp, 8(sp) # 8-byte Folded Reload
; CHECK-LP64-NEXT:    addi sp, sp, 16
; CHECK-LP64-NEXT:    ret
entry:
  tail call void @llvm.write_register.p200i8(metadata !1, i8 addrspace(200)* %value)
  ret void
}

; Function Attrs: nounwind
declare void @llvm.write_register.p200i8(metadata, i8 addrspace(200)*) #3

; Function Attrs: nounwind readonly
define %struct.StackPtr addrspace(200)* @get_csp() local_unnamed_addr #0 {
; CHECK-L64PC128-LABEL: get_csp:
; CHECK-L64PC128:       # %bb.0: # %entry
; CHECK-L64PC128-NEXT:    cmove ca0, csp
; CHECK-L64PC128-NEXT:    cret
;
; CHECK-LP64-LABEL: get_csp:
; CHECK-LP64:       # %bb.0: # %entry
; CHECK-LP64-NEXT:    cmove ca0, csp
; CHECK-LP64-NEXT:    ret
entry:
  %0 = tail call i8 addrspace(200)* @llvm.read_register.p200i8(metadata !2)
  %1 = bitcast i8 addrspace(200)* %0 to %struct.StackPtr addrspace(200)*
  ret %struct.StackPtr addrspace(200)* %1
}

; Function Attrs: nounwind
define void @set_csp(%struct.StackPtr addrspace(200)* %value) local_unnamed_addr #2 {
; CHECK-L64PC128-LABEL: set_csp:
; CHECK-L64PC128:       # %bb.0: # %entry
; CHECK-L64PC128-NEXT:    cmove csp, ca0
; CHECK-L64PC128-NEXT:    cret
;
; CHECK-LP64-LABEL: set_csp:
; CHECK-LP64:       # %bb.0: # %entry
; CHECK-LP64-NEXT:    cmove csp, ca0
; CHECK-LP64-NEXT:    ret
entry:
  %0 = bitcast %struct.StackPtr addrspace(200)* %value to i8 addrspace(200)*
  tail call void @llvm.write_register.p200i8(metadata !2, i8 addrspace(200)* %0)
  ret void
}

; Function Attrs: nounwind readonly
define i64 @get_gp_addr() local_unnamed_addr #0 {
; CHECK-L64PC128-LABEL: get_gp_addr:
; CHECK-L64PC128:       # %bb.0: # %entry
; CHECK-L64PC128-NEXT:    cgetaddr a0, cgp
; CHECK-L64PC128-NEXT:    cret
;
; CHECK-LP64-LABEL: get_gp_addr:
; CHECK-LP64:       # %bb.0: # %entry
; CHECK-LP64-NEXT:    cgetaddr a0, cgp
; CHECK-LP64-NEXT:    ret
entry:
  %0 = tail call i8 addrspace(200)* @llvm.read_register.p200i8(metadata !3)
  %1 = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %0)
  ret i64 %1
}

; Function Attrs: nounwind readnone willreturn
declare i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)*) #4

; Function Attrs: nounwind
define void @set_gp_addr(i64 %value) local_unnamed_addr #2 {
; FIXME: this is wrong, but is a bug upstream and not in CHERI clang (https://godbolt.org/z/WTYh5q)
; CHECK-L64PC128-LABEL: set_gp_addr:
; CHECK-L64PC128:       # %bb.0: # %entry
; CHECK-L64PC128-NEXT:    cincoffset csp, csp, -16
; CHECK-L64PC128-NEXT:    csc cgp, 0(csp) # 16-byte Folded Spill
; CHECK-L64PC128-NEXT:    cincoffset cgp, cnull, a0
; CHECK-L64PC128-NEXT:    clc cgp, 0(csp) # 16-byte Folded Reload
; CHECK-L64PC128-NEXT:    cincoffset csp, csp, 16
; CHECK-L64PC128-NEXT:    cret
;
; CHECK-LP64-LABEL: set_gp_addr:
; CHECK-LP64:       # %bb.0: # %entry
; CHECK-LP64-NEXT:    addi sp, sp, -16
; CHECK-LP64-NEXT:    sd gp, 8(sp) # 8-byte Folded Spill
; CHECK-LP64-NEXT:    cincoffset cgp, cnull, a0
; CHECK-LP64-NEXT:    ld gp, 8(sp) # 8-byte Folded Reload
; CHECK-LP64-NEXT:    addi sp, sp, 16
; CHECK-LP64-NEXT:    ret
entry:
  %0 = getelementptr i8, i8 addrspace(200)* null, i64 %value
  tail call void @llvm.write_register.p200i8(metadata !3, i8 addrspace(200)* %0)
  ret void
}

attributes #0 = { nounwind readonly }
attributes #1 = { nounwind readonly }
attributes #2 = { nounwind }
attributes #3 = { nounwind }
attributes #4 = { nounwind readnone willreturn }

!llvm.named.register.tp = !{!0}
!llvm.named.register.ctp = !{!1}
!llvm.named.register.csp = !{!2}
!llvm.named.register.cgp = !{!3}

!0 = !{!"tp"}
!1 = !{!"ctp"}
!2 = !{!"csp"}
!3 = !{!"cgp"}
