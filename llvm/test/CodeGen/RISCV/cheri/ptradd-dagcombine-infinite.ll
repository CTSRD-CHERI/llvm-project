; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; This IR previously triggered an infinite DAGCombiner loop inside DAGCombiner::visitPTRADD().
; Check that this no longer happens and that we can fold the two GEPs into a single ISD::PTRADD.
; RUN: %riscv64_cheri_purecap_llc -mattr=+m -verify-machineinstrs < %s | FileCheck %s

%struct.foo = type { i64, { i64, i64 }, i8 }

define %struct.foo addrspace(200)* @fold_geps(i64 %arg1, %struct.foo addrspace(200)* %arg2) nounwind {
; CHECK-LABEL: fold_geps:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset ca0, ca1, -32
; CHECK-NEXT:    cret
entry:
  %mul = mul nsw i64 0, %arg1
  %gep1 = getelementptr inbounds %struct.foo, %struct.foo addrspace(200)* %arg2, i64 %mul
  %gep2 = getelementptr inbounds %struct.foo, %struct.foo addrspace(200)* %gep1, i64 -1
  ret %struct.foo addrspace(200)* %gep2
}

define %struct.foo addrspace(200)* @fold_geps2(i64 %a, i64 %b, %struct.foo addrspace(200)* %ptr) nounwind {
; CHECK-LABEL: fold_geps2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset ca0, ca2, -32
; CHECK-NEXT:    cret
entry:
  %zero = sub i64 %a, %a  ; Use a fold that does not return SDValue(N, 0)
  %gep1 = getelementptr inbounds %struct.foo, %struct.foo addrspace(200)* %ptr, i64 %zero
  %gep2 = getelementptr inbounds %struct.foo, %struct.foo addrspace(200)* %gep1, i64 -1
  ret %struct.foo addrspace(200)* %gep2
}

; Negative check, this one can't be folded since the multiply is not a constant
define %struct.foo addrspace(200)* @cannot_fold(i64 %arg1, %struct.foo addrspace(200)* %arg2) nounwind {
; CHECK-LABEL: cannot_fold:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    mul a0, a0, a0
; CHECK-NEXT:    slli a0, a0, 5
; CHECK-NEXT:    cincoffset ca0, ca1, a0
; CHECK-NEXT:    cincoffset ca0, ca0, -32
; CHECK-NEXT:    cret
entry:
  %mul = mul i64 %arg1, %arg1
  %gep1 = getelementptr inbounds %struct.foo, %struct.foo addrspace(200)* %arg2, i64 %mul
  %gep2 = getelementptr inbounds %struct.foo, %struct.foo addrspace(200)* %gep1, i64 -1
  ret %struct.foo addrspace(200)* %gep2
}

; Another check where we can't fold the ptradd, but where visitAdd() returns a new node.
define i8 addrspace(200)* @cannot_fold_2(i64 %arg1, i8 addrspace(200)* %ptr) nounwind {
; CHECK-LABEL: cannot_fold_2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    neg a0, a0
; CHECK-NEXT:    cincoffset ca0, ca1, a0
; CHECK-NEXT:    cincoffset ca0, ca0, 304
; CHECK-NEXT:    cret
entry:
  %sub = sub i64 0, %arg1
  %gep1 = getelementptr inbounds i8, i8 addrspace(200)* %ptr, i64 %sub
  %gep2 = getelementptr inbounds i8, i8 addrspace(200)* %gep1, i64 304
  ret i8 addrspace(200)* %gep2
}
