; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %riscv32_cheri_purecap_llc -verify-machineinstrs < %s | FileCheck %s

define i32 @get_ith_word(i32 signext %i, ...) addrspace(200) nounwind {
; CHECK-LABEL: get_ith_word:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset csp, csp, -16
; CHECK-NEXT:    cincoffset ca1, csp, 8
; CHECK-NEXT:    csetbounds ca1, ca1, 8
; CHECK-NEXT:    cincoffset ca2, csp, 16
; CHECK-NEXT:    sc ca2, 0(ca1)
; CHECK-NEXT:    lc ca1, 8(csp)
; CHECK-NEXT:    addi a0, a0, 1
; CHECK-NEXT:  .LBB0_1: # %while.cond
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    cmove ca2, ca1
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    cincoffset ca1, ca1, 4
; CHECK-NEXT:    bgtz a0, .LBB0_1
; CHECK-NEXT:  # %bb.2: # %while.end
; CHECK-NEXT:    sc ca1, 8(csp)
; CHECK-NEXT:    lw a0, 0(ca2)
; CHECK-NEXT:    cincoffset csp, csp, 16
; CHECK-NEXT:    ret
entry:
  %ap = alloca ptr addrspace(200), align 8, addrspace(200)
  %0 = bitcast ptr addrspace(200) %ap to ptr addrspace(200)
  call void @llvm.lifetime.start.p200(i64 8, ptr addrspace(200) nonnull %0)
  call void @llvm.va_start.p200(ptr addrspace(200) nonnull %0)
  %ap.promoted = load ptr addrspace(200), ptr addrspace(200) %ap, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %entry
  %argp.next6 = phi ptr addrspace(200) [ %ap.promoted, %entry ], [ %argp.next, %while.cond ]
  %i.addr.0 = phi i32 [ %i, %entry ], [ %dec, %while.cond ]
  %dec = add nsw i32 %i.addr.0, -1
  %cmp = icmp sgt i32 %i.addr.0, 0
  %argp.next = getelementptr inbounds i8, ptr addrspace(200) %argp.next6, i32 4
  br i1 %cmp, label %while.cond, label %while.end

while.end:                                        ; preds = %while.cond
  store ptr addrspace(200) %argp.next, ptr addrspace(200) %ap, align 8
  %1 = bitcast ptr addrspace(200) %argp.next6 to ptr addrspace(200)
  %2 = load i32, ptr addrspace(200) %1, align 4
  call void @llvm.va_end.p200(ptr addrspace(200) nonnull %0)
  call void @llvm.lifetime.end.p200(i64 8, ptr addrspace(200) nonnull %0)
  ret i32 %2
}

define ptr addrspace(200) @get_ith_cap(i32 signext %i, ...) addrspace(200) nounwind {
; CHECK-LABEL: get_ith_cap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset csp, csp, -16
; CHECK-NEXT:    cincoffset ca1, csp, 8
; CHECK-NEXT:    csetbounds ca1, ca1, 8
; CHECK-NEXT:    cincoffset ca2, csp, 16
; CHECK-NEXT:    sc ca2, 0(ca1)
; CHECK-NEXT:    lc ca1, 8(csp)
; CHECK-NEXT:    addi a0, a0, 1
; CHECK-NEXT:  .LBB1_1: # %while.cond
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    addi a2, a1, 7
; CHECK-NEXT:    andi a2, a2, -8
; CHECK-NEXT:    csetaddr ca2, ca1, a2
; CHECK-NEXT:    addi a0, a0, -1
; CHECK-NEXT:    cincoffset ca1, ca2, 8
; CHECK-NEXT:    bgtz a0, .LBB1_1
; CHECK-NEXT:  # %bb.2: # %while.end
; CHECK-NEXT:    sc ca1, 8(csp)
; CHECK-NEXT:    lc ca0, 0(ca2)
; CHECK-NEXT:    cincoffset csp, csp, 16
; CHECK-NEXT:    ret
entry:
  %ap = alloca ptr addrspace(200), align 8, addrspace(200)
  %0 = bitcast ptr addrspace(200) %ap to ptr addrspace(200)
  call void @llvm.lifetime.start.p200(i64 8, ptr addrspace(200) nonnull %0)
  call void @llvm.va_start.p200(ptr addrspace(200) nonnull %0)
  %ap.promoted = load ptr addrspace(200), ptr addrspace(200) %ap, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.cond, %entry
  %argp.next6 = phi ptr addrspace(200) [ %ap.promoted, %entry ], [ %argp.next, %while.cond ]
  %i.addr.0 = phi i32 [ %i, %entry ], [ %dec, %while.cond ]
  %dec = add nsw i32 %i.addr.0, -1
  %cmp = icmp sgt i32 %i.addr.0, 0
  %1 = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) %argp.next6)
  %2 = add i32 %1, 7
  %3 = and i32 %2, -8
  %4 = call ptr addrspace(200) @llvm.cheri.cap.address.set.i32(ptr addrspace(200) %argp.next6, i32 %3)
  %argp.next = getelementptr inbounds i8, ptr addrspace(200) %4, i64 8
  br i1 %cmp, label %while.cond, label %while.end

while.end:                                        ; preds = %while.cond
  store ptr addrspace(200) %argp.next, ptr addrspace(200) %ap, align 8
  %5 = bitcast ptr addrspace(200) %4 to ptr addrspace(200)
  %6 = load ptr addrspace(200), ptr addrspace(200) %5, align 8
  call void @llvm.va_end.p200(ptr addrspace(200) nonnull %0)
  call void @llvm.lifetime.end.p200(i64 8, ptr addrspace(200) nonnull %0)
  ret ptr addrspace(200) %6
}

declare void @varargs(i32, ...) addrspace(200) nounwind

; Make sure this doesn't reserve x1; normally 2*XLen sized and aligned structs
; go in an even integer register pair and would thus reserve the odd register,
; even though we're passing on the stack.
define void @test_varargs_odd_cap_reg() nounwind {
; CHECK-LABEL: test_varargs_odd_cap_reg:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cincoffset csp, csp, -16
; CHECK-NEXT:    sc cra, 8(csp) # 8-byte Folded Spill
; CHECK-NEXT:    li a0, 1
; CHECK-NEXT:    sc cnull, 0(csp)
; CHECK-NEXT:    ccall varargs
; CHECK-NEXT:    lc cra, 8(csp) # 8-byte Folded Reload
; CHECK-NEXT:    cincoffset csp, csp, 16
; CHECK-NEXT:    ret
entry:
  tail call addrspace(200) void (i32, ...) @varargs(i32 1, ptr addrspace(200) null)
  ret void
}

declare void @llvm.lifetime.start.p200(i64 immarg, ptr addrspace(200) nocapture) addrspace(200)
declare void @llvm.va_start.p200(ptr addrspace(200)) addrspace(200)
declare void @llvm.va_end.p200(ptr addrspace(200)) addrspace(200)
declare void @llvm.lifetime.end.p200(i64 immarg, ptr addrspace(200) nocapture) addrspace(200)
declare i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200)) addrspace(200)
declare ptr addrspace(200) @llvm.cheri.cap.address.set.i32(ptr addrspace(200), i32) addrspace(200)
