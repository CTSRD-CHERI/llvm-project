; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; Check that we can generate code for stack-protector in purecap mode but only
; do it --enable-purecap-stack-protector is passed
; For debugging: --pass-remarks-filter=stack-protector --pass-remarks-output=/dev/stderr
; RUN: %riscv32_cheri_purecap_llc < %s | FileCheck --check-prefix=IL32PC64-DEFAULT %s
; RUN: %riscv64_cheri_purecap_llc < %s | FileCheck --check-prefix=L64PC128-DEFAULT %s
; RUN: %riscv32_cheri_purecap_llc --enable-purecap-stack-protector < %s | FileCheck --check-prefix=IL32PC64 %s
; RUN: %riscv64_cheri_purecap_llc --enable-purecap-stack-protector < %s | FileCheck --check-prefix=L64PC128 %s

declare void @callee(i8 addrspace(200)*) addrspace(200)

define void @caller() addrspace(200) nounwind sspstrong {
; IL32PC64-DEFAULT-LABEL: caller:
; IL32PC64-DEFAULT:       # %bb.0:
; IL32PC64-DEFAULT-NEXT:    cincoffset csp, csp, -16
; IL32PC64-DEFAULT-NEXT:    sc cra, 8(csp) # 8-byte Folded Spill
; IL32PC64-DEFAULT-NEXT:    cincoffset ca0, csp, 7
; IL32PC64-DEFAULT-NEXT:    csetbounds ca0, ca0, 1
; IL32PC64-DEFAULT-NEXT:    ccall callee
; IL32PC64-DEFAULT-NEXT:    lc cra, 8(csp) # 8-byte Folded Reload
; IL32PC64-DEFAULT-NEXT:    cincoffset csp, csp, 16
; IL32PC64-DEFAULT-NEXT:    ret
;
; L64PC128-DEFAULT-LABEL: caller:
; L64PC128-DEFAULT:       # %bb.0:
; L64PC128-DEFAULT-NEXT:    cincoffset csp, csp, -32
; L64PC128-DEFAULT-NEXT:    sc cra, 16(csp) # 16-byte Folded Spill
; L64PC128-DEFAULT-NEXT:    cincoffset ca0, csp, 15
; L64PC128-DEFAULT-NEXT:    csetbounds ca0, ca0, 1
; L64PC128-DEFAULT-NEXT:    ccall callee
; L64PC128-DEFAULT-NEXT:    lc cra, 16(csp) # 16-byte Folded Reload
; L64PC128-DEFAULT-NEXT:    cincoffset csp, csp, 32
; L64PC128-DEFAULT-NEXT:    ret
;
; IL32PC64-LABEL: caller:
; IL32PC64:       # %bb.0:
; IL32PC64-NEXT:    cincoffset csp, csp, -32
; IL32PC64-NEXT:    sc cra, 24(csp) # 8-byte Folded Spill
; IL32PC64-NEXT:    sc cs0, 16(csp) # 8-byte Folded Spill
; IL32PC64-NEXT:  .LBB0_3: # Label of block must be emitted
; IL32PC64-NEXT:    auipcc cs0, %got_pcrel_hi(__stack_chk_guard)
; IL32PC64-NEXT:    lc cs0, %pcrel_lo(.LBB0_3)(cs0)
; IL32PC64-NEXT:    lw a0, 0(cs0)
; IL32PC64-NEXT:    sw a0, 12(csp)
; IL32PC64-NEXT:    cincoffset ca0, csp, 11
; IL32PC64-NEXT:    csetbounds ca0, ca0, 1
; IL32PC64-NEXT:    ccall callee
; IL32PC64-NEXT:    lw a0, 0(cs0)
; IL32PC64-NEXT:    lw a1, 12(csp)
; IL32PC64-NEXT:    bne a0, a1, .LBB0_2
; IL32PC64-NEXT:  # %bb.1:
; IL32PC64-NEXT:    lc cra, 24(csp) # 8-byte Folded Reload
; IL32PC64-NEXT:    lc cs0, 16(csp) # 8-byte Folded Reload
; IL32PC64-NEXT:    cincoffset csp, csp, 32
; IL32PC64-NEXT:    ret
; IL32PC64-NEXT:  .LBB0_2:
; IL32PC64-NEXT:    ccall __stack_chk_fail
;
; L64PC128-LABEL: caller:
; L64PC128:       # %bb.0:
; L64PC128-NEXT:    cincoffset csp, csp, -48
; L64PC128-NEXT:    sc cra, 32(csp) # 16-byte Folded Spill
; L64PC128-NEXT:    sc cs0, 16(csp) # 16-byte Folded Spill
; L64PC128-NEXT:  .LBB0_3: # Label of block must be emitted
; L64PC128-NEXT:    auipcc cs0, %got_pcrel_hi(__stack_chk_guard)
; L64PC128-NEXT:    lc cs0, %pcrel_lo(.LBB0_3)(cs0)
; L64PC128-NEXT:    ld a0, 0(cs0)
; L64PC128-NEXT:    sd a0, 8(csp)
; L64PC128-NEXT:    cincoffset ca0, csp, 7
; L64PC128-NEXT:    csetbounds ca0, ca0, 1
; L64PC128-NEXT:    ccall callee
; L64PC128-NEXT:    ld a0, 0(cs0)
; L64PC128-NEXT:    ld a1, 8(csp)
; L64PC128-NEXT:    bne a0, a1, .LBB0_2
; L64PC128-NEXT:  # %bb.1:
; L64PC128-NEXT:    lc cra, 32(csp) # 16-byte Folded Reload
; L64PC128-NEXT:    lc cs0, 16(csp) # 16-byte Folded Reload
; L64PC128-NEXT:    cincoffset csp, csp, 48
; L64PC128-NEXT:    ret
; L64PC128-NEXT:  .LBB0_2:
; L64PC128-NEXT:    ccall __stack_chk_fail
  %ptr = alloca i8, addrspace(200)
  call void @callee(i8 addrspace(200)* %ptr)
  ret void
}
