; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;; The CFromPtr instruction is not part of ISAv9, check that we emit `x == 0 ? null : csetoffset(auth, x)` instead.
; RUN: %riscv64_cheri_purecap_llc < %s | FileCheck %s --check-prefix=ISAV8
; RUN: %riscv64_cheri_purecap_llc -mattr=+xcheri-v9-semantics < %s | FileCheck %s --check-prefix=ISAV9
;; Also emit a .o file since verifyInstructionPredicates() is only called for binary output.
; RUN: %riscv64_cheri_purecap_llc -mattr=+xcheri-v9-semantics -filetype=obj -o /dev/null < %s

;; (int_cheri_cap_from_ptr auth, x) -> x == 0 ? null : csetoffset(auth, x)
define dso_local i8 addrspace(200)* @cap_from_ptr(i8 addrspace(200)* addrspace(200)* %ptr, i8 addrspace(200)* %cap, i64 %offset) nounwind {
; ISAV8-LABEL: cap_from_ptr:
; ISAV8:       # %bb.0: # %entry
; ISAV8-NEXT:    cfromptr ca1, ca1, a2
; ISAV8-NEXT:    csc ca1, 0(ca0)
; ISAV8-NEXT:    cmove ca0, ca1
; ISAV8-NEXT:    cret
;
; ISAV9-LABEL: cap_from_ptr:
; ISAV9:       # %bb.0: # %entry
; ISAV9-NEXT:    bnez a2, .LBB0_2
; ISAV9-NEXT:  # %bb.1: # %entry
; ISAV9-NEXT:    cmove ca1, cnull
; ISAV9-NEXT:    j .LBB0_3
; ISAV9-NEXT:  .LBB0_2:
; ISAV9-NEXT:    csetaddr ca1, ca1, a2
; ISAV9-NEXT:  .LBB0_3: # %entry
; ISAV9-NEXT:    csc ca1, 0(ca0)
; ISAV9-NEXT:    cmove ca0, ca1
; ISAV9-NEXT:    cret
entry:
  %new = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i64(i8 addrspace(200)* %cap, i64 %offset)
  store i8 addrspace(200)* %new, i8 addrspace(200)* addrspace(200)* %ptr, align 16
  ret i8 addrspace(200)* %new
}

;; (int_cheri_cap_from_ptr ddc, y) -> x == 0 ? null : csetoffset(ddc, x)
;; NB: This is not the same as (inttoptr x), since the explicit intrinsic retains the offsetting semantics.
define dso_local i8 addrspace(200)* @cap_from_ptr_ddc(i8 addrspace(200)* addrspace(200)* %ptr, i64 %offset) nounwind {
; ISAV8-LABEL: cap_from_ptr_ddc:
; ISAV8:       # %bb.0: # %entry
; ISAV8-NEXT:    cfromptr ca1, ddc, a1
; ISAV8-NEXT:    csc ca1, 0(ca0)
; ISAV8-NEXT:    cmove ca0, ca1
; ISAV8-NEXT:    cret
;
; ISAV9-LABEL: cap_from_ptr_ddc:
; ISAV9:       # %bb.0: # %entry
; ISAV9-NEXT:    cspecialr ca2, ddc
; ISAV9-NEXT:    bnez a1, .LBB1_2
; ISAV9-NEXT:  # %bb.1: # %entry
; ISAV9-NEXT:    cmove ca1, cnull
; ISAV9-NEXT:    j .LBB1_3
; ISAV9-NEXT:  .LBB1_2:
; ISAV9-NEXT:    csetaddr ca1, ca2, a1
; ISAV9-NEXT:  .LBB1_3: # %entry
; ISAV9-NEXT:    csc ca1, 0(ca0)
; ISAV9-NEXT:    cmove ca0, ca1
; ISAV9-NEXT:    cret
entry:
  %ddc = call i8 addrspace(200)* @llvm.cheri.ddc.get()
  %new = call i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i64(i8 addrspace(200)* %ddc, i64 %offset)
  store i8 addrspace(200)* %new, i8 addrspace(200)* addrspace(200)* %ptr, align 16
  ret i8 addrspace(200)* %new
}

declare i8 addrspace(200)* @llvm.cheri.cap.from.pointer.i64(i8 addrspace(200)*, i64)
declare i8 addrspace(200)* @llvm.cheri.ddc.get()
