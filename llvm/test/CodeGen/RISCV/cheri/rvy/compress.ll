; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py

; RUN: cat %s > %t.tgtattr
; RUN: echo 'attributes #0 = { nounwind }' >> %t.tgtattr
; RUN: %riscv32y_purecap_llc -mattr=+c,+y,+cap-mode -filetype=obj < %t.tgtattr \
; RUN:   | llvm-objdump -d -M no-aliases - | FileCheck %s
; RUN: %riscv64y_purecap_llc -mattr=+c,+y,+cap-mode -filetype=obj < %t.tgtattr \
; RUN:   | llvm-objdump -d -M no-aliases - | FileCheck %s
; RUN: %riscv64y_purecap_llc -mattr=+c,+y,+cap-mode,+xcheri-norvc -filetype=obj < %t.tgtattr \
; RUN:   | llvm-objdump -d -M no-aliases --mattr=+y - | FileCheck %s --check-prefix=CHECK-NORVC

; RUN: cat %s > %t.fnattr
; RUN: echo 'attributes #0 = { nounwind "target-features"="+c,+y,+cap-mode" }' >> %t.fnattr
; RUN: %riscv32y_purecap_llc -filetype=obj < %t.fnattr \
; RUN:   | llvm-objdump -d --mattr=+c -M no-aliases - | FileCheck %s
; RUN: %riscv64y_purecap_llc -filetype=obj < %t.fnattr \
; RUN:   | llvm-objdump -d --mattr=+c -M no-aliases - | FileCheck %s
; RUN: cat %s > %t.fnattr
; RUN: echo 'attributes #0 = { nounwind "target-features"="+c,+y,+cap-mode,+xcheri-norvc" }' >> %t.fnattr
; RUN: %riscv64y_purecap_llc -filetype=obj < %t.fnattr \
; RUN:   | llvm-objdump -d --mattr=+c -M no-aliases --mattr=+y - | FileCheck %s --check-prefix=CHECK-NORVC


define i32 @loadstore(ptr addrspace(200) %intptrarg, ptr addrspace(200) %ptrptrarg) addrspace(200) #0 {
; CHECK-LABEL: <loadstore>:
; CHECK-NEXT:    c.cincoffset16csp csp, -32
; CHECK-NEXT:    c.lw a2, 0(ca0)
; CHECK-NEXT:    c.li a3, 1
; CHECK-NEXT:    c.sw a3, 0(ca0)
; CHECK-NEXT:    c.lc ca0, 0(ca1)
; CHECK-NEXT:    c.sc ca0, 0(ca1)
; CHECK-NEXT:    c.scsp ca0, 16(csp)
; CHECK-NEXT:    c.lcsp ca0, 16(csp)
; CHECK-NEXT:    c.swsp a2, 0(csp)
; CHECK-NEXT:    c.lwsp a0, 0(csp)
; CHECK-NEXT:    addi a0, a2, 0
; CHECK-NEXT:    c.cincoffset16csp csp, 32
; CHECK-NEXT:    c.jr cra
; CHECK-NORVC-LABEL: <loadstore>:
; CHECK-NORVC-NEXT:  {{[^a-z.]}}addiy csp, csp, -32
; CHECK-NORVC-NEXT:  {{[^a-z.]}}lw a2, 0(ca0)
; CHECK-NORVC-NEXT:  {{[^a-z.]}}c.li a3, 1
; CHECK-NORVC-NEXT:  {{[^a-z.]}}sw a3, 0(ca0)
; CHECK-NORVC-NEXT:  {{[^a-z.]}}ly ca0, 0(ca1)
; CHECK-NORVC-NEXT:  {{[^a-z.]}}sy ca0, 0(ca1)
; CHECK-NORVC-NEXT:  {{[^a-z.]}}sy ca0, 16(csp)
; CHECK-NORVC-NEXT:  {{[^a-z.]}}ly ca0, 16(csp)
; CHECK-NORVC-NEXT:  {{[^a-z.]}}sw a2, 0(csp)
; CHECK-NORVC-NEXT:  {{[^a-z.]}}lw a0, 0(csp)
; CHECK-NORVC-NEXT:  {{[^a-z.]}}addi a0, a2, 0
; CHECK-NORVC-NEXT:  {{[^a-z.]}}addiy csp, csp, 32
; CHECK-NORVC-NEXT:  {{[^a-z.]}}jalr cnull, 0(cra)
  %stackptr = alloca ptr addrspace(200), align 16, addrspace(200)
  %stackint = alloca i32, align 16, addrspace(200)
  %val = load volatile i32, ptr addrspace(200) %intptrarg
  store volatile i32 1, ptr addrspace(200) %intptrarg
  %ptrval = load volatile ptr addrspace(200), ptr addrspace(200) %ptrptrarg
  store volatile ptr addrspace(200) %ptrval, ptr addrspace(200) %ptrptrarg
  store volatile ptr addrspace(200) %ptrval, ptr addrspace(200) %stackptr
  %stackptrval = load volatile ptr addrspace(200), ptr addrspace(200) %stackptr
  store volatile i32 %val, ptr addrspace(200) %stackint
  %stackintval = load volatile i32, ptr addrspace(200) %stackint
  ret i32 %val
}
