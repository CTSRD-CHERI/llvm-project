; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; TODO: support +zfhmin patterns for load_f16
; RUN: llc -mtriple=riscv64 -target-abi l64pc128d -mattr=+d,-zfhmin,+xcheri,+cap-mode,+xcheri-std-compat < %s | FileCheck %s --check-prefix=PURECAP
; RUN: llc -mtriple=riscv64 -target-abi lp64d -mattr=+d,-zfhmin,+xcheri,-cap-mode,+xcheri-std-compat < %s | FileCheck %s --check-prefix=HYBRID
; RUN: llc -mtriple=riscv64 -target-abi lp64d -mattr=+d,-zfhmin,+xcheri,-cap-mode,-xcheri-std-compat < %s | FileCheck %s --check-prefix=HYBRID-XCHERI
; RUN: sed 's/addrspace(200)/addrspace(0)/g' %s | llc -mtriple=riscv64 -target-abi l64pc128d -mattr=+d,-zfhmin,+xcheri,+cap-mode,+xcheri-std-compat | FileCheck %s --check-prefix=PURECAP-DDC-LOADS

define internal i64 @load_i8_sext(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_i8_sext:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    clb a0, 0(ca0)
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_i8_sext:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    lb a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_i8_sext:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    lb.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_i8_sext:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    clb a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load i8, i8 addrspace(200)* %cap
  %ext = sext i8 %result to i64
  ret i64 %ext
}

define internal i64 @load_i8_zext(i8 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_i8_zext:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    clbu a0, 0(ca0)
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_i8_zext:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    lbu a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_i8_zext:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    lbu.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_i8_zext:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    clbu a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load i8, i8 addrspace(200)* %cap
  %ext = zext i8 %result to i64
  ret i64 %ext
}

define internal i64 @load_i16_sext(i16 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_i16_sext:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    clh a0, 0(ca0)
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_i16_sext:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    lh a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_i16_sext:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    lh.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_i16_sext:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    clh a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load i16, i16 addrspace(200)* %cap
  %ext = sext i16 %result to i64
  ret i64 %ext
}

define internal i64 @load_i16_zext(i16 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_i16_zext:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    clhu a0, 0(ca0)
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_i16_zext:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    lhu a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_i16_zext:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    lhu.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_i16_zext:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    clhu a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load i16, i16 addrspace(200)* %cap
  %ext = zext i16 %result to i64
  ret i64 %ext
}

define internal i64 @load_i32_sext(i32 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_i32_sext:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    clw a0, 0(ca0)
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_i32_sext:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    lw a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_i32_sext:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    lw.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_i32_sext:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    clw a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load i32, i32 addrspace(200)* %cap
  %ext = sext i32 %result to i64
  ret i64 %ext
}

define internal i64 @load_32_zext(i32 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_32_zext:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    clwu a0, 0(ca0)
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_32_zext:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    lwu a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_32_zext:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    lwu.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_32_zext:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    clwu a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load i32, i32 addrspace(200)* %cap
  %ext = zext i32 %result to i64
  ret i64 %ext
}

define internal i64 @load_i64(i64 addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_i64:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    cld a0, 0(ca0)
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_i64:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    ld a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_i64:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    ld.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_i64:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    cld a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load i64, i64 addrspace(200)* %cap
  ret i64 %result
}

define internal i8 addrspace(200)* @load_cap(i8 addrspace(200)* addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_cap:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    clc ca0, 0(ca0)
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_cap:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    lc ca0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_cap:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    lc.cap ca0, (ca0)
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_cap:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    cld a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %cap
  ret i8 addrspace(200)* %result
}

define internal half @load_f16(half addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_f16:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    cincoffset csp, csp, -16
; PURECAP-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-NEXT:    clhu a0, 0(ca0)
; PURECAP-NEXT:    fmv.w.x fa0, a0
; PURECAP-NEXT:    ccall __extendhfsf2
; PURECAP-NEXT:    lui a0, 260096
; PURECAP-NEXT:    fmv.w.x fa5, a0
; PURECAP-NEXT:    fadd.s fa0, fa0, fa5
; PURECAP-NEXT:    ccall __truncsfhf2
; PURECAP-NEXT:    fmv.x.w a0, fa0
; PURECAP-NEXT:    lui a1, 1048560
; PURECAP-NEXT:    or a0, a0, a1
; PURECAP-NEXT:    fmv.w.x fa0, a0
; PURECAP-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-NEXT:    cincoffset csp, csp, 16
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_f16:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    addi sp, sp, -16
; HYBRID-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    lhu a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    fmv.w.x fa0, a0
; HYBRID-NEXT:    call __extendhfsf2@plt
; HYBRID-NEXT:    lui a0, 260096
; HYBRID-NEXT:    fmv.w.x fa5, a0
; HYBRID-NEXT:    fadd.s fa0, fa0, fa5
; HYBRID-NEXT:    call __truncsfhf2@plt
; HYBRID-NEXT:    fmv.x.w a0, fa0
; HYBRID-NEXT:    lui a1, 1048560
; HYBRID-NEXT:    or a0, a0, a1
; HYBRID-NEXT:    fmv.w.x fa0, a0
; HYBRID-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-NEXT:    addi sp, sp, 16
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_f16:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    addi sp, sp, -16
; HYBRID-XCHERI-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
; HYBRID-XCHERI-NEXT:    lhu.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    fmv.w.x fa0, a0
; HYBRID-XCHERI-NEXT:    call __extendhfsf2@plt
; HYBRID-XCHERI-NEXT:    lui a0, 260096
; HYBRID-XCHERI-NEXT:    fmv.w.x fa5, a0
; HYBRID-XCHERI-NEXT:    fadd.s fa0, fa0, fa5
; HYBRID-XCHERI-NEXT:    call __truncsfhf2@plt
; HYBRID-XCHERI-NEXT:    fmv.x.w a0, fa0
; HYBRID-XCHERI-NEXT:    lui a1, 1048560
; HYBRID-XCHERI-NEXT:    or a0, a0, a1
; HYBRID-XCHERI-NEXT:    fmv.w.x fa0, a0
; HYBRID-XCHERI-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
; HYBRID-XCHERI-NEXT:    addi sp, sp, 16
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_f16:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    cincoffset csp, csp, -16
; PURECAP-DDC-LOADS-NEXT:    csc cra, 0(csp) # 16-byte Folded Spill
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    clhu a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    fmv.w.x fa0, a0
; PURECAP-DDC-LOADS-NEXT:    ccall __extendhfsf2
; PURECAP-DDC-LOADS-NEXT:    lui a0, 260096
; PURECAP-DDC-LOADS-NEXT:    fmv.w.x fa5, a0
; PURECAP-DDC-LOADS-NEXT:    fadd.s fa0, fa0, fa5
; PURECAP-DDC-LOADS-NEXT:    ccall __truncsfhf2
; PURECAP-DDC-LOADS-NEXT:    fmv.x.w a0, fa0
; PURECAP-DDC-LOADS-NEXT:    lui a1, 1048560
; PURECAP-DDC-LOADS-NEXT:    or a0, a0, a1
; PURECAP-DDC-LOADS-NEXT:    fmv.w.x fa0, a0
; PURECAP-DDC-LOADS-NEXT:    clc cra, 0(csp) # 16-byte Folded Reload
; PURECAP-DDC-LOADS-NEXT:    cincoffset csp, csp, 16
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load half, half addrspace(200)* %cap
  %plus_one = fadd half %result, 1.0
  ret half %plus_one
}

define internal float @load_f32(float addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_f32:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    cflw fa5, 0(ca0)
; PURECAP-NEXT:    lui a0, 260096
; PURECAP-NEXT:    fmv.w.x fa4, a0
; PURECAP-NEXT:    fadd.s fa0, fa5, fa4
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_f32:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    lw a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    fmv.w.x fa5, a0
; HYBRID-NEXT:    lui a0, 260096
; HYBRID-NEXT:    fmv.w.x fa4, a0
; HYBRID-NEXT:    fadd.s fa0, fa5, fa4
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_f32:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    lw.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    fmv.w.x fa5, a0
; HYBRID-XCHERI-NEXT:    lui a0, 260096
; HYBRID-XCHERI-NEXT:    fmv.w.x fa4, a0
; HYBRID-XCHERI-NEXT:    fadd.s fa0, fa5, fa4
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_f32:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    clw a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:    fmv.w.x fa5, a0
; PURECAP-DDC-LOADS-NEXT:    lui a0, 260096
; PURECAP-DDC-LOADS-NEXT:    fmv.w.x fa4, a0
; PURECAP-DDC-LOADS-NEXT:    fadd.s fa0, fa5, fa4
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load float, float addrspace(200)* %cap
  %plus_one = fadd float %result, 1.0
  ret float %plus_one
}

define internal double @load_f64(double addrspace(200)* %cap) nounwind {
; PURECAP-LABEL: load_f64:
; PURECAP:       # %bb.0: # %entry
; PURECAP-NEXT:    cfld fa5, 0(ca0)
; PURECAP-NEXT:  .LBB10_1: # %entry
; PURECAP-NEXT:    # Label of block must be emitted
; PURECAP-NEXT:    auipcc ca0, %pcrel_hi(.LCPI10_0)
; PURECAP-NEXT:    cincoffset ca0, ca0, %pcrel_lo(.LBB10_1)
; PURECAP-NEXT:    cfld fa4, 0(ca0)
; PURECAP-NEXT:    fadd.d fa0, fa5, fa4
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: load_f64:
; HYBRID:       # %bb.0: # %entry
; HYBRID-NEXT:    modesw.cap
; HYBRID-NEXT:    ld a0, 0(a0)
; HYBRID-NEXT:    modesw.int
; HYBRID-NEXT:    lui a1, %hi(.LCPI10_0)
; HYBRID-NEXT:    fld fa5, %lo(.LCPI10_0)(a1)
; HYBRID-NEXT:    fmv.d.x fa4, a0
; HYBRID-NEXT:    fadd.d fa0, fa4, fa5
; HYBRID-NEXT:    ret
;
; HYBRID-XCHERI-LABEL: load_f64:
; HYBRID-XCHERI:       # %bb.0: # %entry
; HYBRID-XCHERI-NEXT:    ld.cap a0, (ca0)
; HYBRID-XCHERI-NEXT:    lui a1, %hi(.LCPI10_0)
; HYBRID-XCHERI-NEXT:    fld fa5, %lo(.LCPI10_0)(a1)
; HYBRID-XCHERI-NEXT:    fmv.d.x fa4, a0
; HYBRID-XCHERI-NEXT:    fadd.d fa0, fa4, fa5
; HYBRID-XCHERI-NEXT:    ret
;
; PURECAP-DDC-LOADS-LABEL: load_f64:
; PURECAP-DDC-LOADS:       # %bb.0: # %entry
; PURECAP-DDC-LOADS-NEXT:    modesw.int
; PURECAP-DDC-LOADS-NEXT:    cld a0, 0(ca0)
; PURECAP-DDC-LOADS-NEXT:    modesw.cap
; PURECAP-DDC-LOADS-NEXT:  .LBB10_1: # %entry
; PURECAP-DDC-LOADS-NEXT:    # Label of block must be emitted
; PURECAP-DDC-LOADS-NEXT:    auipcc ca1, %pcrel_hi(.LCPI10_0)
; PURECAP-DDC-LOADS-NEXT:    cincoffset ca1, ca1, %pcrel_lo(.LBB10_1)
; PURECAP-DDC-LOADS-NEXT:    cfld fa5, 0(ca1)
; PURECAP-DDC-LOADS-NEXT:    fmv.d.x fa4, a0
; PURECAP-DDC-LOADS-NEXT:    fadd.d fa0, fa4, fa5
; PURECAP-DDC-LOADS-NEXT:    cret
entry:
  %result = load double, double addrspace(200)* %cap
  %plus_one = fadd double %result, 1.0
  ret double %plus_one
}
