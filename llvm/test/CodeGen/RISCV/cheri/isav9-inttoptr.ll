; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
;; Check that we don't emit CFromPtr when lowering inttoptr for ISAv9.
; RUN: %riscv64_cheri_purecap_llc -mattr=+xcheri-v9-semantics < %s | FileCheck %s --check-prefix=PURECAP
; RUN: %riscv64_cheri_llc -mattr=+xcheri-v9-semantics < %s | FileCheck %s --check-prefix=HYBRID
;; Also emit a .o file since verifyInstructionPredicates() is only called for binary output.
; RUN: %riscv64_cheri_purecap_llc -mattr=+xcheri-v9-semantics -filetype=obj -o /dev/null < %s
; RUN: %riscv64_cheri_llc -mattr=+xcheri-v9-semantics -filetype=obj -o /dev/null < %s

define dso_local i8 addrspace(200)* @inttoptr(i64 %ptr) addrspace(200) nounwind {
; PURECAP-LABEL: inttoptr:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset ca0, cnull, a0
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: inttoptr:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cspecialr ca1, ddc
; HYBRID-NEXT:    bnez a0, .LBB0_2
; HYBRID-NEXT:  # %bb.1:
; HYBRID-NEXT:    cmove ca0, cnull
; HYBRID-NEXT:    ret
; HYBRID-NEXT:  .LBB0_2:
; HYBRID-NEXT:    csetaddr ca0, ca1, a0
; HYBRID-NEXT:    ret
  %ret = inttoptr i64 %ptr to i8 addrspace(200)*
  ret i8 addrspace(200)* %ret
}

define dso_local i8 addrspace(200)* @inttoptr_plus_const(i64 %ptr) addrspace(200) nounwind {
; PURECAP-LABEL: inttoptr_plus_const:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset ca0, cnull, a0
; PURECAP-NEXT:    cincoffset ca0, ca0, 2
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: inttoptr_plus_const:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cspecialr ca1, ddc
; HYBRID-NEXT:    bnez a0, .LBB1_2
; HYBRID-NEXT:  # %bb.1:
; HYBRID-NEXT:    cincoffset ca0, cnull, 2
; HYBRID-NEXT:    ret
; HYBRID-NEXT:  .LBB1_2:
; HYBRID-NEXT:    csetaddr ca0, ca1, a0
; HYBRID-NEXT:    cincoffset ca0, ca0, 2
; HYBRID-NEXT:    ret
  %cap = inttoptr i64 %ptr to i8 addrspace(200)*
  %ret = getelementptr i8, i8 addrspace(200)* %cap, i64 2
  ret i8 addrspace(200)* %ret
}

;; CFromPtr has been removed from CHERI ISAv9, but we want to retain the
;; semantics that inttoptr of a variable that happens to be zero will result in
;; an untagged value. This means we can't just expand inttoptr to CSetAddr on
;; DDC since using that with address zero could result in a valid capability.
;; Therefore we have to insert a conditional branch and emit
;; `x.addr == 0 ? null : CSetAddr DDC, x` instead. This is a rather long code
;; sequence due to lack of conditional moves, but it should happen rarely.

define dso_local i8 addrspace(200)* @inttoptr_plus_var(i64 %ptr, i64 %add) addrspace(200) nounwind {
; PURECAP-LABEL: inttoptr_plus_var:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset ca0, cnull, a0
; PURECAP-NEXT:    cincoffset ca0, ca0, a1
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: inttoptr_plus_var:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cspecialr ca2, ddc
; HYBRID-NEXT:    bnez a0, .LBB2_2
; HYBRID-NEXT:  # %bb.1:
; HYBRID-NEXT:    cincoffset ca0, cnull, a1
; HYBRID-NEXT:    ret
; HYBRID-NEXT:  .LBB2_2:
; HYBRID-NEXT:    csetaddr ca0, ca2, a0
; HYBRID-NEXT:    cincoffset ca0, ca0, a1
; HYBRID-NEXT:    ret
  %cap = inttoptr i64 %ptr to i8 addrspace(200)*
  %ret = getelementptr i8, i8 addrspace(200)* %cap, i64 %add
  ret i8 addrspace(200)* %ret
}

define dso_local i8 addrspace(200)* @inttoptr_null() addrspace(200) nounwind {
; PURECAP-LABEL: inttoptr_null:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cmove ca0, cnull
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: inttoptr_null:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cmove ca0, cnull
; HYBRID-NEXT:    ret
  %ret = inttoptr i64 0 to i8 addrspace(200)*
  ret i8 addrspace(200)* %ret
}

define dso_local i8 addrspace(200)* @inttoptr_null_plus_const() addrspace(200) nounwind {
; PURECAP-LABEL: inttoptr_null_plus_const:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset ca0, cnull, 2
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: inttoptr_null_plus_const:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cincoffset ca0, cnull, 2
; HYBRID-NEXT:    ret
  %null = inttoptr i64 0 to i8 addrspace(200)*
  %ret = getelementptr i8, i8 addrspace(200)* %null, i64 2
  ret i8 addrspace(200)* %ret
}

define dso_local i8 addrspace(200)* @inttoptr_null_plus_var(i64 %add) addrspace(200) nounwind {
; PURECAP-LABEL: inttoptr_null_plus_var:
; PURECAP:       # %bb.0:
; PURECAP-NEXT:    cincoffset ca0, cnull, a0
; PURECAP-NEXT:    cret
;
; HYBRID-LABEL: inttoptr_null_plus_var:
; HYBRID:       # %bb.0:
; HYBRID-NEXT:    cincoffset ca0, cnull, a0
; HYBRID-NEXT:    ret
  %null = inttoptr i64 0 to i8 addrspace(200)*
  %ret = getelementptr i8, i8 addrspace(200)* %null, i64 %add
  ret i8 addrspace(200)* %ret
}
