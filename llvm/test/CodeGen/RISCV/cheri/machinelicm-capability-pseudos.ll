; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %riscv32_cheri_purecap_llc -relocation-model=pic -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefixes=RV32I %s
; RUN: %riscv64_cheri_purecap_llc -relocation-model=pic -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefixes=RV64I %s

; Verifies that MachineLICM can hoist capability generation/loading pseudos out
; of loops.

@g = addrspace(200) global i32 0, align 4

define void @test_clgc(i32 signext %n) {
; RV32I-LABEL: test_clgc:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:  .LBB0_3: # %entry
; RV32I-NEXT:    # Label of block must be emitted
; RV32I-NEXT:    auipcc ca1, %captab_pcrel_hi(g)
; RV32I-NEXT:    lc ca1, %pcrel_lo(.LBB0_3)(ca1)
; RV32I-NEXT:    li a2, 0
; RV32I-NEXT:  .LBB0_1: # %loop
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    lw a3, 0(ca1)
; RV32I-NEXT:    addi a2, a2, 1
; RV32I-NEXT:    blt a2, a0, .LBB0_1
; RV32I-NEXT:  # %bb.2: # %ret
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_clgc:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:  .LBB0_3: # %entry
; RV64I-NEXT:    # Label of block must be emitted
; RV64I-NEXT:    auipcc ca1, %captab_pcrel_hi(g)
; RV64I-NEXT:    lc ca1, %pcrel_lo(.LBB0_3)(ca1)
; RV64I-NEXT:    li a2, 0
; RV64I-NEXT:  .LBB0_1: # %loop
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    lw a3, 0(ca1)
; RV64I-NEXT:    addiw a2, a2, 1
; RV64I-NEXT:    blt a2, a0, .LBB0_1
; RV64I-NEXT:  # %bb.2: # %ret
; RV64I-NEXT:    ret
entry:
  br label %loop

loop:
  %i = phi i32 [ %inc, %loop ], [ 0, %entry ]
  %0 = load volatile i32, i32 addrspace(200)* @g, align 4
  %inc = add nuw nsw i32 %i, 1
  %cmp = icmp slt i32 %inc, %n
  br i1 %cmp, label %loop, label %ret

ret:
  ret void
}

@ie = external thread_local(initialexec) addrspace(200) global i32

define void @test_cla_tls_ie(i32 signext %n) {
; RV32I-LABEL: test_cla_tls_ie:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:  .LBB1_3: # %entry
; RV32I-NEXT:    # Label of block must be emitted
; RV32I-NEXT:    auipcc ca2, %tls_ie_captab_pcrel_hi(ie)
; RV32I-NEXT:    lw a2, %pcrel_lo(.LBB1_3)(ca2)
; RV32I-NEXT:    li a1, 0
; RV32I-NEXT:    cincoffset ca2, ctp, a2
; RV32I-NEXT:  .LBB1_1: # %loop
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    lw a3, 0(ca2)
; RV32I-NEXT:    addi a1, a1, 1
; RV32I-NEXT:    blt a1, a0, .LBB1_1
; RV32I-NEXT:  # %bb.2: # %ret
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_cla_tls_ie:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:  .LBB1_3: # %entry
; RV64I-NEXT:    # Label of block must be emitted
; RV64I-NEXT:    auipcc ca2, %tls_ie_captab_pcrel_hi(ie)
; RV64I-NEXT:    ld a2, %pcrel_lo(.LBB1_3)(ca2)
; RV64I-NEXT:    li a1, 0
; RV64I-NEXT:    cincoffset ca2, ctp, a2
; RV64I-NEXT:  .LBB1_1: # %loop
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    lw a3, 0(ca2)
; RV64I-NEXT:    addiw a1, a1, 1
; RV64I-NEXT:    blt a1, a0, .LBB1_1
; RV64I-NEXT:  # %bb.2: # %ret
; RV64I-NEXT:    ret
entry:
  br label %loop

loop:
  %i = phi i32 [ %inc, %loop ], [ 0, %entry ]
  %0 = load volatile i32, i32 addrspace(200)* @ie, align 4
  %inc = add nuw nsw i32 %i, 1
  %cmp = icmp slt i32 %inc, %n
  br i1 %cmp, label %loop, label %ret

ret:
  ret void
}

@gd = external thread_local addrspace(200) global i32

define void @test_clc_tls_gd(i32 signext %n) nounwind {
; RV32I-LABEL: test_clc_tls_gd:
; RV32I:       # %bb.0: # %entry
; RV32I-NEXT:    cincoffset csp, csp, -32
; RV32I-NEXT:    sc cra, 24(csp) # 8-byte Folded Spill
; RV32I-NEXT:    sc cs0, 16(csp) # 8-byte Folded Spill
; RV32I-NEXT:    sc cs1, 8(csp) # 8-byte Folded Spill
; RV32I-NEXT:    sc cs2, 0(csp) # 8-byte Folded Spill
; RV32I-NEXT:    mv s0, a0
; RV32I-NEXT:    li s2, 0
; RV32I-NEXT:  .LBB2_3: # %entry
; RV32I-NEXT:    # Label of block must be emitted
; RV32I-NEXT:    auipcc cs1, %tls_gd_captab_pcrel_hi(gd)
; RV32I-NEXT:    cincoffset cs1, cs1, %pcrel_lo(.LBB2_3)
; RV32I-NEXT:  .LBB2_1: # %loop
; RV32I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV32I-NEXT:    cmove ca0, cs1
; RV32I-NEXT:    ccall __tls_get_addr
; RV32I-NEXT:    lw a0, 0(ca0)
; RV32I-NEXT:    addi s2, s2, 1
; RV32I-NEXT:    blt s2, s0, .LBB2_1
; RV32I-NEXT:  # %bb.2: # %ret
; RV32I-NEXT:    lc cra, 24(csp) # 8-byte Folded Reload
; RV32I-NEXT:    lc cs0, 16(csp) # 8-byte Folded Reload
; RV32I-NEXT:    lc cs1, 8(csp) # 8-byte Folded Reload
; RV32I-NEXT:    lc cs2, 0(csp) # 8-byte Folded Reload
; RV32I-NEXT:    cincoffset csp, csp, 32
; RV32I-NEXT:    ret
;
; RV64I-LABEL: test_clc_tls_gd:
; RV64I:       # %bb.0: # %entry
; RV64I-NEXT:    cincoffset csp, csp, -64
; RV64I-NEXT:    sc cra, 48(csp) # 16-byte Folded Spill
; RV64I-NEXT:    sc cs0, 32(csp) # 16-byte Folded Spill
; RV64I-NEXT:    sc cs1, 16(csp) # 16-byte Folded Spill
; RV64I-NEXT:    sc cs2, 0(csp) # 16-byte Folded Spill
; RV64I-NEXT:    mv s0, a0
; RV64I-NEXT:    li s2, 0
; RV64I-NEXT:  .LBB2_3: # %entry
; RV64I-NEXT:    # Label of block must be emitted
; RV64I-NEXT:    auipcc cs1, %tls_gd_captab_pcrel_hi(gd)
; RV64I-NEXT:    cincoffset cs1, cs1, %pcrel_lo(.LBB2_3)
; RV64I-NEXT:  .LBB2_1: # %loop
; RV64I-NEXT:    # =>This Inner Loop Header: Depth=1
; RV64I-NEXT:    cmove ca0, cs1
; RV64I-NEXT:    ccall __tls_get_addr
; RV64I-NEXT:    lw a0, 0(ca0)
; RV64I-NEXT:    addiw s2, s2, 1
; RV64I-NEXT:    blt s2, s0, .LBB2_1
; RV64I-NEXT:  # %bb.2: # %ret
; RV64I-NEXT:    lc cra, 48(csp) # 16-byte Folded Reload
; RV64I-NEXT:    lc cs0, 32(csp) # 16-byte Folded Reload
; RV64I-NEXT:    lc cs1, 16(csp) # 16-byte Folded Reload
; RV64I-NEXT:    lc cs2, 0(csp) # 16-byte Folded Reload
; RV64I-NEXT:    cincoffset csp, csp, 64
; RV64I-NEXT:    ret
entry:
  br label %loop

loop:
  %i = phi i32 [ %inc, %loop ], [ 0, %entry ]
  %0 = load volatile i32, i32 addrspace(200)* @gd, align 4
  %inc = add nuw nsw i32 %i, 1
  %cmp = icmp slt i32 %inc, %n
  br i1 %cmp, label %loop, label %ret

ret:
  ret void
}
