; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --force-update
; RUN: opt < %s -aa-pipeline=basic-aa -passes=gvn -S | FileCheck -check-prefix=CHECK-GVN %s
; RUN: opt < %s -aa-pipeline=basic-aa -passes=aa-eval -print-all-alias-modref-info -disable-output 2>&1 | FileCheck %s

target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"

; Check that we don't propagate the value of 42 from the setbounds call.

;
;
; struct A { virtual void f(); int n; };
;
; int h() {
;     A a;
;     a.n = 42;
;     return __builtin_cheri_bounds_set(&a, 4)->n;
; }

%struct.A = type <{ i8*, i8 }>


declare i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)*, i64)
declare i8 addrspace(200)* @llvm.cheri.cap.offset.increment.i64(i8 addrspace(200)*, i64)

; make sure that the load from %n.laundered to %v is performed even though the actual pointer aliases!
; Due to the bounds shrinking performed by setbounds the value is not accessible!
define i8 @testBoundsSetAlias() {
; CHECK-LABEL: Function: testBoundsSetAlias: 2 pointers, 1 call sites
; CHECK-NEXT  MayAlias:	i8 addrspace(200)* %n, i8 addrspace(200)* %n.laundered
; CHECK-NEXT  NoModRef:  Ptr: i8* %n	<->  %a.laundered = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %a.bitcast, i64 4)
; CHECK-NEXT  NoModRef:  Ptr: i8* %n.laundered	<->  %a.laundered = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %a.bitcast, i64 4)
; CHECK-GVN-LABEL: @testBoundsSetAlias(
; CHECK-GVN-NEXT:  entry:
; CHECK-GVN-NEXT:    [[A:%.*]] = alloca [[STRUCT_A:%.*]], align 8, addrspace(200)
; CHECK-GVN-NEXT:    [[A_BITCAST:%.*]] = bitcast [[STRUCT_A]] addrspace(200)* [[A]] to i8 addrspace(200)*
; CHECK-GVN-NEXT:    [[N:%.*]] = getelementptr inbounds [[STRUCT_A]], [[STRUCT_A]] addrspace(200)* [[A]], i64 0, i32 1
; CHECK-GVN-NEXT:    store i8 42, i8 addrspace(200)* [[N]], align 1
; CHECK-GVN-NEXT:    [[A_LAUNDERED:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull [[A_BITCAST]], i64 4)
; CHECK-GVN-NEXT:    [[N_LAUNDERED:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[A_LAUNDERED]], i64 8
; CHECK-GVN-NEXT:    [[V:%.*]] = load i8, i8 addrspace(200)* [[N_LAUNDERED]], align 1
; CHECK-GVN-NEXT:    ret i8 [[V]]
;
entry:
  %a = alloca %struct.A, align 8, addrspace(200)
  %a.bitcast = bitcast %struct.A addrspace(200)* %a to i8 addrspace(200)*
  %n = getelementptr inbounds %struct.A, %struct.A addrspace(200)* %a, i64 0, i32 1
  store i8 42, i8 addrspace(200)* %n
  %a.laundered = call i8 addrspace(200)* @llvm.cheri.cap.bounds.set.i64(i8 addrspace(200)* nonnull %a.bitcast, i64 4)
  %n.laundered = getelementptr inbounds i8, i8 addrspace(200)* %a.laundered, i64 8
  %v = load i8, i8 addrspace(200)* %n.laundered
  ret i8 %v
}

; Also check that GEP does not alias (except when offset is zero)
define i8 @testIncOffsetAlias() {
; CHECK-LABEL: Function: testIncOffsetAlias: 2 pointers, 0 call sites
; CHECK-DAG:     NoAlias:	i8 addrspace(200)* %n, i8 addrspace(200)* %n.laundered
; CHECK-GVN-LABEL: @testIncOffsetAlias(
; CHECK-GVN-NEXT:  entry:
; CHECK-GVN-NEXT:    [[A:%.*]] = alloca [[STRUCT_A:%.*]], align 8, addrspace(200)
; CHECK-GVN-NEXT:    [[A_BITCAST:%.*]] = bitcast [[STRUCT_A]] addrspace(200)* [[A]] to i8 addrspace(200)*
; CHECK-GVN-NEXT:    [[N:%.*]] = getelementptr inbounds [[STRUCT_A]], [[STRUCT_A]] addrspace(200)* [[A]], i64 0, i32 1
; CHECK-GVN-NEXT:    store i8 42, i8 addrspace(200)* [[N]], align 1
; CHECK-GVN-NEXT:    [[A_LAUNDERED:%.*]] = getelementptr i8, i8 addrspace(200)* [[A_BITCAST]], i64 4
; CHECK-GVN-NEXT:    [[N_LAUNDERED:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[A_LAUNDERED]], i64 8
; CHECK-GVN-NEXT:    ret i8 undef
;
entry:
  %a = alloca %struct.A, align 8, addrspace(200)
  %a.bitcast = bitcast %struct.A addrspace(200)* %a to i8 addrspace(200)*
  %n = getelementptr inbounds %struct.A, %struct.A addrspace(200)* %a, i64 0, i32 1
  store i8 42, i8 addrspace(200)* %n
  %a.laundered = getelementptr i8, i8 addrspace(200)* %a.bitcast, i64 4
  %n.laundered = getelementptr inbounds i8, i8 addrspace(200)* %a.laundered, i64 8
  %v = load i8, i8 addrspace(200)* %n.laundered
  ; uninitialized load:
  ret i8 %v
}

define i8 @testIncOffsetZeroAlias() {
; CHECK-LABEL: Function: testIncOffsetZeroAlias: 2 pointers, 0 call sites
; CHECK-NEXT:  MustAlias:	i8 addrspace(200)* %n, i8 addrspace(200)* %n.laundered
; CHECK-GVN-LABEL: @testIncOffsetZeroAlias(
; CHECK-GVN-NEXT:  entry:
; CHECK-GVN-NEXT:    [[A:%.*]] = alloca [[STRUCT_A:%.*]], align 8, addrspace(200)
; CHECK-GVN-NEXT:    [[A_BITCAST:%.*]] = bitcast [[STRUCT_A]] addrspace(200)* [[A]] to i8 addrspace(200)*
; CHECK-GVN-NEXT:    [[N:%.*]] = getelementptr inbounds [[STRUCT_A]], [[STRUCT_A]] addrspace(200)* [[A]], i64 0, i32 1
; CHECK-GVN-NEXT:    store i8 42, i8 addrspace(200)* [[N]], align 1
; CHECK-GVN-NEXT:    [[N_LAUNDERED:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[A_BITCAST]], i64 8
; CHECK-GVN-NEXT:    ret i8 42
;
entry:
  %a = alloca %struct.A, align 8, addrspace(200)
  %a.bitcast = bitcast %struct.A addrspace(200)* %a to i8 addrspace(200)*
  %n = getelementptr inbounds %struct.A, %struct.A addrspace(200)* %a, i64 0, i32 1
  store i8 42, i8 addrspace(200)* %n
  %a.laundered = getelementptr i8, i8 addrspace(200)* %a.bitcast, i64 0
  %n.laundered = getelementptr inbounds i8, i8 addrspace(200)* %a.laundered, i64 8
  %v = load i8, i8 addrspace(200)* %n.laundered
  ret i8 %v
}
