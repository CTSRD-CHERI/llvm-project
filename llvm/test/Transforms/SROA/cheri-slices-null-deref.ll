; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -S -passes='sroa<modify-cfg>' < %s | FileCheck %s
;; This is a test for a non-deterministic crash in SROA that depends on Module iteration order
;; In some cases we were dereferencing the user of an already-killed slice.
;; This was noticed while doing a two-stage build of clang and compiling X86IselLowering.
;; Generated from the following reduced C++ test case:
;; struct SDValue {
;;   int *Node;
;;   unsigned ResNo;
;; };
;; 
;; void detectAVGPattern() {
;;   SDValue Operands[3];
;;   for (SDValue &Op : Operands) {
;;     std::swap(Op, Operands[2]);
;;   }
;; }

target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.SDValue = type { ptr, i32 }

define dso_local void @_Z16detectAVGPatternv() local_unnamed_addr #0 {
; CHECK-LABEL: define dso_local void @_Z16detectAVGPatternv
; CHECK-SAME: () local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[__T_I:%.*]] = alloca [[STRUCT_SDVALUE:%.*]], align 8
; CHECK-NEXT:    [[OPERANDS_SROA_0:%.*]] = alloca [[STRUCT_SDVALUE]], align 16
; CHECK-NEXT:    [[OPERANDS_SROA_4:%.*]] = alloca [[STRUCT_SDVALUE]], align 16
; CHECK-NEXT:    [[OPERANDS_SROA_6:%.*]] = alloca [[STRUCT_SDVALUE]], align 16
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[OPERANDS_SROA_0]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[OPERANDS_SROA_4]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[OPERANDS_SROA_6]])
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[__T_I]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[__T_I]], ptr align 16 [[OPERANDS_SROA_0]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) [[OPERANDS_SROA_0]], ptr noundef nonnull align 16 dereferenceable(16) [[OPERANDS_SROA_6]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[OPERANDS_SROA_6]], ptr align 8 [[__T_I]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[__T_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[__T_I]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[__T_I]], ptr align 16 [[OPERANDS_SROA_4]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) [[OPERANDS_SROA_4]], ptr noundef nonnull align 16 dereferenceable(16) [[OPERANDS_SROA_6]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[OPERANDS_SROA_6]], ptr align 8 [[__T_I]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[__T_I]])
; CHECK-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr [[__T_I]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[__T_I]], ptr align 16 [[OPERANDS_SROA_6]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[OPERANDS_SROA_6]], ptr align 8 [[__T_I]], i64 16, i1 false)
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[__T_I]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[OPERANDS_SROA_0]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[OPERANDS_SROA_4]])
; CHECK-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr [[OPERANDS_SROA_6]])
; CHECK-NEXT:    ret void
;
entry:
  %__t.i = alloca %struct.SDValue, align 8
  %Operands = alloca [3 x %struct.SDValue], align 16
  call void @llvm.lifetime.start.p0(i64 48, ptr nonnull %Operands) #3
  %arrayidx = getelementptr inbounds [3 x %struct.SDValue], ptr %Operands, i64 0, i64 2
  br label %for.body

for.body:                                         ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %__t.i)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %__t.i, ptr noundef nonnull align 16 dereferenceable(16) %Operands, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %Operands, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx, ptr noundef nonnull align 8 dereferenceable(16) %__t.i, i64 16, i1 false)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %__t.i)
  %__begin1.0.ptr.1 = getelementptr inbounds %struct.SDValue, ptr %Operands, i64 1
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %__t.i)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %__t.i, ptr noundef nonnull align 16 dereferenceable(16) %__begin1.0.ptr.1, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %__begin1.0.ptr.1, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx, ptr noundef nonnull align 8 dereferenceable(16) %__t.i, i64 16, i1 false)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %__t.i)
  %__begin1.0.ptr.2 = getelementptr inbounds %struct.SDValue, ptr %Operands, i64 2
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %__t.i)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %__t.i, ptr noundef nonnull align 16 dereferenceable(16) %__begin1.0.ptr.2, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %__begin1.0.ptr.2, ptr noundef nonnull align 16 dereferenceable(16) %arrayidx, i64 16, i1 false)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 16 dereferenceable(16) %arrayidx, ptr noundef nonnull align 8 dereferenceable(16) %__t.i, i64 16, i1 false)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %__t.i)
  call void @llvm.lifetime.end.p0(i64 48, ptr nonnull %Operands) #3
  ret void
}

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg)

attributes #0 = { mustprogress nounwind }
attributes #1 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #3 = { nounwind }
