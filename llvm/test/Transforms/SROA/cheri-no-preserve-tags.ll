; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature
; RUN: opt -S -passes=sroa < %s | FileCheck %s
; This test case shows that we can make use of no_preserve_cheri_tags in SROA.
; It is based on @unaligned_copy_buf from cheri-cap-align.ll since I couldn't
; easily come up with a more minimal test case.
target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128"
target triple = "riscv64-unknown-freebsd"

%struct = type { i32, i32, i32, i32, [16 x i8] }
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture writeonly, i8* nocapture readonly, i64, i1 immarg)

define void @no_attribute(%struct* %px) {
; CHECK-LABEL: define {{[^@]+}}@no_attribute
; CHECK-SAME: (%struct* [[PX:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[PY_SROA_0:%.*]] = alloca [16 x i8], align 16
; CHECK-NEXT:    [[PY_SROA_2:%.*]] = alloca [16 x i8], align 16
; CHECK-NEXT:    [[PY_SROA_0_0_PX_CAST_SROA_CAST:%.*]] = bitcast %struct* [[PX]] to i8*
; CHECK-NEXT:    [[PY_SROA_0_0_PY_CAST_SROA_IDX:%.*]] = getelementptr inbounds [16 x i8], [16 x i8]* [[PY_SROA_0]], i64 0, i64 0
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 [[PY_SROA_0_0_PY_CAST_SROA_IDX]], i8* align 16 [[PY_SROA_0_0_PX_CAST_SROA_CAST]], i64 16, i1 false)
; CHECK-NEXT:    [[PY_SROA_2_0_PX_CAST_SROA_IDX:%.*]] = getelementptr inbounds [[STRUCT:%.*]], %struct* [[PX]], i64 0, i32 4, i64 0
; CHECK-NEXT:    [[PY_SROA_2_0_PY_CAST_SROA_IDX1:%.*]] = getelementptr inbounds [16 x i8], [16 x i8]* [[PY_SROA_2]], i64 0, i64 0
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 [[PY_SROA_2_0_PY_CAST_SROA_IDX1]], i8* align 16 [[PY_SROA_2_0_PX_CAST_SROA_IDX]], i64 16, i1 false)
; CHECK-NEXT:    [[PY_SROA_0_4_PX_TAIL_SROA_IDX:%.*]] = getelementptr inbounds [[STRUCT]], %struct* [[PX]], i64 0, i32 1
; CHECK-NEXT:    [[PY_SROA_0_4_PX_TAIL_SROA_CAST:%.*]] = bitcast i32* [[PY_SROA_0_4_PX_TAIL_SROA_IDX]] to i8*
; CHECK-NEXT:    [[PY_SROA_0_4_PY_TAIL_SROA_IDX:%.*]] = getelementptr inbounds [16 x i8], [16 x i8]* [[PY_SROA_0]], i64 0, i64 4
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 [[PY_SROA_0_4_PX_TAIL_SROA_CAST]], i8* align 4 [[PY_SROA_0_4_PY_TAIL_SROA_IDX]], i64 12, i1 false)
; CHECK-NEXT:    [[PY_SROA_2_4_PX_TAIL_SROA_IDX:%.*]] = getelementptr inbounds [[STRUCT]], %struct* [[PX]], i64 0, i32 4, i64 0
; CHECK-NEXT:    [[PY_SROA_2_0_PY_TAIL_SROA_IDX:%.*]] = getelementptr inbounds [16 x i8], [16 x i8]* [[PY_SROA_2]], i64 0, i64 0
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 [[PY_SROA_2_4_PX_TAIL_SROA_IDX]], i8* align 16 [[PY_SROA_2_0_PY_TAIL_SROA_IDX]], i64 16, i1 false)
; CHECK-NEXT:    ret void
;
entry:
  %py = alloca [32 x i8], align 16
  %px.cast = bitcast %struct* %px to i8*
  %py.cast = bitcast [32 x i8]* %py to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %py.cast, i8* align 16 %px.cast, i64 32, i1 false)
  %px.tail = getelementptr inbounds i8, i8* %px.cast, i64 4
  %py.tail = getelementptr inbounds i8, i8* %py.cast, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %px.tail, i8* align 4 %py.tail, i64 28, i1 false)
  ret void
}

define void @with_attribute(%struct* %px) {
; CHECK-LABEL: define {{[^@]+}}@with_attribute
; CHECK-SAME: (%struct* [[PX:%.*]]) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[PY:%.*]] = alloca [32 x i8], align 16
; CHECK-NEXT:    [[PX_CAST:%.*]] = bitcast %struct* [[PX]] to i8*
; CHECK-NEXT:    [[PY_CAST:%.*]] = bitcast [32 x i8]* [[PY]] to i8*
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 [[PY_CAST]], i8* align 16 [[PX_CAST]], i64 32, i1 false) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    [[PX_TAIL:%.*]] = getelementptr inbounds i8, i8* [[PX_CAST]], i64 4
; CHECK-NEXT:    [[PY_TAIL:%.*]] = getelementptr inbounds i8, i8* [[PY_CAST]], i64 4
; CHECK-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 [[PX_TAIL]], i8* align 4 [[PY_TAIL]], i64 28, i1 false) #[[ATTR1]]
; CHECK-NEXT:    ret void
;
entry:
  %py = alloca [32 x i8], align 16
  %px.cast = bitcast %struct* %px to i8*
  %py.cast = bitcast [32 x i8]* %py to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 16 %py.cast, i8* align 16 %px.cast, i64 32, i1 false) no_preserve_cheri_tags
  %px.tail = getelementptr inbounds i8, i8* %px.cast, i64 4
  %py.tail = getelementptr inbounds i8, i8* %py.cast, i64 4
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* align 4 %px.tail, i8* align 4 %py.tail, i64 28, i1 false) no_preserve_cheri_tags
  ret void
}

; UTC_ARGS: --disable
; CHECK: attributes #[[ATTR1]] = { no_preserve_cheri_tags }
