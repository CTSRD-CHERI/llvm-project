; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes
; RUN: sed -e 's/@PTR_AS@/200/g' -e 's/@PTR_PAIR_SIZE@/32/g' %s \
; RUN:   | opt -opaque-pointers=0 -S -passes=sroa -o - | FileCheck %s
; RUN: sed -e 's/@PTR_AS@/0/g' -e 's/@PTR_PAIR_SIZE@/16/g' -e 's/-pf200:128:128:128:64//g' %s \
; RUN:   | opt -opaque-pointers=0 -S -passes=sroa -o - | FileCheck %s --check-prefix NOCHERI
target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A@PTR_AS@-P@PTR_AS@-G@PTR_AS@"
target triple = "riscv64"
; Regression test found while compiling busybox awk. This was created based on from the following reduced C code:
; void a() {
;   struct {
;     int *b;
;     char c;
;   } d = d;
; }
; The fix for this is the same as for the strict-align-offset-transfer.ll regression test, but
; it triggered a different assertion:
; Slices of alloca:   %d = alloca %struct.anon, align 16, addrspace(200)
;    [0,32) slice #0 (splittable)
;      used by:   call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* %0, i8 addrspace(200)* %1, i64 32, i1 false)
;  Pre-splitting loads and stores
;    Searching for candidate loads and stores
;  Rewriting alloca partition [0,32) to:   %d = alloca %struct.anon, align 16, addrspace(200)
;    rewriting [0,32) slice #0 (splittable)
;  Assertion failed: (isa<X>(Val) && "cast<Ty>() argument of incompatible type!"),

%struct.anon = type { i32 addrspace(@PTR_AS@)*, i8 }

define void @previously_crashing_testcase() nounwind {
; CHECK-LABEL: define {{[^@]+}}@previously_crashing_testcase
; CHECK-SAME: () addrspace(200) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret void
;
; NOCHERI-LABEL: define {{[^@]+}}@previously_crashing_testcase
; NOCHERI-SAME: () #[[ATTR0:[0-9]+]] {
; NOCHERI-NEXT:  entry:
; NOCHERI-NEXT:    ret void
;
entry:
  %d = alloca %struct.anon, align 16, addrspace(@PTR_AS@)
  %0 = bitcast %struct.anon addrspace(@PTR_AS@)* %d to i8 addrspace(@PTR_AS@)*
  %1 = bitcast %struct.anon addrspace(@PTR_AS@)* %d to i8 addrspace(@PTR_AS@)*
  call void @llvm.memcpy.p@PTR_AS@i8.p@PTR_AS@i8.i64(i8 addrspace(@PTR_AS@)* %0, i8 addrspace(@PTR_AS@)* %1, i64 @PTR_PAIR_SIZE@, i1 false)
  ret void
}

declare void @use(%struct.anon addrspace(@PTR_AS@)*)

define void @crashing_testcase_with_use() nounwind {
; CHECK-LABEL: define {{[^@]+}}@crashing_testcase_with_use
; CHECK-SAME: () addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[D:%.*]] = alloca [[STRUCT_ANON:%.*]], align 16, addrspace(200)
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_ANON]] addrspace(200)* [[D]] to i8 addrspace(200)*
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast [[STRUCT_ANON]] addrspace(200)* [[D]] to i8 addrspace(200)*
; CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[TMP1]], i64 32, i1 false)
; CHECK-NEXT:    call void @use([[STRUCT_ANON]] addrspace(200)* [[D]])
; CHECK-NEXT:    ret void
;
; NOCHERI-LABEL: define {{[^@]+}}@crashing_testcase_with_use
; NOCHERI-SAME: () #[[ATTR0]] {
; NOCHERI-NEXT:  entry:
; NOCHERI-NEXT:    [[D:%.*]] = alloca [[STRUCT_ANON:%.*]], align 16
; NOCHERI-NEXT:    [[TMP0:%.*]] = bitcast %struct.anon* [[D]] to i8*
; NOCHERI-NEXT:    [[TMP1:%.*]] = bitcast %struct.anon* [[D]] to i8*
; NOCHERI-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* [[TMP0]], i8* [[TMP1]], i64 16, i1 false)
; NOCHERI-NEXT:    call void @use(%struct.anon* [[D]])
; NOCHERI-NEXT:    ret void
;
entry:
  %d = alloca %struct.anon, align 16, addrspace(@PTR_AS@)
  %0 = bitcast %struct.anon addrspace(@PTR_AS@)* %d to i8 addrspace(@PTR_AS@)*
  %1 = bitcast %struct.anon addrspace(@PTR_AS@)* %d to i8 addrspace(@PTR_AS@)*
  call void @llvm.memcpy.p@PTR_AS@i8.p@PTR_AS@i8.i64(i8 addrspace(@PTR_AS@)* %0, i8 addrspace(@PTR_AS@)* %1, i64 @PTR_PAIR_SIZE@, i1 false)
  ; Note: memcpy() not removed if there is another use -> this did not assert
  call void @use(%struct.anon addrspace(@PTR_AS@)* %d)
  ret void
}


define void @working_testcase() nounwind {
; CHECK-LABEL: define {{[^@]+}}@working_testcase
; CHECK-SAME: () addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    ret void
;
; NOCHERI-LABEL: define {{[^@]+}}@working_testcase
; NOCHERI-SAME: () #[[ATTR0]] {
; NOCHERI-NEXT:  entry:
; NOCHERI-NEXT:    ret void
;
entry:
  %d = alloca %struct.anon, align 16, addrspace(@PTR_AS@)
  %0 = bitcast %struct.anon addrspace(@PTR_AS@)* %d to i8 addrspace(@PTR_AS@)*
  call void @llvm.memcpy.p@PTR_AS@i8.p@PTR_AS@i8.i64(i8 addrspace(@PTR_AS@)* %0, i8 addrspace(@PTR_AS@)* %0, i64 @PTR_PAIR_SIZE@, i1 false)
  ; Note: It was not asserting when both uses were the same bitcast, only when there were two different ones
  ret void
}

define void @working_testcase_with_use() nounwind {
; CHECK-LABEL: define {{[^@]+}}@working_testcase_with_use
; CHECK-SAME: () addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[D:%.*]] = alloca [[STRUCT_ANON:%.*]], align 16, addrspace(200)
; CHECK-NEXT:    [[TMP0:%.*]] = bitcast [[STRUCT_ANON]] addrspace(200)* [[D]] to i8 addrspace(200)*
; CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* [[TMP0]], i8 addrspace(200)* [[TMP0]], i64 32, i1 false)
; CHECK-NEXT:    call void @use([[STRUCT_ANON]] addrspace(200)* [[D]])
; CHECK-NEXT:    ret void
;
; NOCHERI-LABEL: define {{[^@]+}}@working_testcase_with_use
; NOCHERI-SAME: () #[[ATTR0]] {
; NOCHERI-NEXT:  entry:
; NOCHERI-NEXT:    [[D:%.*]] = alloca [[STRUCT_ANON:%.*]], align 16
; NOCHERI-NEXT:    [[TMP0:%.*]] = bitcast %struct.anon* [[D]] to i8*
; NOCHERI-NEXT:    call void @llvm.memcpy.p0i8.p0i8.i64(i8* [[TMP0]], i8* [[TMP0]], i64 16, i1 false)
; NOCHERI-NEXT:    call void @use(%struct.anon* [[D]])
; NOCHERI-NEXT:    ret void
;
entry:
  %d = alloca %struct.anon, align 16, addrspace(@PTR_AS@)
  %0 = bitcast %struct.anon addrspace(@PTR_AS@)* %d to i8 addrspace(@PTR_AS@)*
  call void @llvm.memcpy.p@PTR_AS@i8.p@PTR_AS@i8.i64(i8 addrspace(@PTR_AS@)* %0, i8 addrspace(@PTR_AS@)* %0, i64 @PTR_PAIR_SIZE@, i1 false)
  ; Note: memcpy() not removed if there is another use
  call void @use(%struct.anon addrspace(@PTR_AS@)* %d)
  ret void
}

declare void @llvm.memcpy.p@PTR_AS@i8.p@PTR_AS@i8.i64(i8 addrspace(@PTR_AS@)* noalias nocapture writeonly, i8 addrspace(@PTR_AS@)* noalias nocapture readonly, i64, i1 immarg)
