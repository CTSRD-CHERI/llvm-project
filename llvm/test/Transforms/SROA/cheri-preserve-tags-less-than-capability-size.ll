; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --force-update
;; Check that we do not be create a memcpy with the must_preserve_tags attribute
;; for less than capability-size elements.
; RUN: opt -S -passes=sroa < %s | FileCheck %s
target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200"
target triple = "riscv64-unknown-freebsd14.0"

%struct.mdoc_argv = type { i32, i32, i32, i8 addrspace(200)* }

define void @mdoc_argv(i8 addrspace(200)* %dst, i32 %arg) {
; CHECK-LABEL: @mdoc_argv(
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMPV_SROA_0:%.*]] = alloca { i32, i32 }, align 16, addrspace(200)
; CHECK-NEXT:    [[TMPV_SROA_3:%.*]] = alloca [20 x i8], align 4, addrspace(200)
; CHECK-NEXT:    [[TMPV_SROA_0_0_SRC_SROA_CAST4:%.*]] = bitcast { i32, i32 } addrspace(200)* [[TMPV_SROA_0]] to i8 addrspace(200)*
; CHECK-NEXT:    call void @llvm.memset.p200i8.i64(i8 addrspace(200)* align 16 [[TMPV_SROA_0_0_SRC_SROA_CAST4]], i8 0, i64 8, i1 false)
; CHECK-NEXT:    [[TMPV_SROA_3_0_SRC_SROA_IDX3:%.*]] = getelementptr inbounds [20 x i8], [20 x i8] addrspace(200)* [[TMPV_SROA_3]], i64 0, i64 0
; CHECK-NEXT:    call void @llvm.memset.p200i8.i64(i8 addrspace(200)* align 4 [[TMPV_SROA_3_0_SRC_SROA_IDX3]], i8 0, i64 20, i1 false)
; CHECK-NEXT:    [[TMPV_SROA_0_0_SRC_SROA_CAST:%.*]] = bitcast { i32, i32 } addrspace(200)* [[TMPV_SROA_0]] to i8 addrspace(200)*
; CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 1 [[DST:%.*]], i8 addrspace(200)* align 16 [[TMPV_SROA_0_0_SRC_SROA_CAST]], i64 8, i1 false) #[[ATTR2:[0-9]+]]
; CHECK-NEXT:    [[TMPV_SROA_2_0_DST_SROA_IDX:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DST]], i64 8
; CHECK-NEXT:    [[TMPV_SROA_2_0_DST_SROA_CAST:%.*]] = bitcast i8 addrspace(200)* [[TMPV_SROA_2_0_DST_SROA_IDX]] to i32 addrspace(200)*
; CHECK-NEXT:    store i32 [[ARG:%.*]], i32 addrspace(200)* [[TMPV_SROA_2_0_DST_SROA_CAST]], align 1
; CHECK-NEXT:    [[TMPV_SROA_3_0_DST_SROA_RAW_IDX:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[DST]], i64 12
; CHECK-NEXT:    [[TMPV_SROA_3_0_SRC_SROA_IDX:%.*]] = getelementptr inbounds [20 x i8], [20 x i8] addrspace(200)* [[TMPV_SROA_3]], i64 0, i64 0
; CHECK-NEXT:    call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* align 1 [[TMPV_SROA_3_0_DST_SROA_RAW_IDX]], i8 addrspace(200)* align 4 [[TMPV_SROA_3_0_SRC_SROA_IDX]], i64 20, i1 false) #[[ATTR3:[0-9]+]]
; CHECK-NEXT:    ret void
;
entry:
  %tmpv = alloca %struct.mdoc_argv, align 16, addrspace(200)
  %src = bitcast %struct.mdoc_argv addrspace(200)* %tmpv to i8 addrspace(200)*
  call void @llvm.memset.p200i8.i64(i8 addrspace(200)* %src, i8 0, i64 32, i1 false)
  %pos = getelementptr inbounds %struct.mdoc_argv, %struct.mdoc_argv addrspace(200)* %tmpv, i32 0, i32 2
  store i32 %arg, i32 addrspace(200)* %pos, align 8
  call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* %dst, i8 addrspace(200)* %src, i64 32, i1 false) must_preserve_cheri_tags
  ret void
}

declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noalias nocapture writeonly, i8 addrspace(200)* noalias nocapture readonly, i64, i1 immarg)
declare void @llvm.memset.p200i8.i64(i8 addrspace(200)* nocapture, i8, i64, i1)

; UTC_ARGS: --disable
; CHECK: attributes #[[ATTR2]] = { no_preserve_cheri_tags }
; CHECK: attributes #[[ATTR3]] = { must_preserve_cheri_tags }
