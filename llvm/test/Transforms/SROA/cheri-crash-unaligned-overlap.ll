; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -S -passes=sroa < %s | FileCheck %s
target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n32:64-S128-A200-P200-G200"

declare void @llvm.lifetime.start.p200(i64 immarg, ptr addrspace(200))

;; This previously crashed with:
;;
;;   Assertion `BeginOffset < EndOffset && "Partitions must span some bytes!"' failed.
;;
;; This test is ultimately derived from specific usage within Chromium of:
;;
;;   std::string("array of ") + (condition ?  "mutable " : "")
;;
;; that was optimised to IR characterised by the partition access patterns in
;; this test and crashed Morello LLVM (note for example that the original
;; reduced IR loaded rather than stored a pointer, but the latter avoids issues
;; of poison, and the overlap has been reduced to just a single i16 at the
;; boundary).
define void @head_i16() {
; CHECK-LABEL: define void @head_i16() addrspace(200) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BUF:%.*]] = alloca [32 x i8], align 16, addrspace(200)
; CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 32, ptr addrspace(200) [[BUF]])
; CHECK-NEXT:    [[BUF_16_P16_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[BUF]], i64 16
; CHECK-NEXT:    store ptr addrspace(200) null, ptr addrspace(200) [[BUF_16_P16_SROA_IDX]], align 16
; CHECK-NEXT:    [[BUF_15_P15_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[BUF]], i64 15
; CHECK-NEXT:    store i16 0, ptr addrspace(200) [[BUF_15_P15_SROA_IDX]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %buf = alloca [32 x i8], align 16, addrspace(200)
  call void @llvm.lifetime.start.p200(i64 32, ptr addrspace(200) %buf)
  %p16 = getelementptr [32 x i8], ptr addrspace(200) %buf, i64 0, i64 16
  store ptr addrspace(200) null, ptr addrspace(200) %p16, align 16
  %p15 = getelementptr [32 x i8], ptr addrspace(200) %buf, i64 0, i64 15
  store i16 0, ptr addrspace(200) %p15, align 1
  ret void
}

;; Test we don't crash even when the overlap is due to an unaligned capability
;; (even if the align 16 is UB here).
define void @head_cap_misaligned() {
; CHECK-LABEL: define void @head_cap_misaligned() addrspace(200) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BUF:%.*]] = alloca [32 x i8], align 16, addrspace(200)
; CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 32, ptr addrspace(200) [[BUF]])
; CHECK-NEXT:    [[BUF_16_P16_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[BUF]], i64 16
; CHECK-NEXT:    store ptr addrspace(200) null, ptr addrspace(200) [[BUF_16_P16_SROA_IDX]], align 16
; CHECK-NEXT:    [[BUF_15_P15_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[BUF]], i64 15
; CHECK-NEXT:    store ptr addrspace(200) null, ptr addrspace(200) [[BUF_15_P15_SROA_IDX]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %buf = alloca [32 x i8], align 16, addrspace(200)
  call void @llvm.lifetime.start.p200(i64 32, ptr addrspace(200) %buf)
  %p16 = getelementptr inbounds [32 x i8], ptr addrspace(200) %buf, i64 0, i64 16
  store ptr addrspace(200) null, ptr addrspace(200) %p16, align 16
  %p15 = getelementptr inbounds [32 x i8], ptr addrspace(200) %buf, i64 0, i64 15
  store ptr addrspace(200) null, ptr addrspace(200) %p15, align 16
  ret void
}

;; Test we don't crash even when the overlap is due to an unaligned capability
;; that's marked as unaligned.
define void @head_cap_unaligned() {
; CHECK-LABEL: define void @head_cap_unaligned() addrspace(200) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BUF:%.*]] = alloca [32 x i8], align 16, addrspace(200)
; CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 32, ptr addrspace(200) [[BUF]])
; CHECK-NEXT:    [[BUF_16_P16_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[BUF]], i64 16
; CHECK-NEXT:    store ptr addrspace(200) null, ptr addrspace(200) [[BUF_16_P16_SROA_IDX]], align 16
; CHECK-NEXT:    [[BUF_15_P15_SROA_IDX:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[BUF]], i64 15
; CHECK-NEXT:    store ptr addrspace(200) null, ptr addrspace(200) [[BUF_15_P15_SROA_IDX]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %buf = alloca [32 x i8], align 16, addrspace(200)
  call void @llvm.lifetime.start.p200(i64 32, ptr addrspace(200) %buf)
  %p16 = getelementptr inbounds [32 x i8], ptr addrspace(200) %buf, i64 0, i64 16
  store ptr addrspace(200) null, ptr addrspace(200) %p16, align 16
  %p15 = getelementptr inbounds [32 x i8], ptr addrspace(200) %buf, i64 0, i64 15
  store ptr addrspace(200) null, ptr addrspace(200) %p15, align 1
  ret void
}

;; Test we don't crash when the overlap is past the end (and in fact omit the
;; tail padding as implicit).
define void @tail_i16() {
; CHECK-LABEL: define void @tail_i16() addrspace(200) {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[BUF_SROA_0:%.*]] = alloca [17 x i8], align 16, addrspace(200)
; CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 17, ptr addrspace(200) [[BUF_SROA_0]])
; CHECK-NEXT:    store ptr addrspace(200) null, ptr addrspace(200) [[BUF_SROA_0]], align 16
; CHECK-NEXT:    [[BUF_SROA_0_15_P15_SROA_IDX1:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[BUF_SROA_0]], i64 15
; CHECK-NEXT:    store i16 0, ptr addrspace(200) [[BUF_SROA_0_15_P15_SROA_IDX1]], align 1
; CHECK-NEXT:    ret void
;
entry:
  %buf = alloca [32 x i8], align 16, addrspace(200)
  call void @llvm.lifetime.start.p200(i64 32, ptr addrspace(200) %buf)
  store ptr addrspace(200) null, ptr addrspace(200) %buf, align 16
  %p15 = getelementptr inbounds [32 x i8], ptr addrspace(200) %buf, i64 0, i64 15
  store i16 0, ptr addrspace(200) %p15, align 1
  ret void
}
