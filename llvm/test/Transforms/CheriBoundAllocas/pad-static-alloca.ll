; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --force-update
; RUN: %riscv64_cheri_purecap_opt -opaque-pointers=0 -cheri-bound-allocas -S < %s | FileCheck %s --check-prefixes=TYPED
; RUN: %riscv64_cheri_purecap_opt -opaque-pointers=1 -instsimplify -cheri-bound-allocas -S < %s | FileCheck %s --check-prefix OPAQUE
target datalayout = "E-m:m-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"

declare void @keep_live(i8 addrspace(200)*) local_unnamed_addr addrspace(200)

define void @small() local_unnamed_addr addrspace(200) {
; TYPED-LABEL: @small(
; TYPED-NEXT:  entry:
; TYPED-NEXT:    [[TMP0:%.*]] = alloca [10 x i8], align 1, addrspace(200)
; TYPED-NEXT:    [[TMP1:%.*]] = bitcast [10 x i8] addrspace(200)* [[TMP0]] to i8 addrspace(200)*
; TYPED-NEXT:    [[TMP2:%.*]] = call i8 addrspace(200)* @llvm.cheri.bounded.stack.cap.i64(i8 addrspace(200)* [[TMP1]], i64 10)
; TYPED-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[TMP2]] to [10 x i8] addrspace(200)*
; TYPED-NEXT:    [[PTR:%.*]] = getelementptr inbounds [10 x i8], [10 x i8] addrspace(200)* [[TMP3]], i64 0, i64 0
; TYPED-NEXT:    call void @keep_live(i8 addrspace(200)* nonnull [[PTR]])
; TYPED-NEXT:    ret void
;
; OPAQUE-LABEL: @small(
; OPAQUE-NEXT:  entry:
; OPAQUE-NEXT:    [[TMP0:%.*]] = alloca [10 x i8], align 1, addrspace(200)
; OPAQUE-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[TMP0]], i64 10)
; OPAQUE-NEXT:    call void @keep_live(ptr addrspace(200) nonnull [[TMP1]])
; OPAQUE-NEXT:    ret void
;
entry:
  %0 = alloca [10 x i8], align 1, addrspace(200)
  %ptr = getelementptr inbounds [10 x i8], [10 x i8] addrspace(200)* %0, i64 0, i64 0
  call void @keep_live(i8 addrspace(200)* nonnull %ptr)
  ret void
}

define void @pad_large() local_unnamed_addr addrspace(200) {
; TYPED-LABEL: @pad_large(
; TYPED-NEXT:  entry:
; TYPED-NEXT:    [[TMP0:%.*]] = alloca { [16388 x i8], [28 x i8] }, align 32, addrspace(200)
; TYPED-NEXT:    [[WITHOUT_TAIL_PADDING:%.*]] = bitcast { [16388 x i8], [28 x i8] } addrspace(200)* [[TMP0]] to [16388 x i8] addrspace(200)*
; TYPED-NEXT:    [[TMP1:%.*]] = bitcast { [16388 x i8], [28 x i8] } addrspace(200)* [[TMP0]] to i8 addrspace(200)*
; TYPED-NEXT:    [[TMP2:%.*]] = call i8 addrspace(200)* @llvm.cheri.bounded.stack.cap.i64(i8 addrspace(200)* [[TMP1]], i64 16416)
; TYPED-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[TMP2]] to [16388 x i8] addrspace(200)*
; TYPED-NEXT:    [[PTR:%.*]] = getelementptr inbounds [16388 x i8], [16388 x i8] addrspace(200)* [[TMP3]], i64 0, i64 0
; TYPED-NEXT:    call void @keep_live(i8 addrspace(200)* nonnull [[PTR]])
; TYPED-NEXT:    ret void
;
; OPAQUE-LABEL: @pad_large(
; OPAQUE-NEXT:  entry:
; OPAQUE-NEXT:    [[TMP0:%.*]] = alloca { [16388 x i8], [28 x i8] }, align 32, addrspace(200)
; OPAQUE-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[TMP0]], i64 16416)
; OPAQUE-NEXT:    call void @keep_live(ptr addrspace(200) nonnull [[TMP1]])
; OPAQUE-NEXT:    ret void
;
entry:
  %0 = alloca [16388 x i8], align 1, addrspace(200)
  %ptr = getelementptr inbounds [16388 x i8], [16388 x i8] addrspace(200)* %0, i64 0, i64 0
  call void @keep_live(i8 addrspace(200)* nonnull %ptr)
  ret void
}

define void @nopad_large() local_unnamed_addr addrspace(200) {
; TYPED-LABEL: @nopad_large(
; TYPED-NEXT:  entry:
; TYPED-NEXT:    [[TMP0:%.*]] = alloca [16388 x i8], align 32, addrspace(200)
; TYPED-NEXT:    [[PTR:%.*]] = getelementptr inbounds [16388 x i8], [16388 x i8] addrspace(200)* [[TMP0]], i64 0, i64 0
; TYPED-NEXT:    store volatile i8 0, i8 addrspace(200)* [[PTR]], align 1
; TYPED-NEXT:    ret void
;
; OPAQUE-LABEL: @nopad_large(
; OPAQUE-NEXT:  entry:
; OPAQUE-NEXT:    [[TMP0:%.*]] = alloca [16388 x i8], align 32, addrspace(200)
; OPAQUE-NEXT:    store volatile i8 0, ptr addrspace(200) [[TMP0]], align 1
; OPAQUE-NEXT:    ret void
;
entry:
  %0 = alloca [16388 x i8], align 1, addrspace(200)
  %ptr = getelementptr inbounds [16388 x i8], [16388 x i8] addrspace(200)* %0, i64 0, i64 0
  store volatile i8 0, i8 addrspace(200)* %ptr
  ret void
}

;; A large alloca with a struct type - incorrect handling of the new alloca type
;; resulted in invalid IR after catching up with API changes when merging to LLVM 14.

%struct.snmp_pdu = type { [100 x %struct.asn_oid], i32 }
%struct.asn_oid = type { [28 x i32] }

@snmp_discover_engine_resp = addrspace(200) global %struct.snmp_pdu zeroinitializer, align 4
declare void @snmp_pdu_free(%struct.snmp_pdu addrspace(200)* noundef) addrspace(200)

define dso_local void @snmp_discover_engine(%struct.snmp_pdu addrspace(200)* noalias sret(%struct.snmp_pdu) align 4 %agg.result) addrspace(200) nounwind {
; TYPED-LABEL: @snmp_discover_engine(
; TYPED-NEXT:  entry:
; TYPED-NEXT:    [[BYVAL_TEMP:%.*]] = alloca { [[STRUCT_SNMP_PDU:%.*]], [12 x i8] }, align 16, addrspace(200)
; TYPED-NEXT:    [[WITHOUT_TAIL_PADDING:%.*]] = bitcast { [[STRUCT_SNMP_PDU]], [12 x i8] } addrspace(200)* [[BYVAL_TEMP]] to [[STRUCT_SNMP_PDU]] addrspace(200)*
; TYPED-NEXT:    [[TMP0:%.*]] = bitcast { [[STRUCT_SNMP_PDU]], [12 x i8] } addrspace(200)* [[BYVAL_TEMP]] to i8 addrspace(200)*
; TYPED-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.bounded.stack.cap.i64(i8 addrspace(200)* [[TMP0]], i64 11216)
; TYPED-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[TMP1]] to [[STRUCT_SNMP_PDU]] addrspace(200)*
; TYPED-NEXT:    call void @snmp_pdu_free([[STRUCT_SNMP_PDU]] addrspace(200)* [[TMP2]])
; TYPED-NEXT:    ret void
;
; OPAQUE-LABEL: @snmp_discover_engine(
; OPAQUE-NEXT:  entry:
; OPAQUE-NEXT:    [[BYVAL_TEMP:%.*]] = alloca { [[STRUCT_SNMP_PDU:%.*]], [12 x i8] }, align 16, addrspace(200)
; OPAQUE-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.bounded.stack.cap.i64(ptr addrspace(200) [[BYVAL_TEMP]], i64 11216)
; OPAQUE-NEXT:    call void @snmp_pdu_free(ptr addrspace(200) [[TMP0]])
; OPAQUE-NEXT:    ret void
;
entry:
  %byval-temp = alloca %struct.snmp_pdu, align 4, addrspace(200)
  call void @snmp_pdu_free(%struct.snmp_pdu addrspace(200)* %byval-temp)
  ret void
}

declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noalias nocapture writeonly, i8 addrspace(200)* noalias nocapture readonly, i64, i1 immarg) addrspace(200)
