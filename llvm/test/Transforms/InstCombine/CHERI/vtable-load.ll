; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes
; RUN: sed -e 's/addrspace(200)/addrspace(0)/g' -e 's/-A200-P200-G200//g' %s | opt -enable-new-pm=1 -S "-passes=instcombine" | FileCheck %s --check-prefix=HYBRID
; RUN: opt -enable-new-pm=1 -S "-passes=instcombine" < %s | FileCheck %s --check-prefix=PURECAP
; Check that instcombine can resolve the vtable load.
; FIXME: This does not work for pure-capability code because ptrtoint(gep(null, x)) is not folded to x
; Test case is based partially optimized output of clang/test/CodeGenCXX/member-function-pointer-calls.cpp.
target datalayout = "e-m:e-pf200:128:128:128:64-p:64:64-i64:64-i128:128-n64-S128-A200-P200-G200"
target triple = "riscv64-unknown-freebsd"

%struct.A = type { i64 (...) addrspace(200)* addrspace(200)* }
@_ZTV1A = internal unnamed_addr addrspace(200) constant { [4 x i8 addrspace(200)*] } { [4 x i8 addrspace(200)*]
  [ i8 addrspace(200)* null,
  i8 addrspace(200)* bitcast ({ i8 addrspace(200)*, i8 addrspace(200)* } addrspace(200)* @_ZTI1A to i8 addrspace(200)*),
  i8 addrspace(200)* bitcast (i64 (%struct.A addrspace(200)*) addrspace(200)* @member_function_1 to i8 addrspace(200)*),
  i8 addrspace(200)* bitcast (i64 (%struct.A addrspace(200)*) addrspace(200)* @member_function_2 to i8 addrspace(200)*)
  ] }, align 16
@_ZTI1A = external addrspace(200) constant { i8 addrspace(200)*, i8 addrspace(200)* }, align 16

define i64 (%struct.A addrspace(200)*) addrspace(200)* @return_member_function_1() {
; HYBRID-LABEL: define {{[^@]+}}@return_member_function_1() {
; HYBRID-NEXT:  call_member_fn_ptr.exit:
; HYBRID-NEXT:    ret i64 (%struct.A*)* @member_function_1
;
; PURECAP-LABEL: define {{[^@]+}}@return_member_function_1() addrspace(200) {
; PURECAP-NEXT:  call_member_fn_ptr.exit:
; PURECAP-NEXT:    ret i64 ([[STRUCT_A:%.*]] addrspace(200)*) addrspace(200)* @member_function_1
;
call_member_fn_ptr.exit:
  %memptr.virtualfn.i = load i64 (%struct.A addrspace(200)*) addrspace(200)*, i64 (%struct.A addrspace(200)*) addrspace(200)* addrspace(200)* bitcast (i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* bitcast (i8 addrspace(200)* addrspace(200)* getelementptr inbounds ({ [4 x i8 addrspace(200)*] }, { [4 x i8 addrspace(200)*] } addrspace(200)* @_ZTV1A, i64 0, inrange i32 0, i64 2) to i8 addrspace(200)*), i64 add (i64 ptrtoint (i8 addrspace(200)* getelementptr (i8, i8 addrspace(200)* null, i64 1) to i64), i64 -1)) to i64 (%struct.A addrspace(200)*) addrspace(200)* addrspace(200)*), align 16
  ret i64 (%struct.A addrspace(200)*) addrspace(200)* %memptr.virtualfn.i
}

declare i64 @member_function_1(%struct.A addrspace(200)* nocapture nonnull readnone align 16 dereferenceable(16) %this)
declare i64 @member_function_2(%struct.A addrspace(200)* nocapture nonnull readnone align 16 dereferenceable(16) %this)
