; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes
; RUN: %cheri_opt -S -passes=instcombine %s -o - | FileCheck %s
target datalayout = "pf200:128:128:128:64-A200-P200-G200"

declare i64 @check_fold(i64) addrspace(200)
declare i64 @llvm.cheri.cap.base.get.i64(ptr addrspace(200)) addrspace(200)
declare ptr addrspace(200) @llvm.cheri.cap.base.set(ptr addrspace(200), i64) addrspace(200)
declare i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200)) addrspace(200)
declare i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200)) addrspace(200)
declare ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200), i64) addrspace(200)
declare ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200), i64) addrspace(200)
declare i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200)) addrspace(200)
declare ptr addrspace(200) @llvm.cheri.cap.length.set(ptr addrspace(200), i64) addrspace(200)
declare i64 @llvm.cheri.cap.perms.get.i64(ptr addrspace(200)) addrspace(200)
declare ptr addrspace(200) @llvm.cheri.cap.perms.and.i64(ptr addrspace(200), i64) addrspace(200)


define ptr addrspace(200) @fold_offset_get_set(ptr addrspace(200) %arg) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_offset_get_set
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    ret ptr addrspace(200) [[ARG]]
;
  %offset = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) %arg)
  %ret = tail call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) %arg, i64 %offset)
  ret ptr addrspace(200) %ret
  ; This is a no-op and should be folded to ret %arg
}

; But check that we don't do the same folding when using different base caps for get/set
define ptr addrspace(200) @fold_offset_get_set_different_cap(ptr addrspace(200) %arg, ptr addrspace(200) %arg2) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_offset_get_set_different_cap
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]], ptr addrspace(200) [[ARG2:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) [[ARG]])
; CHECK-NEXT:    [[RET:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) [[ARG2]], i64 [[OFFSET]])
; CHECK-NEXT:    ret ptr addrspace(200) [[RET]]
;
  %offset = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) %arg)
  %ret = tail call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) %arg2, i64 %offset)
  ret ptr addrspace(200) %ret
}

define ptr addrspace(200) @fold_offset_get_add_set(ptr addrspace(200) %arg) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_offset_get_add_set
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[RET:%.*]] = getelementptr i8, ptr addrspace(200) [[ARG]], i64 22
; CHECK-NEXT:    ret ptr addrspace(200) [[RET]]
;
  %offset = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) %arg)
  %new_offset = add i64 %offset, 22
  %ret = tail call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) %arg, i64 %new_offset)
  ret ptr addrspace(200) %ret
}

define ptr addrspace(200) @fold_addr_get_set(ptr addrspace(200) %arg) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_addr_get_set
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    ret ptr addrspace(200) [[ARG]]
;
  %addr = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) %arg)
  %ret = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) %arg, i64 %addr)
  ret ptr addrspace(200) %ret
}

; But check that we don't do the same folding when using different base caps for get/set
define ptr addrspace(200) @fold_addr_get_set_different_cap(ptr addrspace(200) %arg, ptr addrspace(200) %arg2) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_addr_get_set_different_cap
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]], ptr addrspace(200) [[ARG2:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[ADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[ARG]])
; CHECK-NEXT:    [[RET:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[ARG2]], i64 [[ADDR]])
; CHECK-NEXT:    ret ptr addrspace(200) [[RET]]
;
  %addr = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) %arg)
  %ret = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) %arg2, i64 %addr)
  ret ptr addrspace(200) %ret
}

define ptr addrspace(200) @fold_addr_get_add_set(ptr addrspace(200) %arg) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_addr_get_add_set
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[RET:%.*]] = getelementptr i8, ptr addrspace(200) [[ARG]], i64 25
; CHECK-NEXT:    ret ptr addrspace(200) [[RET]]
;
  %offset = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) %arg)
  %new_offset = add i64 %offset, 25
  %ret = tail call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) %arg, i64 %new_offset)
  ret ptr addrspace(200) %ret
}

define ptr addrspace(200) @offset_get_set_sequence(i64 %x, i64 %y, ptr addrspace(200) %cap) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@offset_get_set_sequence
; CHECK-SAME: (i64 [[X:%.*]], i64 [[Y:%.*]], ptr addrspace(200) [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr addrspace(200) [[CAP]], i64 [[X]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr addrspace(200) [[TMP5]], i64 [[Y]]
; CHECK-NEXT:    ret ptr addrspace(200) [[TMP11]]
;
entry:
  %tmp2 = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) null, i64 %x)
  %tmp3 = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) %cap)
  %tmp4 = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) %tmp2)
  %add = add i64 %tmp3, %tmp4
  %tmp5 = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) %cap, i64 %add)
  %tmp8 = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) null, i64 %y)
  %tmp9 = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) %tmp5)
  %tmp10 = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) %tmp8)
  %add1 = add i64 %tmp9, %tmp10
  %tmp11 = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) %tmp5, i64 %add1)
  ret ptr addrspace(200) %tmp11
}

define ptr addrspace(200) @offset_get_set_sequence_gep_null(i64 %x, i64 %y, ptr addrspace(200) %cap) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@offset_get_set_sequence_gep_null
; CHECK-SAME: (i64 [[X:%.*]], i64 [[Y:%.*]], ptr addrspace(200) [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr addrspace(200) [[CAP]], i64 [[X]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr addrspace(200) [[TMP5]], i64 [[Y]]
; CHECK-NEXT:    ret ptr addrspace(200) [[TMP11]]
;
entry:
  %tmp2 = getelementptr i8, ptr addrspace(200) null, i64 %x
  %tmp4 = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) %tmp2)
  %tmp5 = getelementptr i8, ptr addrspace(200) %cap, i64 %tmp4
  %tmp8 = getelementptr i8, ptr addrspace(200) null, i64 %y
  %tmp10 = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) %tmp8)
  %tmp11 = getelementptr i8, ptr addrspace(200) %tmp5, i64 %tmp10
  ret ptr addrspace(200) %tmp11
}

define ptr addrspace(200) @addr_get_set_sequence(i64 %x, i64 %y, ptr addrspace(200) %cap) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@addr_get_set_sequence
; CHECK-SAME: (i64 [[X:%.*]], i64 [[Y:%.*]], ptr addrspace(200) [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr addrspace(200) [[CAP]], i64 [[X]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr addrspace(200) [[TMP5]], i64 [[Y]]
; CHECK-NEXT:    ret ptr addrspace(200) [[TMP11]]
;
entry:
  %tmp2 = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) null, i64 %x)
  %tmp3 = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) %cap)
  %tmp4 = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) %tmp2)
  %add = add i64 %tmp3, %tmp4
  %tmp5 = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) %cap, i64 %add)
  %tmp8 = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) null, i64 %y)
  %tmp9 = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) %tmp5)
  %tmp10 = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) %tmp8)
  %add1 = add i64 %tmp9, %tmp10
  %tmp11 = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) %tmp5, i64 %add1)
  ret ptr addrspace(200) %tmp11
}

define ptr addrspace(200) @addr_get_set_sequence_gep_null(i64 %x, i64 %y, ptr addrspace(200) %cap) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@addr_get_set_sequence_gep_null
; CHECK-SAME: (i64 [[X:%.*]], i64 [[Y:%.*]], ptr addrspace(200) [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, ptr addrspace(200) [[CAP]], i64 [[X]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, ptr addrspace(200) [[TMP5]], i64 [[Y]]
; CHECK-NEXT:    ret ptr addrspace(200) [[TMP11]]
;
entry:
  %tmp2 = getelementptr i8, ptr addrspace(200) null, i64 %x
  %tmp4 = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) %tmp2)
  %tmp5 = getelementptr i8, ptr addrspace(200) %cap, i64 %tmp4
  %tmp8 = getelementptr i8, ptr addrspace(200) null, i64 %y
  %tmp10 = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) %tmp8)
  %tmp11 = getelementptr i8, ptr addrspace(200) %tmp5, i64 %tmp10
  ret ptr addrspace(200) %tmp11
}
