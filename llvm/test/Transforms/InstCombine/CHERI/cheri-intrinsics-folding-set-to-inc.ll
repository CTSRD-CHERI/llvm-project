; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
; RUN: %cheri_opt -S -instcombine %s -o - | FileCheck %s
target datalayout = "pf200:128:128:128:64-A200-P200-G200"

declare i64 @check_fold(i64) nounwind
declare i64 @llvm.cheri.cap.base.get.i64(i8 addrspace(200)*) nounwind
declare i8 addrspace(200)* @llvm.cheri.cap.base.set(i8 addrspace(200)*, i64) nounwind
declare i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)*) nounwind
declare i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)*) nounwind
declare i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)*, i64) nounwind
declare i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)*, i64) nounwind
declare i8 addrspace(200)* @llvm.cheri.cap.offset.increment.i64(i8 addrspace(200)*, i64) nounwind
declare i64 @llvm.cheri.cap.length.get.i64(i8 addrspace(200)*) nounwind
declare i8 addrspace(200)* @llvm.cheri.cap.length.set(i8 addrspace(200)*, i64) nounwind
declare i64 @llvm.cheri.cap.perms.get.i64(i8 addrspace(200)*) nounwind
declare i8 addrspace(200)* @llvm.cheri.cap.perms.and.i64(i8 addrspace(200)*, i64) nounwind
declare i64 @llvm.cheri.cap.type.get.i64(i8 addrspace(200)*) nounwind


define i8 addrspace(200)* @fold_offset_get_set(i8 addrspace(200)* %arg) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_offset_get_set
; CHECK-SAME: (i8 addrspace(200)* [[ARG:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    ret i8 addrspace(200)* [[ARG]]
;
  %offset = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* %arg)
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* %arg, i64 %offset)
  ret i8 addrspace(200)* %ret
  ; This is a no-op and should be folded to ret %arg
}

; But check that we don't do the same folding when using different base caps for get/set
define i8 addrspace(200)* @fold_offset_get_set_different_cap(i8 addrspace(200)* %arg, i8 addrspace(200)* %arg2) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_offset_get_set_different_cap
; CHECK-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[ARG2:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[ARG]])
; CHECK-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* [[ARG2]], i64 [[OFFSET]])
; CHECK-NEXT:    ret i8 addrspace(200)* [[RET]]
;
  %offset = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* %arg)
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* %arg2, i64 %offset)
  ret i8 addrspace(200)* %ret
}

define i8 addrspace(200)* @fold_offset_get_add_set(i8 addrspace(200)* %arg) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_offset_get_add_set
; CHECK-SAME: (i8 addrspace(200)* [[ARG:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[RET:%.*]] = getelementptr i8, i8 addrspace(200)* [[ARG]], i64 22
; CHECK-NEXT:    ret i8 addrspace(200)* [[RET]]
;
  %offset = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* %arg)
  %new_offset = add i64 %offset, 22
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* %arg, i64 %new_offset)
  ret i8 addrspace(200)* %ret
}

define i8 addrspace(200)* @fold_addr_get_set(i8 addrspace(200)* %arg) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_addr_get_set
; CHECK-SAME: (i8 addrspace(200)* [[ARG:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    ret i8 addrspace(200)* [[ARG]]
;
  %addr = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %arg)
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* %arg, i64 %addr)
  ret i8 addrspace(200)* %ret
}

; But check that we don't do the same folding when using different base caps for get/set
define i8 addrspace(200)* @fold_addr_get_set_different_cap(i8 addrspace(200)* %arg, i8 addrspace(200)* %arg2) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_addr_get_set_different_cap
; CHECK-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[ARG2:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[ADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[ARG]])
; CHECK-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[ARG2]], i64 [[ADDR]])
; CHECK-NEXT:    ret i8 addrspace(200)* [[RET]]
;
  %addr = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %arg)
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* %arg2, i64 %addr)
  ret i8 addrspace(200)* %ret
}

define i8 addrspace(200)* @fold_addr_get_add_set(i8 addrspace(200)* %arg) nounwind {
; CHECK-LABEL: define {{[^@]+}}@fold_addr_get_add_set
; CHECK-SAME: (i8 addrspace(200)* [[ARG:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:    [[RET:%.*]] = getelementptr i8, i8 addrspace(200)* [[ARG]], i64 25
; CHECK-NEXT:    ret i8 addrspace(200)* [[RET]]
;
  %offset = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %arg)
  %new_offset = add i64 %offset, 25
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* %arg, i64 %new_offset)
  ret i8 addrspace(200)* %ret
}

define i8 addrspace(200)* @offset_get_set_sequence(i64 %x, i64 %y, i8 addrspace(200)* %cap) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@offset_get_set_sequence
; CHECK-SAME: (i64 [[X:%.*]], i64 [[Y:%.*]], i8 addrspace(200)* [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, i8 addrspace(200)* [[CAP]], i64 [[X]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[TMP5]], i64 [[Y]]
; CHECK-NEXT:    ret i8 addrspace(200)* [[TMP11]]
;
entry:
  %tmp2 = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* null, i64 %x)
  %tmp3 = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* %cap)
  %tmp4 = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* %tmp2)
  %add = add i64 %tmp3, %tmp4
  %tmp5 = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* %cap, i64 %add)
  %tmp8 = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* null, i64 %y)
  %tmp9 = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* %tmp5)
  %tmp10 = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* %tmp8)
  %add1 = add i64 %tmp9, %tmp10
  %tmp11 = call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* %tmp5, i64 %add1)
  ret i8 addrspace(200)* %tmp11
}

define i8 addrspace(200)* @offset_get_set_sequence_gep_null(i64 %x, i64 %y, i8 addrspace(200)* %cap) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@offset_get_set_sequence_gep_null
; CHECK-SAME: (i64 [[X:%.*]], i64 [[Y:%.*]], i8 addrspace(200)* [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, i8 addrspace(200)* [[CAP]], i64 [[X]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[TMP5]], i64 [[Y]]
; CHECK-NEXT:    ret i8 addrspace(200)* [[TMP11]]
;
entry:
  %tmp2 = getelementptr i8, i8 addrspace(200)* null, i64 %x
  %tmp4 = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* %tmp2)
  %tmp5 = getelementptr i8, i8 addrspace(200)* %cap, i64 %tmp4
  %tmp8 = getelementptr i8, i8 addrspace(200)* null, i64 %y
  %tmp10 = call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* %tmp8)
  %tmp11 = getelementptr i8, i8 addrspace(200)* %tmp5, i64 %tmp10
  ret i8 addrspace(200)* %tmp11
}

define i8 addrspace(200)* @addr_get_set_sequence(i64 %x, i64 %y, i8 addrspace(200)* %cap) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@addr_get_set_sequence
; CHECK-SAME: (i64 [[X:%.*]], i64 [[Y:%.*]], i8 addrspace(200)* [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, i8 addrspace(200)* [[CAP]], i64 [[X]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[TMP5]], i64 [[Y]]
; CHECK-NEXT:    ret i8 addrspace(200)* [[TMP11]]
;
entry:
  %tmp2 = call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* null, i64 %x)
  %tmp3 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %cap)
  %tmp4 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %tmp2)
  %add = add i64 %tmp3, %tmp4
  %tmp5 = call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* %cap, i64 %add)
  %tmp8 = call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* null, i64 %y)
  %tmp9 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %tmp5)
  %tmp10 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %tmp8)
  %add1 = add i64 %tmp9, %tmp10
  %tmp11 = call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* %tmp5, i64 %add1)
  ret i8 addrspace(200)* %tmp11
}

define i8 addrspace(200)* @addr_get_set_sequence_gep_null(i64 %x, i64 %y, i8 addrspace(200)* %cap) addrspace(200) nounwind {
; CHECK-LABEL: define {{[^@]+}}@addr_get_set_sequence_gep_null
; CHECK-SAME: (i64 [[X:%.*]], i64 [[Y:%.*]], i8 addrspace(200)* [[CAP:%.*]]) addrspace(200) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr i8, i8 addrspace(200)* [[CAP]], i64 [[X]]
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[TMP5]], i64 [[Y]]
; CHECK-NEXT:    ret i8 addrspace(200)* [[TMP11]]
;
entry:
  %tmp2 = getelementptr i8, i8 addrspace(200)* null, i64 %x
  %tmp4 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %tmp2)
  %tmp5 = getelementptr i8, i8 addrspace(200)* %cap, i64 %tmp4
  %tmp8 = getelementptr i8, i8 addrspace(200)* null, i64 %y
  %tmp10 = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* %tmp8)
  %tmp11 = getelementptr i8, i8 addrspace(200)* %tmp5, i64 %tmp10
  ret i8 addrspace(200)* %tmp11
}
