; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --force-update
; We should be setting no_preserve_cheri_tags for loops that copy integers, and must_preserve_cheri_tags for capability copies.
; FIXME: this does not work with addrspace(200) pointers yet since we need SCEV.
; RUN: sed -e 's/-A200-P200-G200//g' %s | opt --passes='require<aa>,loop(loop-idiom,loop-deletion),simplifycfg' -aa-pipeline=basic-aa -S | \
; RUN:   FileCheck %s --check-prefixes=HYBRID
; RUN: opt --passes='require<aa>,loop(loop-idiom,loop-deletion),simplifycfg' -aa-pipeline=basic-aa -S < %s | \
; RUN:   FileCheck %s --check-prefixes=PURECAP
target datalayout = "e-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-A200-P200-G200"

%struct.state = type { [25 x i32], i32 }
%struct.capstate = type { [25 x ptr addrspace(200)], i32 }

@nocap = unnamed_addr addrspace("G") global [25 x i32] zeroinitializer, align 4
@cap = unnamed_addr addrspace("G") global [25 x ptr addrspace(200)] zeroinitializer, align 4
@k = unnamed_addr addrspace("G") global i32 0, align 4

define void @get_state(ptr addrspace("A") nocapture noalias %state) addrspace("P") {
; HYBRID-LABEL: define {{[^@]+}}@get_state
; HYBRID-SAME: (ptr noalias nocapture [[STATE:%.*]]) {
; HYBRID-NEXT:  entry:
; HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 4 [[STATE]], ptr align 4 @nocap, i64 100, i1 false)
; HYBRID-NEXT:    ret void
;
; PURECAP-LABEL: define {{[^@]+}}@get_state
; PURECAP-SAME: (ptr addrspace(200) noalias nocapture [[STATE:%.*]]) addrspace(200) {
; PURECAP-NEXT:  entry:
; PURECAP-NEXT:    br label [[FOR_BODY:%.*]]
; PURECAP:       for.body:
; PURECAP-NEXT:    [[I_08:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; PURECAP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [25 x i32], ptr addrspace(200) @nocap, i64 0, i64 [[I_08]]
; PURECAP-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[ARRAYIDX]], align 4
; PURECAP-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [[STRUCT_STATE:%.*]], ptr addrspace(200) [[STATE]], i64 0, i32 0, i64 [[I_08]]
; PURECAP-NEXT:    store i32 [[TMP0]], ptr addrspace(200) [[ARRAYIDX2]], align 4
; PURECAP-NEXT:    [[INC]] = add nuw nsw i64 [[I_08]], 1
; PURECAP-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INC]], 25
; PURECAP-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; PURECAP:       for.end:
; PURECAP-NEXT:    ret void
;
entry:
  br label %for.body.preheader

for.body.preheader:
  br label %for.body

for.body:
  %i.08 = phi i64 [ 0, %for.body.preheader ], [ %inc, %for.body ]
  %arrayidx = getelementptr inbounds [25 x i32], ptr addrspace("G") @nocap, i64 0, i64 %i.08
  %0 = load i32, ptr addrspace("A") %arrayidx, align 4
  %arrayidx2 = getelementptr inbounds %struct.state, ptr addrspace("A") %state, i64 0, i32 0, i64 %i.08
  store i32 %0, ptr addrspace("A") %arrayidx2, align 4
  %inc = add nuw nsw i64 %i.08, 1
  %exitcond = icmp ne i64 %inc, 25
  br i1 %exitcond, label %for.body, label %for.end

for.end:
  ret void
}

define void @get_cap_state(ptr addrspace("A") nocapture noalias %state) addrspace("P") {
; HYBRID-LABEL: define {{[^@]+}}@get_cap_state
; HYBRID-SAME: (ptr noalias nocapture [[STATE:%.*]]) {
; HYBRID-NEXT:  entry:
; HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[STATE]], ptr align 16 @cap, i64 400, i1 false)
; HYBRID-NEXT:    ret void
;
; PURECAP-LABEL: define {{[^@]+}}@get_cap_state
; PURECAP-SAME: (ptr addrspace(200) noalias nocapture [[STATE:%.*]]) addrspace(200) {
; PURECAP-NEXT:  entry:
; PURECAP-NEXT:    br label [[FOR_BODY:%.*]]
; PURECAP:       for.body:
; PURECAP-NEXT:    [[I_08:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INC:%.*]], [[FOR_BODY]] ]
; PURECAP-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds [25 x ptr addrspace(200)], ptr addrspace(200) @cap, i64 0, i64 [[I_08]]
; PURECAP-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARRAYIDX]], align 16
; PURECAP-NEXT:    [[ARRAYIDX2:%.*]] = getelementptr inbounds [[STRUCT_CAPSTATE:%.*]], ptr addrspace(200) [[STATE]], i64 0, i32 0, i64 [[I_08]]
; PURECAP-NEXT:    store ptr addrspace(200) [[TMP0]], ptr addrspace(200) [[ARRAYIDX2]], align 16
; PURECAP-NEXT:    [[INC]] = add nuw nsw i64 [[I_08]], 1
; PURECAP-NEXT:    [[EXITCOND:%.*]] = icmp ne i64 [[INC]], 25
; PURECAP-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[FOR_END:%.*]]
; PURECAP:       for.end:
; PURECAP-NEXT:    ret void
;
entry:
  br label %for.body

for.body:
  %i.08 = phi i64 [ 0, %entry ], [ %inc, %for.body ]
  %arrayidx = getelementptr inbounds [25 x ptr addrspace(200)], ptr addrspace("G") @cap, i64 0, i64 %i.08
  %0 = load ptr addrspace(200), ptr addrspace("G") %arrayidx, align 16
  %arrayidx2 = getelementptr inbounds %struct.capstate, ptr addrspace("A") %state, i64 0, i32 0, i64 %i.08
  store ptr addrspace(200) %0, ptr addrspace("A") %arrayidx2, align 16
  %inc = add nuw nsw i64 %i.08, 1
  %exitcond = icmp ne i64 %inc, 25
  br i1 %exitcond, label %for.body, label %for.end

for.end:
  ret void
}

; UTC_ARGS: --disable
; HYBRID-TODO: attributes #[[ATTR1]] = { no_preserve_cheri_tags }
; HYBRID-TODO: attributes #[[ATTR2]] = { must_preserve_cheri_tags }
