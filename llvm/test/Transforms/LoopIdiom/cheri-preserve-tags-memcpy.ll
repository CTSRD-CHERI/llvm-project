; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --force-update
; Check that we retain the {must,no}_preserve_cheri_tags attribute when merging memcpy loops.
; FIXME: this does not work as expected with addrspace(200) pointers yet since we need SCEV.
; RUN: sed -e 's/-A200-P200-G200//g' -e 's/.p200/.p0/g' %s | \
; RUN:    opt -passes='require<aa>,loop(loop-idiom,loop-deletion),simplifycfg' -aa-pipeline=basic-aa -S | \
; RUN:    FileCheck %s --check-prefixes=HYBRID,CHECK
; RUN: opt -passes='require<aa>,loop(loop-idiom,loop-deletion),simplifycfg' -aa-pipeline=basic-aa -S < %s | \
; RUN:    FileCheck %s --check-prefixes=PURECAP,CHECK
target datalayout = "e-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-A200-P200-G200"

; Created from the following reduced C testcase:
; struct sockaddr_in {
;   short sin_portsin_zero[8]
; };
; struct {
;   int nscount;
;   struct sockaddr_in nsaddr_list[]
; } __res_nsend_statp;
; int __res_nsend_ns;
; void __res_nsend() {
;   for (; __res_nsend_ns; __res_nsend_ns++)
;     __res_nsend_statp.nsaddr_list[__res_nsend_ns] =
;         __res_nsend_statp.nsaddr_list[__res_nsend_ns + 1];
; }

%struct.wombat = type { i16, %struct.foo, [8 x i8] }
%struct.foo = type { i32 }

define void @no_preserve(ptr addrspace("A") noalias writeonly %dst, ptr addrspace("A") noalias readonly %src, i64 %count) local_unnamed_addr #0 {
; HYBRID-LABEL: define {{[^@]+}}@no_preserve
; HYBRID-SAME: (ptr noalias writeonly [[DST:%.*]], ptr noalias readonly [[SRC:%.*]], i64 [[COUNT:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
; HYBRID-NEXT:    [[CMP1:%.*]] = icmp sgt i64 [[COUNT]], 0
; HYBRID-NEXT:    br i1 [[CMP1]], label [[BB1_PREHEADER:%.*]], label [[BB2:%.*]]
; HYBRID:       bb1.preheader:
; HYBRID-NEXT:    [[UGLYGEP:%.*]] = getelementptr i8, ptr [[SRC]], i64 16
; HYBRID-NEXT:    [[TMP1:%.*]] = shl nuw i64 [[COUNT]], 4
; HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DST]], ptr align 4 [[UGLYGEP]], i64 [[TMP1]], i1 false) #[[ATTR2:[0-9]+]]
; HYBRID-NEXT:    br label [[BB2]]
; HYBRID:       bb2:
; HYBRID-NEXT:    ret void
;
; PURECAP-LABEL: define {{[^@]+}}@no_preserve
; PURECAP-SAME: (ptr addrspace(200) noalias writeonly [[DST:%.*]], ptr addrspace(200) noalias readonly [[SRC:%.*]], i64 [[COUNT:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
; PURECAP-NEXT:    [[CMP1:%.*]] = icmp sgt i64 [[COUNT]], 0
; PURECAP-NEXT:    br i1 [[CMP1]], label [[BB1:%.*]], label [[BB2:%.*]]
; PURECAP:       bb1:
; PURECAP-NEXT:    [[IDX:%.*]] = phi i64 [ [[ADD:%.*]], [[BB1]] ], [ 0, [[TMP0:%.*]] ]
; PURECAP-NEXT:    [[LDST:%.*]] = getelementptr [[STRUCT_WOMBAT:%.*]], ptr addrspace(200) [[DST]], i64 [[IDX]]
; PURECAP-NEXT:    [[ADD]] = add nuw nsw i64 [[IDX]], 1
; PURECAP-NEXT:    [[LSRC:%.*]] = getelementptr [[STRUCT_WOMBAT]], ptr addrspace(200) [[SRC]], i64 [[ADD]]
; PURECAP-NEXT:    tail call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) noundef nonnull align 16 dereferenceable(16) [[LDST]], ptr addrspace(200) noundef nonnull align 4 dereferenceable(16) [[LSRC]], i64 16, i1 false) #[[ATTR2:[0-9]+]]
; PURECAP-NEXT:    [[CMP2:%.*]] = icmp slt i64 [[ADD]], [[COUNT]]
; PURECAP-NEXT:    br i1 [[CMP2]], label [[BB1]], label [[BB2]]
; PURECAP:       bb2:
; PURECAP-NEXT:    ret void
;
  %cmp1 = icmp sgt i64 %count, 0
  br i1 %cmp1, label %bb1.preheader, label %bb2

bb1.preheader:
  br label %bb1

bb1:
  %idx = phi i64 [ %add, %bb1 ], [ 0, %bb1.preheader ]
  %ldst = getelementptr %struct.wombat, ptr addrspace("A") %dst, i64 %idx
  %add = add nuw nsw i64 %idx, 1
  %lsrc = getelementptr %struct.wombat, ptr addrspace("A") %src, i64 %add
  tail call void @llvm.memcpy.p200.p200.i64(ptr addrspace("A") noundef nonnull align 16 dereferenceable(16) %ldst, ptr addrspace("A") noundef nonnull align 4 dereferenceable(16) %lsrc, i64 16, i1 false) #1
  %cmp2 = icmp slt i64 %add, %count
  br i1 %cmp2, label %bb1, label %bb2.loopexit

bb2.loopexit:
  br label %bb2

bb2:
  ret void
}

define void @must_preserve(ptr addrspace("A") noalias writeonly %dst, ptr addrspace("A") noalias readonly %src, i64 %count) local_unnamed_addr #0 {
; HYBRID-LABEL: define {{[^@]+}}@must_preserve
; HYBRID-SAME: (ptr noalias writeonly [[DST:%.*]], ptr noalias readonly [[SRC:%.*]], i64 [[COUNT:%.*]]) local_unnamed_addr #[[ATTR0]] {
; HYBRID-NEXT:    [[CMP1:%.*]] = icmp sgt i64 [[COUNT]], 0
; HYBRID-NEXT:    br i1 [[CMP1]], label [[BB1_PREHEADER:%.*]], label [[BB2:%.*]]
; HYBRID:       bb1.preheader:
; HYBRID-NEXT:    [[UGLYGEP:%.*]] = getelementptr i8, ptr [[SRC]], i64 16
; HYBRID-NEXT:    [[TMP1:%.*]] = shl nuw i64 [[COUNT]], 4
; HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DST]], ptr align 4 [[UGLYGEP]], i64 [[TMP1]], i1 false) #[[ATTR3:[0-9]+]]
; HYBRID-NEXT:    br label [[BB2]]
; HYBRID:       bb2:
; HYBRID-NEXT:    ret void
;
; PURECAP-LABEL: define {{[^@]+}}@must_preserve
; PURECAP-SAME: (ptr addrspace(200) noalias writeonly [[DST:%.*]], ptr addrspace(200) noalias readonly [[SRC:%.*]], i64 [[COUNT:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
; PURECAP-NEXT:    [[CMP1:%.*]] = icmp sgt i64 [[COUNT]], 0
; PURECAP-NEXT:    br i1 [[CMP1]], label [[BB1:%.*]], label [[BB2:%.*]]
; PURECAP:       bb1:
; PURECAP-NEXT:    [[IDX:%.*]] = phi i64 [ [[ADD:%.*]], [[BB1]] ], [ 0, [[TMP0:%.*]] ]
; PURECAP-NEXT:    [[LDST:%.*]] = getelementptr [[STRUCT_WOMBAT:%.*]], ptr addrspace(200) [[DST]], i64 [[IDX]]
; PURECAP-NEXT:    [[ADD]] = add nuw nsw i64 [[IDX]], 1
; PURECAP-NEXT:    [[LSRC:%.*]] = getelementptr [[STRUCT_WOMBAT]], ptr addrspace(200) [[SRC]], i64 [[ADD]]
; PURECAP-NEXT:    tail call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) noundef nonnull align 16 dereferenceable(16) [[LDST]], ptr addrspace(200) noundef nonnull align 4 dereferenceable(16) [[LSRC]], i64 16, i1 false) #[[ATTR3:[0-9]+]]
; PURECAP-NEXT:    [[CMP2:%.*]] = icmp slt i64 [[ADD]], [[COUNT]]
; PURECAP-NEXT:    br i1 [[CMP2]], label [[BB1]], label [[BB2]]
; PURECAP:       bb2:
; PURECAP-NEXT:    ret void
;
  %cmp1 = icmp sgt i64 %count, 0
  br i1 %cmp1, label %bb1.preheader, label %bb2

bb1.preheader:
  br label %bb1

bb1:
  %idx = phi i64 [ %add, %bb1 ], [ 0, %bb1.preheader ]
  %ldst = getelementptr %struct.wombat, ptr addrspace("A") %dst, i64 %idx
  %add = add nuw nsw i64 %idx, 1
  %lsrc = getelementptr %struct.wombat, ptr addrspace("A") %src, i64 %add
  tail call void @llvm.memcpy.p200.p200.i64(ptr addrspace("A") noundef nonnull align 16 dereferenceable(16) %ldst, ptr addrspace("A") noundef nonnull align 4 dereferenceable(16) %lsrc, i64 16, i1 false) #2
  %cmp2 = icmp slt i64 %add, %count
  br i1 %cmp2, label %bb1, label %bb2.loopexit

bb2.loopexit:
  br label %bb2

bb2:
  ret void
}

declare void @llvm.memcpy.p200.p200.i64(ptr addrspace("A") noalias nocapture writeonly, ptr addrspace("A") noalias nocapture readonly, i64, i1 immarg)

attributes #0 = { nofree nosync nounwind }
attributes #1 = { no_preserve_cheri_tags }
attributes #2 = { must_preserve_cheri_tags }

; UTC_ARGS: --disable
; CHECK: attributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
; CHECK: attributes #[[ATTR2]] = { no_preserve_cheri_tags }
; CHECK: attributes #[[ATTR3]] = { must_preserve_cheri_tags }
